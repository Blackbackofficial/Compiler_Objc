// Code generated from ObjC.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // ObjC

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 145, 1338, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4, 
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97, 
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102, 
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106, 
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111, 
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115, 
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120, 
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124, 
	4, 125, 9, 125, 3, 2, 6, 2, 252, 10, 2, 13, 2, 14, 2, 253, 3, 2, 3, 2, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	5, 3, 270, 10, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 278, 10, 5, 
	3, 5, 5, 5, 281, 10, 5, 3, 5, 5, 5, 284, 10, 5, 3, 5, 5, 5, 287, 10, 5, 
	3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 295, 10, 6, 3, 6, 3, 6, 5, 6, 
	299, 10, 6, 3, 6, 5, 6, 302, 10, 6, 3, 6, 5, 6, 305, 10, 6, 3, 6, 3, 6, 
	3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 313, 10, 7, 3, 7, 5, 7, 316, 10, 7, 3, 7, 
	5, 7, 319, 10, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 
	329, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 5, 9, 336, 10, 9, 3, 9, 5, 9, 
	339, 10, 9, 3, 9, 5, 9, 342, 10, 9, 3, 9, 5, 9, 345, 10, 9, 3, 9, 3, 9, 
	3, 10, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 
	12, 7, 12, 360, 10, 12, 12, 12, 14, 12, 363, 11, 12, 3, 13, 3, 13, 3, 13, 
	3, 13, 3, 14, 3, 14, 3, 14, 7, 14, 372, 10, 14, 12, 14, 14, 14, 375, 11, 
	14, 3, 15, 3, 15, 5, 15, 379, 10, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 
	3, 16, 3, 17, 3, 17, 3, 17, 7, 17, 390, 10, 17, 12, 17, 14, 17, 393, 11, 
	17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 411, 10, 18, 3, 19, 3, 
	19, 3, 20, 3, 20, 3, 21, 3, 21, 3, 22, 3, 22, 3, 23, 3, 23, 7, 23, 423, 
	10, 23, 12, 23, 14, 23, 426, 11, 23, 3, 23, 3, 23, 3, 23, 3, 23, 6, 23, 
	432, 10, 23, 13, 23, 14, 23, 433, 3, 23, 3, 23, 3, 23, 3, 23, 6, 23, 440, 
	10, 23, 13, 23, 14, 23, 441, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 
	6, 23, 450, 10, 23, 13, 23, 14, 23, 451, 3, 23, 3, 23, 3, 23, 5, 23, 457, 
	10, 23, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 6, 25, 465, 10, 25, 13, 
	25, 14, 25, 466, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 28, 5, 28, 
	476, 10, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 6, 
	29, 486, 10, 29, 13, 29, 14, 29, 487, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 
	3, 31, 3, 32, 5, 32, 497, 10, 32, 3, 32, 3, 32, 5, 32, 501, 10, 32, 3, 
	32, 5, 32, 504, 10, 32, 3, 32, 3, 32, 3, 33, 3, 33, 6, 33, 510, 10, 33, 
	13, 33, 14, 33, 511, 3, 33, 5, 33, 515, 10, 33, 5, 33, 517, 10, 33, 3, 
	34, 5, 34, 520, 10, 34, 3, 34, 3, 34, 7, 34, 524, 10, 34, 12, 34, 14, 34, 
	527, 11, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 545, 10, 37, 
	3, 38, 3, 38, 3, 38, 7, 38, 550, 10, 38, 12, 38, 14, 38, 553, 11, 38, 3, 
	39, 3, 39, 3, 39, 3, 39, 5, 39, 559, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 
	5, 40, 565, 10, 40, 3, 40, 3, 40, 5, 40, 569, 10, 40, 3, 41, 3, 41, 3, 
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 582, 
	10, 41, 3, 41, 3, 41, 5, 41, 586, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 
	41, 5, 41, 593, 10, 41, 3, 42, 3, 42, 3, 42, 5, 42, 598, 10, 42, 3, 43, 
	3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 619, 10, 44, 
	3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 5, 46, 628, 10, 46, 3, 
	46, 3, 46, 7, 46, 632, 10, 46, 12, 46, 14, 46, 635, 11, 46, 3, 46, 5, 46, 
	638, 10, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 645, 10, 47, 3, 
	47, 3, 47, 7, 47, 649, 10, 47, 12, 47, 14, 47, 652, 11, 47, 3, 47, 5, 47, 
	655, 10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 
	48, 5, 48, 666, 10, 48, 3, 49, 3, 49, 3, 49, 5, 49, 671, 10, 49, 3, 49, 
	3, 49, 7, 49, 675, 10, 49, 12, 49, 14, 49, 678, 11, 49, 3, 49, 3, 49, 3, 
	50, 3, 50, 5, 50, 684, 10, 50, 3, 50, 5, 50, 687, 10, 50, 3, 50, 3, 50, 
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 5, 52, 699, 10, 
	52, 3, 53, 3, 53, 6, 53, 703, 10, 53, 13, 53, 14, 53, 704, 5, 53, 707, 
	10, 53, 3, 54, 5, 54, 710, 10, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 
	55, 3, 55, 3, 55, 3, 56, 3, 56, 5, 56, 722, 10, 56, 3, 56, 6, 56, 725, 
	10, 56, 13, 56, 14, 56, 726, 5, 56, 729, 10, 56, 3, 57, 3, 57, 3, 57, 3, 
	57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 60, 
	3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 
	62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 7, 64, 763, 10, 64, 
	12, 64, 14, 64, 766, 11, 64, 3, 64, 5, 64, 769, 10, 64, 3, 65, 3, 65, 3, 
	65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 67, 5, 67, 781, 10, 67, 
	3, 67, 3, 67, 3, 67, 3, 68, 3, 68, 5, 68, 788, 10, 68, 3, 68, 3, 68, 3, 
	69, 3, 69, 3, 69, 3, 69, 6, 69, 796, 10, 69, 13, 69, 14, 69, 797, 3, 70, 
	3, 70, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 7, 72, 807, 10, 72, 12, 72, 14, 
	72, 810, 11, 72, 3, 73, 3, 73, 3, 73, 5, 73, 815, 10, 73, 3, 74, 3, 74, 
	3, 74, 5, 74, 820, 10, 74, 3, 74, 3, 74, 6, 74, 824, 10, 74, 13, 74, 14, 
	74, 825, 3, 74, 3, 74, 5, 74, 830, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 
	3, 76, 3, 76, 3, 76, 6, 76, 839, 10, 76, 13, 76, 14, 76, 840, 3, 77, 3, 
	77, 3, 77, 7, 77, 846, 10, 77, 12, 77, 14, 77, 849, 11, 77, 3, 78, 3, 78, 
	5, 78, 853, 10, 78, 3, 78, 3, 78, 5, 78, 857, 10, 78, 3, 79, 3, 79, 3, 
	79, 5, 79, 862, 10, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 869, 
	10, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 875, 10, 79, 3, 79, 3, 79, 3, 
	79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 
	3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 897, 10, 79, 3, 
	80, 3, 80, 3, 80, 7, 80, 902, 10, 80, 12, 80, 14, 80, 905, 11, 80, 3, 80, 
	5, 80, 908, 10, 80, 3, 81, 3, 81, 3, 81, 5, 81, 913, 10, 81, 3, 82, 3, 
	82, 5, 82, 917, 10, 82, 3, 82, 3, 82, 5, 82, 921, 10, 82, 3, 82, 5, 82, 
	924, 10, 82, 3, 83, 5, 83, 927, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 7, 
	84, 933, 10, 84, 12, 84, 14, 84, 936, 11, 84, 3, 84, 3, 84, 3, 84, 3, 84, 
	7, 84, 942, 10, 84, 12, 84, 14, 84, 945, 11, 84, 3, 84, 3, 84, 3, 84, 5, 
	84, 950, 10, 84, 3, 84, 3, 84, 5, 84, 954, 10, 84, 3, 85, 3, 85, 5, 85, 
	958, 10, 85, 3, 85, 3, 85, 3, 85, 5, 85, 963, 10, 85, 3, 85, 5, 85, 966, 
	10, 85, 3, 86, 3, 86, 3, 86, 5, 86, 971, 10, 86, 3, 87, 3, 87, 5, 87, 975, 
	10, 87, 3, 87, 5, 87, 978, 10, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 7, 
	88, 985, 10, 88, 12, 88, 14, 88, 988, 11, 88, 3, 88, 5, 88, 991, 10, 88, 
	3, 88, 3, 88, 5, 88, 995, 10, 88, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1001, 
	10, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 6, 90, 1010, 10, 
	90, 13, 90, 14, 90, 1011, 3, 90, 3, 90, 5, 90, 1016, 10, 90, 3, 90, 6, 
	90, 1019, 10, 90, 13, 90, 14, 90, 1020, 3, 90, 5, 90, 1024, 10, 90, 3, 
	91, 3, 91, 5, 91, 1028, 10, 91, 3, 91, 3, 91, 3, 91, 5, 91, 1033, 10, 91, 
	3, 91, 5, 91, 1036, 10, 91, 3, 92, 3, 92, 3, 92, 7, 92, 1041, 10, 92, 12, 
	92, 14, 92, 1044, 11, 92, 3, 93, 6, 93, 1047, 10, 93, 13, 93, 14, 93, 1048, 
	3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 
	94, 3, 94, 5, 94, 1063, 10, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 
	3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1077, 10, 95, 3, 96, 3, 
	96, 3, 96, 7, 96, 1082, 10, 96, 12, 96, 14, 96, 1085, 11, 96, 3, 96, 3, 
	96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 1096, 10, 97, 
	3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 1104, 10, 97, 3, 98, 3, 
	98, 3, 98, 3, 98, 3, 98, 5, 98, 1111, 10, 98, 3, 98, 3, 98, 3, 98, 3, 99, 
	3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1122, 10, 99, 3, 99, 3, 99, 5, 
	99, 1126, 10, 99, 3, 99, 3, 99, 5, 99, 1130, 10, 99, 3, 99, 3, 99, 3, 99, 
	3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 101, 
	3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102, 3, 102, 
	5, 102, 1153, 10, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 
	3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1165, 10, 103, 3, 103, 5, 103, 
	1168, 10, 103, 3, 104, 3, 104, 3, 104, 7, 104, 1173, 10, 104, 12, 104, 
	14, 104, 1176, 11, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 
	1183, 10, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 
	3, 107, 5, 107, 1193, 10, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 109, 
	7, 109, 1200, 10, 109, 12, 109, 14, 109, 1203, 11, 109, 3, 110, 3, 110, 
	3, 110, 7, 110, 1208, 10, 110, 12, 110, 14, 110, 1211, 11, 110, 3, 111, 
	3, 111, 3, 111, 7, 111, 1216, 10, 111, 12, 111, 14, 111, 1219, 11, 111, 
	3, 112, 3, 112, 3, 112, 7, 112, 1224, 10, 112, 12, 112, 14, 112, 1227, 
	11, 112, 3, 113, 3, 113, 3, 113, 7, 113, 1232, 10, 113, 12, 113, 14, 113, 
	1235, 11, 113, 3, 114, 3, 114, 3, 114, 7, 114, 1240, 10, 114, 12, 114, 
	14, 114, 1243, 11, 114, 3, 115, 3, 115, 3, 115, 7, 115, 1248, 10, 115, 
	12, 115, 14, 115, 1251, 11, 115, 3, 116, 3, 116, 3, 116, 7, 116, 1256, 
	10, 116, 12, 116, 14, 116, 1259, 11, 116, 3, 117, 3, 117, 3, 117, 7, 117, 
	1264, 10, 117, 12, 117, 14, 117, 1267, 11, 117, 3, 118, 3, 118, 3, 118, 
	7, 118, 1272, 10, 118, 12, 118, 14, 118, 1275, 11, 118, 3, 119, 3, 119, 
	3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1283, 10, 119, 3, 120, 3, 120, 
	3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 3, 120, 
	3, 120, 3, 120, 3, 120, 5, 120, 1299, 10, 120, 5, 120, 1301, 10, 120, 3, 
	121, 3, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 5, 
	122, 1312, 10, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 
	122, 7, 122, 1321, 10, 122, 12, 122, 14, 122, 1324, 11, 122, 3, 123, 3, 
	123, 3, 123, 7, 123, 1329, 10, 123, 12, 123, 14, 123, 1332, 11, 123, 3, 
	124, 3, 124, 3, 125, 3, 125, 3, 125, 2, 2, 126, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 
	52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 
	88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 
	120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 
	150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 
	180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 
	210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 
	240, 242, 244, 246, 248, 2, 16, 3, 2, 134, 135, 5, 2, 12, 12, 15, 15, 17, 
	18, 5, 2, 30, 31, 46, 47, 51, 52, 3, 2, 69, 70, 7, 2, 27, 27, 41, 41, 53, 
	53, 58, 58, 61, 61, 4, 2, 59, 59, 62, 62, 4, 2, 82, 82, 107, 116, 4, 2, 
	89, 89, 92, 92, 4, 2, 83, 84, 90, 91, 3, 2, 105, 106, 3, 2, 97, 98, 4, 
	2, 99, 100, 104, 104, 5, 2, 85, 86, 98, 99, 101, 101, 4, 2, 128, 128, 130, 
	133, 2, 1447, 2, 251, 3, 2, 2, 2, 4, 269, 3, 2, 2, 2, 6, 271, 3, 2, 2, 
	2, 8, 273, 3, 2, 2, 2, 10, 290, 3, 2, 2, 2, 12, 308, 3, 2, 2, 2, 14, 322, 
	3, 2, 2, 2, 16, 332, 3, 2, 2, 2, 18, 348, 3, 2, 2, 2, 20, 352, 3, 2, 2, 
	2, 22, 356, 3, 2, 2, 2, 24, 364, 3, 2, 2, 2, 26, 368, 3, 2, 2, 2, 28, 376, 
	3, 2, 2, 2, 30, 382, 3, 2, 2, 2, 32, 386, 3, 2, 2, 2, 34, 410, 3, 2, 2, 
	2, 36, 412, 3, 2, 2, 2, 38, 414, 3, 2, 2, 2, 40, 416, 3, 2, 2, 2, 42, 418, 
	3, 2, 2, 2, 44, 456, 3, 2, 2, 2, 46, 458, 3, 2, 2, 2, 48, 464, 3, 2, 2, 
	2, 50, 468, 3, 2, 2, 2, 52, 471, 3, 2, 2, 2, 54, 475, 3, 2, 2, 2, 56, 485, 
	3, 2, 2, 2, 58, 489, 3, 2, 2, 2, 60, 492, 3, 2, 2, 2, 62, 496, 3, 2, 2, 
	2, 64, 516, 3, 2, 2, 2, 66, 519, 3, 2, 2, 2, 68, 530, 3, 2, 2, 2, 70, 532, 
	3, 2, 2, 2, 72, 544, 3, 2, 2, 2, 74, 546, 3, 2, 2, 2, 76, 558, 3, 2, 2, 
	2, 78, 560, 3, 2, 2, 2, 80, 592, 3, 2, 2, 2, 82, 597, 3, 2, 2, 2, 84, 599, 
	3, 2, 2, 2, 86, 618, 3, 2, 2, 2, 88, 620, 3, 2, 2, 2, 90, 624, 3, 2, 2, 
	2, 92, 641, 3, 2, 2, 2, 94, 665, 3, 2, 2, 2, 96, 667, 3, 2, 2, 2, 98, 681, 
	3, 2, 2, 2, 100, 690, 3, 2, 2, 2, 102, 698, 3, 2, 2, 2, 104, 706, 3, 2, 
	2, 2, 106, 709, 3, 2, 2, 2, 108, 714, 3, 2, 2, 2, 110, 728, 3, 2, 2, 2, 
	112, 730, 3, 2, 2, 2, 114, 735, 3, 2, 2, 2, 116, 740, 3, 2, 2, 2, 118, 
	743, 3, 2, 2, 2, 120, 746, 3, 2, 2, 2, 122, 752, 3, 2, 2, 2, 124, 755, 
	3, 2, 2, 2, 126, 760, 3, 2, 2, 2, 128, 770, 3, 2, 2, 2, 130, 776, 3, 2, 
	2, 2, 132, 780, 3, 2, 2, 2, 134, 785, 3, 2, 2, 2, 136, 795, 3, 2, 2, 2, 
	138, 799, 3, 2, 2, 2, 140, 801, 3, 2, 2, 2, 142, 803, 3, 2, 2, 2, 144, 
	811, 3, 2, 2, 2, 146, 816, 3, 2, 2, 2, 148, 831, 3, 2, 2, 2, 150, 838, 
	3, 2, 2, 2, 152, 842, 3, 2, 2, 2, 154, 856, 3, 2, 2, 2, 156, 896, 3, 2, 
	2, 2, 158, 898, 3, 2, 2, 2, 160, 909, 3, 2, 2, 2, 162, 923, 3, 2, 2, 2, 
	164, 926, 3, 2, 2, 2, 166, 953, 3, 2, 2, 2, 168, 965, 3, 2, 2, 2, 170, 
	967, 3, 2, 2, 2, 172, 972, 3, 2, 2, 2, 174, 994, 3, 2, 2, 2, 176, 1000, 
	3, 2, 2, 2, 178, 1023, 3, 2, 2, 2, 180, 1035, 3, 2, 2, 2, 182, 1037, 3, 
	2, 2, 2, 184, 1046, 3, 2, 2, 2, 186, 1062, 3, 2, 2, 2, 188, 1076, 3, 2, 
	2, 2, 190, 1078, 3, 2, 2, 2, 192, 1103, 3, 2, 2, 2, 194, 1105, 3, 2, 2, 
	2, 196, 1115, 3, 2, 2, 2, 198, 1134, 3, 2, 2, 2, 200, 1140, 3, 2, 2, 2, 
	202, 1152, 3, 2, 2, 2, 204, 1167, 3, 2, 2, 2, 206, 1169, 3, 2, 2, 2, 208, 
	1182, 3, 2, 2, 2, 210, 1184, 3, 2, 2, 2, 212, 1186, 3, 2, 2, 2, 214, 1194, 
	3, 2, 2, 2, 216, 1196, 3, 2, 2, 2, 218, 1204, 3, 2, 2, 2, 220, 1212, 3, 
	2, 2, 2, 222, 1220, 3, 2, 2, 2, 224, 1228, 3, 2, 2, 2, 226, 1236, 3, 2, 
	2, 2, 228, 1244, 3, 2, 2, 2, 230, 1252, 3, 2, 2, 2, 232, 1260, 3, 2, 2, 
	2, 234, 1268, 3, 2, 2, 2, 236, 1282, 3, 2, 2, 2, 238, 1300, 3, 2, 2, 2, 
	240, 1302, 3, 2, 2, 2, 242, 1304, 3, 2, 2, 2, 244, 1325, 3, 2, 2, 2, 246, 
	1333, 3, 2, 2, 2, 248, 1335, 3, 2, 2, 2, 250, 252, 5, 4, 3, 2, 251, 250, 
	3, 2, 2, 2, 252, 253, 3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 253, 254, 3, 2, 
	2, 2, 254, 255, 3, 2, 2, 2, 255, 256, 7, 2, 2, 3, 256, 3, 3, 2, 2, 2, 257, 
	270, 7, 138, 2, 2, 258, 270, 7, 139, 2, 2, 259, 270, 5, 6, 4, 2, 260, 270, 
	5, 132, 67, 2, 261, 270, 5, 134, 68, 2, 262, 270, 5, 8, 5, 2, 263, 270, 
	5, 12, 7, 2, 264, 270, 5, 10, 6, 2, 265, 270, 5, 14, 8, 2, 266, 270, 5, 
	16, 9, 2, 267, 270, 5, 18, 10, 2, 268, 270, 5, 20, 11, 2, 269, 257, 3, 
	2, 2, 2, 269, 258, 3, 2, 2, 2, 269, 259, 3, 2, 2, 2, 269, 260, 3, 2, 2, 
	2, 269, 261, 3, 2, 2, 2, 269, 262, 3, 2, 2, 2, 269, 263, 3, 2, 2, 2, 269, 
	264, 3, 2, 2, 2, 269, 265, 3, 2, 2, 2, 269, 266, 3, 2, 2, 2, 269, 267, 
	3, 2, 2, 2, 269, 268, 3, 2, 2, 2, 270, 5, 3, 2, 2, 2, 271, 272, 9, 2, 2, 
	2, 272, 7, 3, 2, 2, 2, 273, 274, 7, 11, 2, 2, 274, 277, 5, 36, 19, 2, 275, 
	276, 7, 88, 2, 2, 276, 278, 5, 38, 20, 2, 277, 275, 3, 2, 2, 2, 277, 278, 
	3, 2, 2, 2, 278, 280, 3, 2, 2, 2, 279, 281, 5, 24, 13, 2, 280, 279, 3, 
	2, 2, 2, 280, 281, 3, 2, 2, 2, 281, 283, 3, 2, 2, 2, 282, 284, 5, 44, 23, 
	2, 283, 282, 3, 2, 2, 2, 283, 284, 3, 2, 2, 2, 284, 286, 3, 2, 2, 2, 285, 
	287, 5, 48, 25, 2, 286, 285, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 288, 
	3, 2, 2, 2, 288, 289, 7, 8, 2, 2, 289, 9, 3, 2, 2, 2, 290, 291, 7, 11, 
	2, 2, 291, 292, 5, 36, 19, 2, 292, 294, 7, 71, 2, 2, 293, 295, 5, 40, 21, 
	2, 294, 293, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 
	298, 7, 72, 2, 2, 297, 299, 5, 24, 13, 2, 298, 297, 3, 2, 2, 2, 298, 299, 
	3, 2, 2, 2, 299, 301, 3, 2, 2, 2, 300, 302, 5, 44, 23, 2, 301, 300, 3, 
	2, 2, 2, 301, 302, 3, 2, 2, 2, 302, 304, 3, 2, 2, 2, 303, 305, 5, 48, 25, 
	2, 304, 303, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 
	307, 7, 8, 2, 2, 307, 11, 3, 2, 2, 2, 308, 309, 7, 10, 2, 2, 309, 312, 
	5, 36, 19, 2, 310, 311, 7, 88, 2, 2, 311, 313, 5, 38, 20, 2, 312, 310, 
	3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 315, 3, 2, 2, 2, 314, 316, 5, 44, 
	23, 2, 315, 314, 3, 2, 2, 2, 315, 316, 3, 2, 2, 2, 316, 318, 3, 2, 2, 2, 
	317, 319, 5, 56, 29, 2, 318, 317, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 
	320, 3, 2, 2, 2, 320, 321, 7, 8, 2, 2, 321, 13, 3, 2, 2, 2, 322, 323, 7, 
	10, 2, 2, 323, 324, 5, 36, 19, 2, 324, 325, 7, 71, 2, 2, 325, 326, 5, 40, 
	21, 2, 326, 328, 7, 72, 2, 2, 327, 329, 5, 56, 29, 2, 328, 327, 3, 2, 2, 
	2, 328, 329, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 331, 7, 8, 2, 2, 331, 
	15, 3, 2, 2, 2, 332, 333, 7, 13, 2, 2, 333, 335, 5, 42, 22, 2, 334, 336, 
	5, 24, 13, 2, 335, 334, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 338, 3, 
	2, 2, 2, 337, 339, 5, 48, 25, 2, 338, 337, 3, 2, 2, 2, 338, 339, 3, 2, 
	2, 2, 339, 341, 3, 2, 2, 2, 340, 342, 7, 14, 2, 2, 341, 340, 3, 2, 2, 2, 
	341, 342, 3, 2, 2, 2, 342, 344, 3, 2, 2, 2, 343, 345, 5, 48, 25, 2, 344, 
	343, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 347, 
	7, 8, 2, 2, 347, 17, 3, 2, 2, 2, 348, 349, 7, 13, 2, 2, 349, 350, 5, 26, 
	14, 2, 350, 351, 7, 77, 2, 2, 351, 19, 3, 2, 2, 2, 352, 353, 7, 5, 2, 2, 
	353, 354, 5, 22, 12, 2, 354, 355, 7, 77, 2, 2, 355, 21, 3, 2, 2, 2, 356, 
	361, 5, 36, 19, 2, 357, 358, 7, 78, 2, 2, 358, 360, 5, 36, 19, 2, 359, 
	357, 3, 2, 2, 2, 360, 363, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 361, 362, 
	3, 2, 2, 2, 362, 23, 3, 2, 2, 2, 363, 361, 3, 2, 2, 2, 364, 365, 7, 84, 
	2, 2, 365, 366, 5, 26, 14, 2, 366, 367, 7, 83, 2, 2, 367, 25, 3, 2, 2, 
	2, 368, 373, 5, 42, 22, 2, 369, 370, 7, 78, 2, 2, 370, 372, 5, 42, 22, 
	2, 371, 369, 3, 2, 2, 2, 372, 375, 3, 2, 2, 2, 373, 371, 3, 2, 2, 2, 373, 
	374, 3, 2, 2, 2, 374, 27, 3, 2, 2, 2, 375, 373, 3, 2, 2, 2, 376, 378, 7, 
	16, 2, 2, 377, 379, 5, 30, 16, 2, 378, 377, 3, 2, 2, 2, 378, 379, 3, 2, 
	2, 2, 379, 380, 3, 2, 2, 2, 380, 381, 5, 148, 75, 2, 381, 29, 3, 2, 2, 
	2, 382, 383, 7, 71, 2, 2, 383, 384, 5, 32, 17, 2, 384, 385, 7, 72, 2, 2, 
	385, 31, 3, 2, 2, 2, 386, 391, 5, 34, 18, 2, 387, 388, 7, 78, 2, 2, 388, 
	390, 5, 34, 18, 2, 389, 387, 3, 2, 2, 2, 390, 393, 3, 2, 2, 2, 391, 389, 
	3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 33, 3, 2, 2, 2, 393, 391, 3, 2, 
	2, 2, 394, 411, 7, 120, 2, 2, 395, 411, 7, 118, 2, 2, 396, 411, 7, 126, 
	2, 2, 397, 411, 7, 122, 2, 2, 398, 411, 7, 123, 2, 2, 399, 411, 7, 124, 
	2, 2, 400, 411, 7, 125, 2, 2, 401, 411, 3, 2, 2, 2, 402, 403, 7, 119, 2, 
	2, 403, 404, 7, 82, 2, 2, 404, 411, 7, 127, 2, 2, 405, 406, 7, 121, 2, 
	2, 406, 407, 7, 82, 2, 2, 407, 408, 7, 127, 2, 2, 408, 411, 7, 88, 2, 2, 
	409, 411, 7, 127, 2, 2, 410, 394, 3, 2, 2, 2, 410, 395, 3, 2, 2, 2, 410, 
	396, 3, 2, 2, 2, 410, 397, 3, 2, 2, 2, 410, 398, 3, 2, 2, 2, 410, 399, 
	3, 2, 2, 2, 410, 400, 3, 2, 2, 2, 410, 401, 3, 2, 2, 2, 410, 402, 3, 2, 
	2, 2, 410, 405, 3, 2, 2, 2, 410, 409, 3, 2, 2, 2, 411, 35, 3, 2, 2, 2, 
	412, 413, 7, 127, 2, 2, 413, 37, 3, 2, 2, 2, 414, 415, 7, 127, 2, 2, 415, 
	39, 3, 2, 2, 2, 416, 417, 7, 127, 2, 2, 417, 41, 3, 2, 2, 2, 418, 419, 
	7, 127, 2, 2, 419, 43, 3, 2, 2, 2, 420, 424, 7, 73, 2, 2, 421, 423, 5, 
	148, 75, 2, 422, 421, 3, 2, 2, 2, 423, 426, 3, 2, 2, 2, 424, 422, 3, 2, 
	2, 2, 424, 425, 3, 2, 2, 2, 425, 427, 3, 2, 2, 2, 426, 424, 3, 2, 2, 2, 
	427, 457, 7, 74, 2, 2, 428, 429, 7, 73, 2, 2, 429, 431, 5, 46, 24, 2, 430, 
	432, 5, 148, 75, 2, 431, 430, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 431, 
	3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435, 436, 7, 74, 
	2, 2, 436, 457, 3, 2, 2, 2, 437, 439, 7, 73, 2, 2, 438, 440, 5, 148, 75, 
	2, 439, 438, 3, 2, 2, 2, 440, 441, 3, 2, 2, 2, 441, 439, 3, 2, 2, 2, 441, 
	442, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 444, 5, 44, 23, 2, 444, 445, 
	7, 74, 2, 2, 445, 457, 3, 2, 2, 2, 446, 447, 7, 73, 2, 2, 447, 449, 5, 
	46, 24, 2, 448, 450, 5, 148, 75, 2, 449, 448, 3, 2, 2, 2, 450, 451, 3, 
	2, 2, 2, 451, 449, 3, 2, 2, 2, 451, 452, 3, 2, 2, 2, 452, 453, 3, 2, 2, 
	2, 453, 454, 5, 44, 23, 2, 454, 455, 7, 74, 2, 2, 455, 457, 3, 2, 2, 2, 
	456, 420, 3, 2, 2, 2, 456, 428, 3, 2, 2, 2, 456, 437, 3, 2, 2, 2, 456, 
	446, 3, 2, 2, 2, 457, 45, 3, 2, 2, 2, 458, 459, 9, 3, 2, 2, 459, 47, 3, 
	2, 2, 2, 460, 465, 5, 134, 68, 2, 461, 465, 5, 50, 26, 2, 462, 465, 5, 
	52, 27, 2, 463, 465, 5, 28, 15, 2, 464, 460, 3, 2, 2, 2, 464, 461, 3, 2, 
	2, 2, 464, 462, 3, 2, 2, 2, 464, 463, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 
	466, 464, 3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 49, 3, 2, 2, 2, 468, 469, 
	7, 97, 2, 2, 469, 470, 5, 54, 28, 2, 470, 51, 3, 2, 2, 2, 471, 472, 7, 
	98, 2, 2, 472, 473, 5, 54, 28, 2, 473, 53, 3, 2, 2, 2, 474, 476, 5, 70, 
	36, 2, 475, 474, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2, 
	477, 478, 5, 64, 33, 2, 478, 479, 7, 77, 2, 2, 479, 55, 3, 2, 2, 2, 480, 
	486, 5, 132, 67, 2, 481, 486, 5, 134, 68, 2, 482, 486, 5, 58, 30, 2, 483, 
	486, 5, 60, 31, 2, 484, 486, 5, 72, 37, 2, 485, 480, 3, 2, 2, 2, 485, 481, 
	3, 2, 2, 2, 485, 482, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 485, 484, 3, 2, 
	2, 2, 486, 487, 3, 2, 2, 2, 487, 485, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 
	488, 57, 3, 2, 2, 2, 489, 490, 7, 97, 2, 2, 490, 491, 5, 62, 32, 2, 491, 
	59, 3, 2, 2, 2, 492, 493, 7, 98, 2, 2, 493, 494, 5, 62, 32, 2, 494, 61, 
	3, 2, 2, 2, 495, 497, 5, 70, 36, 2, 496, 495, 3, 2, 2, 2, 496, 497, 3, 
	2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 500, 5, 64, 33, 2, 499, 501, 5, 142, 
	72, 2, 500, 499, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 503, 3, 2, 2, 2, 
	502, 504, 7, 77, 2, 2, 503, 502, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 
	505, 3, 2, 2, 2, 505, 506, 5, 190, 96, 2, 506, 63, 3, 2, 2, 2, 507, 517, 
	5, 68, 35, 2, 508, 510, 5, 66, 34, 2, 509, 508, 3, 2, 2, 2, 510, 511, 3, 
	2, 2, 2, 511, 509, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 514, 3, 2, 2, 
	2, 513, 515, 5, 170, 86, 2, 514, 513, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 
	515, 517, 3, 2, 2, 2, 516, 507, 3, 2, 2, 2, 516, 509, 3, 2, 2, 2, 517, 
	65, 3, 2, 2, 2, 518, 520, 5, 68, 35, 2, 519, 518, 3, 2, 2, 2, 519, 520, 
	3, 2, 2, 2, 520, 521, 3, 2, 2, 2, 521, 525, 7, 88, 2, 2, 522, 524, 5, 70, 
	36, 2, 523, 522, 3, 2, 2, 2, 524, 527, 3, 2, 2, 2, 525, 523, 3, 2, 2, 2, 
	525, 526, 3, 2, 2, 2, 526, 528, 3, 2, 2, 2, 527, 525, 3, 2, 2, 2, 528, 
	529, 7, 127, 2, 2, 529, 67, 3, 2, 2, 2, 530, 531, 7, 127, 2, 2, 531, 69, 
	3, 2, 2, 2, 532, 533, 7, 71, 2, 2, 533, 534, 5, 176, 89, 2, 534, 535, 7, 
	72, 2, 2, 535, 71, 3, 2, 2, 2, 536, 537, 7, 21, 2, 2, 537, 538, 5, 74, 
	38, 2, 538, 539, 7, 77, 2, 2, 539, 545, 3, 2, 2, 2, 540, 541, 7, 6, 2, 
	2, 541, 542, 5, 74, 38, 2, 542, 543, 7, 77, 2, 2, 543, 545, 3, 2, 2, 2, 
	544, 536, 3, 2, 2, 2, 544, 540, 3, 2, 2, 2, 545, 73, 3, 2, 2, 2, 546, 551, 
	5, 76, 39, 2, 547, 548, 7, 78, 2, 2, 548, 550, 5, 76, 39, 2, 549, 547, 
	3, 2, 2, 2, 550, 553, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 551, 552, 3, 2, 
	2, 2, 552, 75, 3, 2, 2, 2, 553, 551, 3, 2, 2, 2, 554, 559, 7, 127, 2, 2, 
	555, 556, 7, 127, 2, 2, 556, 557, 7, 82, 2, 2, 557, 559, 7, 127, 2, 2, 
	558, 554, 3, 2, 2, 2, 558, 555, 3, 2, 2, 2, 559, 77, 3, 2, 2, 2, 560, 561, 
	5, 80, 41, 2, 561, 562, 7, 71, 2, 2, 562, 564, 7, 103, 2, 2, 563, 565, 
	5, 80, 41, 2, 564, 563, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 566, 3, 
	2, 2, 2, 566, 568, 7, 72, 2, 2, 567, 569, 5, 96, 49, 2, 568, 567, 3, 2, 
	2, 2, 568, 569, 3, 2, 2, 2, 569, 79, 3, 2, 2, 2, 570, 593, 7, 64, 2, 2, 
	571, 593, 7, 33, 2, 2, 572, 593, 7, 55, 2, 2, 573, 593, 7, 49, 2, 2, 574, 
	593, 7, 50, 2, 2, 575, 593, 7, 42, 2, 2, 576, 593, 7, 38, 2, 2, 577, 593, 
	7, 56, 2, 2, 578, 593, 7, 63, 2, 2, 579, 581, 7, 44, 2, 2, 580, 582, 5, 
	24, 13, 2, 581, 580, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 593, 3, 2, 
	2, 2, 583, 585, 5, 36, 19, 2, 584, 586, 5, 24, 13, 2, 585, 584, 3, 2, 2, 
	2, 585, 586, 3, 2, 2, 2, 586, 593, 3, 2, 2, 2, 587, 593, 5, 146, 74, 2, 
	588, 593, 5, 156, 79, 2, 589, 593, 7, 127, 2, 2, 590, 591, 7, 127, 2, 2, 
	591, 593, 5, 162, 82, 2, 592, 570, 3, 2, 2, 2, 592, 571, 3, 2, 2, 2, 592, 
	572, 3, 2, 2, 2, 592, 573, 3, 2, 2, 2, 592, 574, 3, 2, 2, 2, 592, 575, 
	3, 2, 2, 2, 592, 576, 3, 2, 2, 2, 592, 577, 3, 2, 2, 2, 592, 578, 3, 2, 
	2, 2, 592, 579, 3, 2, 2, 2, 592, 583, 3, 2, 2, 2, 592, 587, 3, 2, 2, 2, 
	592, 588, 3, 2, 2, 2, 592, 589, 3, 2, 2, 2, 592, 590, 3, 2, 2, 2, 593, 
	81, 3, 2, 2, 2, 594, 598, 7, 34, 2, 2, 595, 598, 7, 65, 2, 2, 596, 598, 
	5, 84, 43, 2, 597, 594, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 597, 596, 3, 
	2, 2, 2, 598, 83, 3, 2, 2, 2, 599, 600, 9, 4, 2, 2, 600, 85, 3, 2, 2, 2, 
	601, 619, 7, 127, 2, 2, 602, 619, 5, 248, 125, 2, 603, 619, 7, 129, 2, 
	2, 604, 605, 7, 71, 2, 2, 605, 606, 5, 206, 104, 2, 606, 607, 7, 72, 2, 
	2, 607, 619, 3, 2, 2, 2, 608, 619, 7, 25, 2, 2, 609, 619, 7, 24, 2, 2, 
	610, 619, 5, 100, 51, 2, 611, 619, 5, 108, 55, 2, 612, 619, 5, 112, 57, 
	2, 613, 619, 5, 114, 58, 2, 614, 619, 5, 90, 46, 2, 615, 619, 5, 92, 47, 
	2, 616, 619, 5, 94, 48, 2, 617, 619, 5, 98, 50, 2, 618, 601, 3, 2, 2, 2, 
	618, 602, 3, 2, 2, 2, 618, 603, 3, 2, 2, 2, 618, 604, 3, 2, 2, 2, 618, 
	608, 3, 2, 2, 2, 618, 609, 3, 2, 2, 2, 618, 610, 3, 2, 2, 2, 618, 611, 
	3, 2, 2, 2, 618, 612, 3, 2, 2, 2, 618, 613, 3, 2, 2, 2, 618, 614, 3, 2, 
	2, 2, 618, 615, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2, 618, 617, 3, 2, 2, 2, 
	619, 87, 3, 2, 2, 2, 620, 621, 5, 242, 122, 2, 621, 622, 7, 88, 2, 2, 622, 
	623, 5, 242, 122, 2, 623, 89, 3, 2, 2, 2, 624, 625, 7, 81, 2, 2, 625, 627, 
	7, 73, 2, 2, 626, 628, 5, 88, 45, 2, 627, 626, 3, 2, 2, 2, 627, 628, 3, 
	2, 2, 2, 628, 633, 3, 2, 2, 2, 629, 630, 7, 78, 2, 2, 630, 632, 5, 88, 
	45, 2, 631, 629, 3, 2, 2, 2, 632, 635, 3, 2, 2, 2, 633, 631, 3, 2, 2, 2, 
	633, 634, 3, 2, 2, 2, 634, 637, 3, 2, 2, 2, 635, 633, 3, 2, 2, 2, 636, 
	638, 7, 78, 2, 2, 637, 636, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 639, 
	3, 2, 2, 2, 639, 640, 7, 74, 2, 2, 640, 91, 3, 2, 2, 2, 641, 642, 7, 81, 
	2, 2, 642, 644, 7, 75, 2, 2, 643, 645, 5, 242, 122, 2, 644, 643, 3, 2, 
	2, 2, 644, 645, 3, 2, 2, 2, 645, 650, 3, 2, 2, 2, 646, 647, 7, 78, 2, 2, 
	647, 649, 5, 242, 122, 2, 648, 646, 3, 2, 2, 2, 649, 652, 3, 2, 2, 2, 650, 
	648, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 654, 3, 2, 2, 2, 652, 650, 
	3, 2, 2, 2, 653, 655, 7, 78, 2, 2, 654, 653, 3, 2, 2, 2, 654, 655, 3, 2, 
	2, 2, 655, 656, 3, 2, 2, 2, 656, 657, 7, 76, 2, 2, 657, 93, 3, 2, 2, 2, 
	658, 659, 7, 81, 2, 2, 659, 660, 7, 71, 2, 2, 660, 661, 5, 242, 122, 2, 
	661, 662, 7, 72, 2, 2, 662, 666, 3, 2, 2, 2, 663, 664, 7, 81, 2, 2, 664, 
	666, 5, 248, 125, 2, 665, 658, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 666, 95, 
	3, 2, 2, 2, 667, 670, 7, 71, 2, 2, 668, 671, 5, 116, 59, 2, 669, 671, 7, 
	64, 2, 2, 670, 668, 3, 2, 2, 2, 670, 669, 3, 2, 2, 2, 670, 671, 3, 2, 2, 
	2, 671, 676, 3, 2, 2, 2, 672, 673, 7, 78, 2, 2, 673, 675, 5, 116, 59, 2, 
	674, 672, 3, 2, 2, 2, 675, 678, 3, 2, 2, 2, 676, 674, 3, 2, 2, 2, 676, 
	677, 3, 2, 2, 2, 677, 679, 3, 2, 2, 2, 678, 676, 3, 2, 2, 2, 679, 680, 
	7, 72, 2, 2, 680, 97, 3, 2, 2, 2, 681, 683, 7, 103, 2, 2, 682, 684, 5, 
	80, 41, 2, 683, 682, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 686, 3, 2, 
	2, 2, 685, 687, 5, 96, 49, 2, 686, 685, 3, 2, 2, 2, 686, 687, 3, 2, 2, 
	2, 687, 688, 3, 2, 2, 2, 688, 689, 5, 190, 96, 2, 689, 99, 3, 2, 2, 2, 
	690, 691, 7, 75, 2, 2, 691, 692, 5, 102, 52, 2, 692, 693, 5, 104, 53, 2, 
	693, 694, 7, 76, 2, 2, 694, 101, 3, 2, 2, 2, 695, 699, 5, 206, 104, 2, 
	696, 699, 5, 36, 19, 2, 697, 699, 7, 24, 2, 2, 698, 695, 3, 2, 2, 2, 698, 
	696, 3, 2, 2, 2, 698, 697, 3, 2, 2, 2, 699, 103, 3, 2, 2, 2, 700, 707, 
	5, 68, 35, 2, 701, 703, 5, 106, 54, 2, 702, 701, 3, 2, 2, 2, 703, 704, 
	3, 2, 2, 2, 704, 702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 707, 3, 2, 
	2, 2, 706, 700, 3, 2, 2, 2, 706, 702, 3, 2, 2, 2, 707, 105, 3, 2, 2, 2, 
	708, 710, 5, 68, 35, 2, 709, 708, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 
	711, 3, 2, 2, 2, 711, 712, 7, 88, 2, 2, 712, 713, 5, 206, 104, 2, 713, 
	107, 3, 2, 2, 2, 714, 715, 7, 19, 2, 2, 715, 716, 7, 71, 2, 2, 716, 717, 
	5, 110, 56, 2, 717, 718, 7, 72, 2, 2, 718, 109, 3, 2, 2, 2, 719, 729, 5, 
	68, 35, 2, 720, 722, 5, 68, 35, 2, 721, 720, 3, 2, 2, 2, 721, 722, 3, 2, 
	2, 2, 722, 723, 3, 2, 2, 2, 723, 725, 7, 88, 2, 2, 724, 721, 3, 2, 2, 2, 
	725, 726, 3, 2, 2, 2, 726, 724, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2, 727, 
	729, 3, 2, 2, 2, 728, 719, 3, 2, 2, 2, 728, 724, 3, 2, 2, 2, 729, 111, 
	3, 2, 2, 2, 730, 731, 7, 13, 2, 2, 731, 732, 7, 71, 2, 2, 732, 733, 5, 
	42, 22, 2, 733, 734, 7, 72, 2, 2, 734, 113, 3, 2, 2, 2, 735, 736, 7, 7, 
	2, 2, 736, 737, 7, 71, 2, 2, 737, 738, 5, 176, 89, 2, 738, 739, 7, 72, 
	2, 2, 739, 115, 3, 2, 2, 2, 740, 741, 5, 136, 69, 2, 741, 742, 5, 164, 
	83, 2, 742, 117, 3, 2, 2, 2, 743, 744, 7, 23, 2, 2, 744, 745, 5, 190, 96, 
	2, 745, 119, 3, 2, 2, 2, 746, 747, 7, 4, 2, 2, 747, 748, 7, 71, 2, 2, 748, 
	749, 5, 116, 59, 2, 749, 750, 7, 72, 2, 2, 750, 751, 5, 190, 96, 2, 751, 
	121, 3, 2, 2, 2, 752, 753, 7, 9, 2, 2, 753, 754, 5, 190, 96, 2, 754, 123, 
	3, 2, 2, 2, 755, 756, 7, 22, 2, 2, 756, 757, 7, 71, 2, 2, 757, 758, 7, 
	127, 2, 2, 758, 759, 7, 72, 2, 2, 759, 125, 3, 2, 2, 2, 760, 764, 5, 118, 
	60, 2, 761, 763, 5, 120, 61, 2, 762, 761, 3, 2, 2, 2, 763, 766, 3, 2, 2, 
	2, 764, 762, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 
	764, 3, 2, 2, 2, 767, 769, 5, 122, 62, 2, 768, 767, 3, 2, 2, 2, 768, 769, 
	3, 2, 2, 2, 769, 127, 3, 2, 2, 2, 770, 771, 7, 20, 2, 2, 771, 772, 7, 71, 
	2, 2, 772, 773, 5, 86, 44, 2, 773, 774, 7, 72, 2, 2, 774, 775, 5, 190, 
	96, 2, 775, 129, 3, 2, 2, 2, 776, 777, 7, 3, 2, 2, 777, 778, 5, 190, 96, 
	2, 778, 131, 3, 2, 2, 2, 779, 781, 5, 136, 69, 2, 780, 779, 3, 2, 2, 2, 
	780, 781, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 783, 5, 164, 83, 2, 783, 
	784, 5, 190, 96, 2, 784, 133, 3, 2, 2, 2, 785, 787, 5, 136, 69, 2, 786, 
	788, 5, 142, 72, 2, 787, 786, 3, 2, 2, 2, 787, 788, 3, 2, 2, 2, 788, 789, 
	3, 2, 2, 2, 789, 790, 7, 77, 2, 2, 790, 135, 3, 2, 2, 2, 791, 796, 5, 138, 
	70, 2, 792, 796, 5, 140, 71, 2, 793, 796, 5, 80, 41, 2, 794, 796, 5, 82, 
	42, 2, 795, 791, 3, 2, 2, 2, 795, 792, 3, 2, 2, 2, 795, 793, 3, 2, 2, 2, 
	795, 794, 3, 2, 2, 2, 796, 797, 3, 2, 2, 2, 797, 795, 3, 2, 2, 2, 797, 
	798, 3, 2, 2, 2, 798, 137, 3, 2, 2, 2, 799, 800, 9, 5, 2, 2, 800, 139, 
	3, 2, 2, 2, 801, 802, 9, 6, 2, 2, 802, 141, 3, 2, 2, 2, 803, 808, 5, 144, 
	73, 2, 804, 805, 7, 78, 2, 2, 805, 807, 5, 144, 73, 2, 806, 804, 3, 2, 
	2, 2, 807, 810, 3, 2, 2, 2, 808, 806, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 
	809, 143, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 811, 814, 5, 164, 83, 2, 812, 
	813, 7, 82, 2, 2, 813, 815, 5, 174, 88, 2, 814, 812, 3, 2, 2, 2, 814, 815, 
	3, 2, 2, 2, 815, 145, 3, 2, 2, 2, 816, 829, 9, 7, 2, 2, 817, 830, 7, 127, 
	2, 2, 818, 820, 7, 127, 2, 2, 819, 818, 3, 2, 2, 2, 819, 820, 3, 2, 2, 
	2, 820, 821, 3, 2, 2, 2, 821, 823, 7, 73, 2, 2, 822, 824, 5, 148, 75, 2, 
	823, 822, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 825, 
	826, 3, 2, 2, 2, 826, 827, 3, 2, 2, 2, 827, 828, 7, 74, 2, 2, 828, 830, 
	3, 2, 2, 2, 829, 817, 3, 2, 2, 2, 829, 819, 3, 2, 2, 2, 830, 147, 3, 2, 
	2, 2, 831, 832, 5, 150, 76, 2, 832, 833, 5, 152, 77, 2, 833, 834, 7, 77, 
	2, 2, 834, 149, 3, 2, 2, 2, 835, 839, 5, 138, 70, 2, 836, 839, 5, 80, 41, 
	2, 837, 839, 5, 82, 42, 2, 838, 835, 3, 2, 2, 2, 838, 836, 3, 2, 2, 2, 
	838, 837, 3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 840, 
	841, 3, 2, 2, 2, 841, 151, 3, 2, 2, 2, 842, 847, 5, 154, 78, 2, 843, 844, 
	7, 78, 2, 2, 844, 846, 5, 154, 78, 2, 845, 843, 3, 2, 2, 2, 846, 849, 3, 
	2, 2, 2, 847, 845, 3, 2, 2, 2, 847, 848, 3, 2, 2, 2, 848, 153, 3, 2, 2, 
	2, 849, 847, 3, 2, 2, 2, 850, 857, 5, 164, 83, 2, 851, 853, 5, 164, 83, 
	2, 852, 851, 3, 2, 2, 2, 852, 853, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 
	855, 7, 88, 2, 2, 855, 857, 5, 248, 125, 2, 856, 850, 3, 2, 2, 2, 856, 
	852, 3, 2, 2, 2, 857, 155, 3, 2, 2, 2, 858, 861, 7, 40, 2, 2, 859, 860, 
	7, 88, 2, 2, 860, 862, 5, 176, 89, 2, 861, 859, 3, 2, 2, 2, 861, 862, 3, 
	2, 2, 2, 862, 874, 3, 2, 2, 2, 863, 868, 5, 246, 124, 2, 864, 865, 7, 73, 
	2, 2, 865, 866, 5, 158, 80, 2, 866, 867, 7, 74, 2, 2, 867, 869, 3, 2, 2, 
	2, 868, 864, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 875, 3, 2, 2, 2, 870, 
	871, 7, 73, 2, 2, 871, 872, 5, 158, 80, 2, 872, 873, 7, 74, 2, 2, 873, 
	875, 3, 2, 2, 2, 874, 863, 3, 2, 2, 2, 874, 870, 3, 2, 2, 2, 875, 897, 
	3, 2, 2, 2, 876, 877, 7, 67, 2, 2, 877, 878, 7, 71, 2, 2, 878, 879, 5, 
	176, 89, 2, 879, 880, 7, 78, 2, 2, 880, 881, 5, 246, 124, 2, 881, 882, 
	7, 72, 2, 2, 882, 883, 7, 73, 2, 2, 883, 884, 5, 158, 80, 2, 884, 885, 
	7, 74, 2, 2, 885, 897, 3, 2, 2, 2, 886, 887, 7, 68, 2, 2, 887, 888, 7, 
	71, 2, 2, 888, 889, 5, 176, 89, 2, 889, 890, 7, 78, 2, 2, 890, 891, 5, 
	246, 124, 2, 891, 892, 7, 72, 2, 2, 892, 893, 7, 73, 2, 2, 893, 894, 5, 
	158, 80, 2, 894, 895, 7, 74, 2, 2, 895, 897, 3, 2, 2, 2, 896, 858, 3, 2, 
	2, 2, 896, 876, 3, 2, 2, 2, 896, 886, 3, 2, 2, 2, 897, 157, 3, 2, 2, 2, 
	898, 903, 5, 160, 81, 2, 899, 900, 7, 78, 2, 2, 900, 902, 5, 160, 81, 2, 
	901, 899, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2, 903, 
	904, 3, 2, 2, 2, 904, 907, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 906, 908, 
	7, 78, 2, 2, 907, 906, 3, 2, 2, 2, 907, 908, 3, 2, 2, 2, 908, 159, 3, 2, 
	2, 2, 909, 912, 5, 246, 124, 2, 910, 911, 7, 82, 2, 2, 911, 913, 5, 214, 
	108, 2, 912, 910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 161, 3, 2, 2, 
	2, 914, 916, 7, 99, 2, 2, 915, 917, 5, 136, 69, 2, 916, 915, 3, 2, 2, 2, 
	916, 917, 3, 2, 2, 2, 917, 924, 3, 2, 2, 2, 918, 920, 7, 99, 2, 2, 919, 
	921, 5, 136, 69, 2, 920, 919, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 922, 
	3, 2, 2, 2, 922, 924, 5, 162, 82, 2, 923, 914, 3, 2, 2, 2, 923, 918, 3, 
	2, 2, 2, 924, 163, 3, 2, 2, 2, 925, 927, 5, 162, 82, 2, 926, 925, 3, 2, 
	2, 2, 926, 927, 3, 2, 2, 2, 927, 928, 3, 2, 2, 2, 928, 929, 5, 166, 84, 
	2, 929, 165, 3, 2, 2, 2, 930, 934, 5, 246, 124, 2, 931, 933, 5, 168, 85, 
	2, 932, 931, 3, 2, 2, 2, 933, 936, 3, 2, 2, 2, 934, 932, 3, 2, 2, 2, 934, 
	935, 3, 2, 2, 2, 935, 954, 3, 2, 2, 2, 936, 934, 3, 2, 2, 2, 937, 938, 
	7, 71, 2, 2, 938, 939, 5, 164, 83, 2, 939, 943, 7, 72, 2, 2, 940, 942, 
	5, 168, 85, 2, 941, 940, 3, 2, 2, 2, 942, 945, 3, 2, 2, 2, 943, 941, 3, 
	2, 2, 2, 943, 944, 3, 2, 2, 2, 944, 954, 3, 2, 2, 2, 945, 943, 3, 2, 2, 
	2, 946, 947, 7, 71, 2, 2, 947, 949, 7, 103, 2, 2, 948, 950, 5, 246, 124, 
	2, 949, 948, 3, 2, 2, 2, 949, 950, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 
	952, 7, 72, 2, 2, 952, 954, 5, 96, 49, 2, 953, 930, 3, 2, 2, 2, 953, 937, 
	3, 2, 2, 2, 953, 946, 3, 2, 2, 2, 954, 167, 3, 2, 2, 2, 955, 957, 7, 75, 
	2, 2, 956, 958, 5, 214, 108, 2, 957, 956, 3, 2, 2, 2, 957, 958, 3, 2, 2, 
	2, 958, 959, 3, 2, 2, 2, 959, 966, 7, 76, 2, 2, 960, 962, 7, 71, 2, 2, 
	961, 963, 5, 170, 86, 2, 962, 961, 3, 2, 2, 2, 962, 963, 3, 2, 2, 2, 963, 
	964, 3, 2, 2, 2, 964, 966, 7, 72, 2, 2, 965, 955, 3, 2, 2, 2, 965, 960, 
	3, 2, 2, 2, 966, 169, 3, 2, 2, 2, 967, 970, 5, 182, 92, 2, 968, 969, 7, 
	78, 2, 2, 969, 971, 7, 117, 2, 2, 970, 968, 3, 2, 2, 2, 970, 971, 3, 2, 
	2, 2, 971, 171, 3, 2, 2, 2, 972, 977, 5, 136, 69, 2, 973, 975, 5, 164, 
	83, 2, 974, 973, 3, 2, 2, 2, 974, 975, 3, 2, 2, 2, 975, 978, 3, 2, 2, 2, 
	976, 978, 5, 178, 90, 2, 977, 974, 3, 2, 2, 2, 977, 976, 3, 2, 2, 2, 978, 
	173, 3, 2, 2, 2, 979, 995, 5, 208, 105, 2, 980, 981, 7, 73, 2, 2, 981, 
	986, 5, 174, 88, 2, 982, 983, 7, 78, 2, 2, 983, 985, 5, 174, 88, 2, 984, 
	982, 3, 2, 2, 2, 985, 988, 3, 2, 2, 2, 986, 984, 3, 2, 2, 2, 986, 987, 
	3, 2, 2, 2, 987, 990, 3, 2, 2, 2, 988, 986, 3, 2, 2, 2, 989, 991, 7, 78, 
	2, 2, 990, 989, 3, 2, 2, 2, 990, 991, 3, 2, 2, 2, 991, 992, 3, 2, 2, 2, 
	992, 993, 7, 74, 2, 2, 993, 995, 3, 2, 2, 2, 994, 979, 3, 2, 2, 2, 994, 
	980, 3, 2, 2, 2, 995, 175, 3, 2, 2, 2, 996, 997, 5, 150, 76, 2, 997, 998, 
	5, 178, 90, 2, 998, 1001, 3, 2, 2, 2, 999, 1001, 5, 78, 40, 2, 1000, 996, 
	3, 2, 2, 2, 1000, 999, 3, 2, 2, 2, 1001, 177, 3, 2, 2, 2, 1002, 1003, 5, 
	162, 82, 2, 1003, 1004, 5, 178, 90, 2, 1004, 1024, 3, 2, 2, 2, 1005, 1006, 
	7, 71, 2, 2, 1006, 1007, 5, 178, 90, 2, 1007, 1009, 7, 72, 2, 2, 1008, 
	1010, 5, 180, 91, 2, 1009, 1008, 3, 2, 2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 
	1009, 3, 2, 2, 2, 1011, 1012, 3, 2, 2, 2, 1012, 1024, 3, 2, 2, 2, 1013, 
	1015, 7, 75, 2, 2, 1014, 1016, 5, 214, 108, 2, 1015, 1014, 3, 2, 2, 2, 
	1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1019, 7, 76, 2, 2, 
	1018, 1013, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 1018, 3, 2, 2, 2, 
	1020, 1021, 3, 2, 2, 2, 1021, 1024, 3, 2, 2, 2, 1022, 1024, 3, 2, 2, 2, 
	1023, 1002, 3, 2, 2, 2, 1023, 1005, 3, 2, 2, 2, 1023, 1018, 3, 2, 2, 2, 
	1023, 1022, 3, 2, 2, 2, 1024, 179, 3, 2, 2, 2, 1025, 1027, 7, 75, 2, 2, 
	1026, 1028, 5, 214, 108, 2, 1027, 1026, 3, 2, 2, 2, 1027, 1028, 3, 2, 2, 
	2, 1028, 1029, 3, 2, 2, 2, 1029, 1036, 7, 76, 2, 2, 1030, 1032, 7, 71, 
	2, 2, 1031, 1033, 5, 182, 92, 2, 1032, 1031, 3, 2, 2, 2, 1032, 1033, 3, 
	2, 2, 2, 1033, 1034, 3, 2, 2, 2, 1034, 1036, 7, 72, 2, 2, 1035, 1025, 3, 
	2, 2, 2, 1035, 1030, 3, 2, 2, 2, 1036, 181, 3, 2, 2, 2, 1037, 1042, 5, 
	172, 87, 2, 1038, 1039, 7, 78, 2, 2, 1039, 1041, 5, 172, 87, 2, 1040, 1038, 
	3, 2, 2, 2, 1041, 1044, 3, 2, 2, 2, 1042, 1040, 3, 2, 2, 2, 1042, 1043, 
	3, 2, 2, 2, 1043, 183, 3, 2, 2, 2, 1044, 1042, 3, 2, 2, 2, 1045, 1047, 
	5, 186, 94, 2, 1046, 1045, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048, 1046, 
	3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 185, 3, 2, 2, 2, 1050, 1063, 
	5, 188, 95, 2, 1051, 1052, 5, 206, 104, 2, 1052, 1053, 7, 77, 2, 2, 1053, 
	1063, 3, 2, 2, 2, 1054, 1063, 5, 190, 96, 2, 1055, 1063, 5, 192, 97, 2, 
	1056, 1063, 5, 202, 102, 2, 1057, 1063, 5, 204, 103, 2, 1058, 1063, 5, 
	128, 65, 2, 1059, 1063, 5, 130, 66, 2, 1060, 1063, 5, 126, 64, 2, 1061, 
	1063, 7, 77, 2, 2, 1062, 1050, 3, 2, 2, 2, 1062, 1051, 3, 2, 2, 2, 1062, 
	1054, 3, 2, 2, 2, 1062, 1055, 3, 2, 2, 2, 1062, 1056, 3, 2, 2, 2, 1062, 
	1057, 3, 2, 2, 2, 1062, 1058, 3, 2, 2, 2, 1062, 1059, 3, 2, 2, 2, 1062, 
	1060, 3, 2, 2, 2, 1062, 1061, 3, 2, 2, 2, 1063, 187, 3, 2, 2, 2, 1064, 
	1065, 5, 246, 124, 2, 1065, 1066, 7, 88, 2, 2, 1066, 1067, 5, 186, 94, 
	2, 1067, 1077, 3, 2, 2, 2, 1068, 1069, 7, 32, 2, 2, 1069, 1070, 5, 214, 
	108, 2, 1070, 1071, 7, 88, 2, 2, 1071, 1072, 5, 186, 94, 2, 1072, 1077, 
	3, 2, 2, 2, 1073, 1074, 7, 36, 2, 2, 1074, 1075, 7, 88, 2, 2, 1075, 1077, 
	5, 186, 94, 2, 1076, 1064, 3, 2, 2, 2, 1076, 1068, 3, 2, 2, 2, 1076, 1073, 
	3, 2, 2, 2, 1077, 189, 3, 2, 2, 2, 1078, 1083, 7, 73, 2, 2, 1079, 1082, 
	5, 134, 68, 2, 1080, 1082, 5, 184, 93, 2, 1081, 1079, 3, 2, 2, 2, 1081, 
	1080, 3, 2, 2, 2, 1082, 1085, 3, 2, 2, 2, 1083, 1081, 3, 2, 2, 2, 1083, 
	1084, 3, 2, 2, 2, 1084, 1086, 3, 2, 2, 2, 1085, 1083, 3, 2, 2, 2, 1086, 
	1087, 7, 74, 2, 2, 1087, 191, 3, 2, 2, 2, 1088, 1089, 7, 45, 2, 2, 1089, 
	1090, 7, 71, 2, 2, 1090, 1091, 5, 206, 104, 2, 1091, 1092, 7, 72, 2, 2, 
	1092, 1095, 5, 186, 94, 2, 1093, 1094, 7, 39, 2, 2, 1094, 1096, 5, 186, 
	94, 2, 1095, 1093, 3, 2, 2, 2, 1095, 1096, 3, 2, 2, 2, 1096, 1104, 3, 2, 
	2, 2, 1097, 1098, 7, 60, 2, 2, 1098, 1099, 7, 71, 2, 2, 1099, 1100, 5, 
	206, 104, 2, 1100, 1101, 7, 72, 2, 2, 1101, 1102, 5, 186, 94, 2, 1102, 
	1104, 3, 2, 2, 2, 1103, 1088, 3, 2, 2, 2, 1103, 1097, 3, 2, 2, 2, 1104, 
	193, 3, 2, 2, 2, 1105, 1106, 7, 43, 2, 2, 1106, 1107, 7, 71, 2, 2, 1107, 
	1108, 5, 116, 59, 2, 1108, 1110, 7, 46, 2, 2, 1109, 1111, 5, 206, 104, 
	2, 1110, 1109, 3, 2, 2, 2, 1110, 1111, 3, 2, 2, 2, 1111, 1112, 3, 2, 2, 
	2, 1112, 1113, 7, 72, 2, 2, 1113, 1114, 5, 186, 94, 2, 1114, 195, 3, 2, 
	2, 2, 1115, 1116, 7, 43, 2, 2, 1116, 1121, 7, 71, 2, 2, 1117, 1118, 5, 
	136, 69, 2, 1118, 1119, 5, 142, 72, 2, 1119, 1122, 3, 2, 2, 2, 1120, 1122, 
	5, 206, 104, 2, 1121, 1117, 3, 2, 2, 2, 1121, 1120, 3, 2, 2, 2, 1121, 1122, 
	3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123, 1125, 7, 77, 2, 2, 1124, 1126, 
	5, 206, 104, 2, 1125, 1124, 3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 1127, 
	3, 2, 2, 2, 1127, 1129, 7, 77, 2, 2, 1128, 1130, 5, 206, 104, 2, 1129, 
	1128, 3, 2, 2, 2, 1129, 1130, 3, 2, 2, 2, 1130, 1131, 3, 2, 2, 2, 1131, 
	1132, 7, 72, 2, 2, 1132, 1133, 5, 186, 94, 2, 1133, 197, 3, 2, 2, 2, 1134, 
	1135, 7, 66, 2, 2, 1135, 1136, 7, 71, 2, 2, 1136, 1137, 5, 206, 104, 2, 
	1137, 1138, 7, 72, 2, 2, 1138, 1139, 5, 186, 94, 2, 1139, 199, 3, 2, 2, 
	2, 1140, 1141, 7, 37, 2, 2, 1141, 1142, 5, 186, 94, 2, 1142, 1143, 7, 66, 
	2, 2, 1143, 1144, 7, 71, 2, 2, 1144, 1145, 5, 206, 104, 2, 1145, 1146, 
	7, 72, 2, 2, 1146, 1147, 7, 77, 2, 2, 1147, 201, 3, 2, 2, 2, 1148, 1153, 
	5, 198, 100, 2, 1149, 1153, 5, 200, 101, 2, 1150, 1153, 5, 196, 99, 2, 
	1151, 1153, 5, 194, 98, 2, 1152, 1148, 3, 2, 2, 2, 1152, 1149, 3, 2, 2, 
	2, 1152, 1150, 3, 2, 2, 2, 1152, 1151, 3, 2, 2, 2, 1153, 203, 3, 2, 2, 
	2, 1154, 1155, 7, 48, 2, 2, 1155, 1156, 5, 246, 124, 2, 1156, 1157, 7, 
	77, 2, 2, 1157, 1168, 3, 2, 2, 2, 1158, 1159, 7, 35, 2, 2, 1159, 1168, 
	7, 77, 2, 2, 1160, 1161, 7, 29, 2, 2, 1161, 1168, 7, 77, 2, 2, 1162, 1164, 
	7, 54, 2, 2, 1163, 1165, 5, 206, 104, 2, 1164, 1163, 3, 2, 2, 2, 1164, 
	1165, 3, 2, 2, 2, 1165, 1166, 3, 2, 2, 2, 1166, 1168, 7, 77, 2, 2, 1167, 
	1154, 3, 2, 2, 2, 1167, 1158, 3, 2, 2, 2, 1167, 1160, 3, 2, 2, 2, 1167, 
	1162, 3, 2, 2, 2, 1168, 205, 3, 2, 2, 2, 1169, 1174, 5, 208, 105, 2, 1170, 
	1171, 7, 78, 2, 2, 1171, 1173, 5, 208, 105, 2, 1172, 1170, 3, 2, 2, 2, 
	1173, 1176, 3, 2, 2, 2, 1174, 1172, 3, 2, 2, 2, 1174, 1175, 3, 2, 2, 2, 
	1175, 207, 3, 2, 2, 2, 1176, 1174, 3, 2, 2, 2, 1177, 1183, 5, 212, 107, 
	2, 1178, 1179, 5, 238, 120, 2, 1179, 1180, 5, 210, 106, 2, 1180, 1181, 
	5, 208, 105, 2, 1181, 1183, 3, 2, 2, 2, 1182, 1177, 3, 2, 2, 2, 1182, 1178, 
	3, 2, 2, 2, 1183, 209, 3, 2, 2, 2, 1184, 1185, 9, 8, 2, 2, 1185, 211, 3, 
	2, 2, 2, 1186, 1192, 5, 216, 109, 2, 1187, 1188, 7, 87, 2, 2, 1188, 1189, 
	5, 212, 107, 2, 1189, 1190, 7, 88, 2, 2, 1190, 1191, 5, 212, 107, 2, 1191, 
	1193, 3, 2, 2, 2, 1192, 1187, 3, 2, 2, 2, 1192, 1193, 3, 2, 2, 2, 1193, 
	213, 3, 2, 2, 2, 1194, 1195, 5, 212, 107, 2, 1195, 215, 3, 2, 2, 2, 1196, 
	1201, 5, 218, 110, 2, 1197, 1198, 7, 94, 2, 2, 1198, 1200, 5, 218, 110, 
	2, 1199, 1197, 3, 2, 2, 2, 1200, 1203, 3, 2, 2, 2, 1201, 1199, 3, 2, 2, 
	2, 1201, 1202, 3, 2, 2, 2, 1202, 217, 3, 2, 2, 2, 1203, 1201, 3, 2, 2, 
	2, 1204, 1209, 5, 220, 111, 2, 1205, 1206, 7, 93, 2, 2, 1206, 1208, 5, 
	220, 111, 2, 1207, 1205, 3, 2, 2, 2, 1208, 1211, 3, 2, 2, 2, 1209, 1207, 
	3, 2, 2, 2, 1209, 1210, 3, 2, 2, 2, 1210, 219, 3, 2, 2, 2, 1211, 1209, 
	3, 2, 2, 2, 1212, 1217, 5, 222, 112, 2, 1213, 1214, 7, 102, 2, 2, 1214, 
	1216, 5, 222, 112, 2, 1215, 1213, 3, 2, 2, 2, 1216, 1219, 3, 2, 2, 2, 1217, 
	1215, 3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2, 1218, 221, 3, 2, 2, 2, 1219, 
	1217, 3, 2, 2, 2, 1220, 1225, 5, 224, 113, 2, 1221, 1222, 7, 103, 2, 2, 
	1222, 1224, 5, 224, 113, 2, 1223, 1221, 3, 2, 2, 2, 1224, 1227, 3, 2, 2, 
	2, 1225, 1223, 3, 2, 2, 2, 1225, 1226, 3, 2, 2, 2, 1226, 223, 3, 2, 2, 
	2, 1227, 1225, 3, 2, 2, 2, 1228, 1233, 5, 226, 114, 2, 1229, 1230, 7, 101, 
	2, 2, 1230, 1232, 5, 226, 114, 2, 1231, 1229, 3, 2, 2, 2, 1232, 1235, 3, 
	2, 2, 2, 1233, 1231, 3, 2, 2, 2, 1233, 1234, 3, 2, 2, 2, 1234, 225, 3, 
	2, 2, 2, 1235, 1233, 3, 2, 2, 2, 1236, 1241, 5, 228, 115, 2, 1237, 1238, 
	9, 9, 2, 2, 1238, 1240, 5, 228, 115, 2, 1239, 1237, 3, 2, 2, 2, 1240, 1243, 
	3, 2, 2, 2, 1241, 1239, 3, 2, 2, 2, 1241, 1242, 3, 2, 2, 2, 1242, 227, 
	3, 2, 2, 2, 1243, 1241, 3, 2, 2, 2, 1244, 1249, 5, 230, 116, 2, 1245, 1246, 
	9, 10, 2, 2, 1246, 1248, 5, 230, 116, 2, 1247, 1245, 3, 2, 2, 2, 1248, 
	1251, 3, 2, 2, 2, 1249, 1247, 3, 2, 2, 2, 1249, 1250, 3, 2, 2, 2, 1250, 
	229, 3, 2, 2, 2, 1251, 1249, 3, 2, 2, 2, 1252, 1257, 5, 232, 117, 2, 1253, 
	1254, 9, 11, 2, 2, 1254, 1256, 5, 232, 117, 2, 1255, 1253, 3, 2, 2, 2, 
	1256, 1259, 3, 2, 2, 2, 1257, 1255, 3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 
	1258, 231, 3, 2, 2, 2, 1259, 1257, 3, 2, 2, 2, 1260, 1265, 5, 234, 118, 
	2, 1261, 1262, 9, 12, 2, 2, 1262, 1264, 5, 234, 118, 2, 1263, 1261, 3, 
	2, 2, 2, 1264, 1267, 3, 2, 2, 2, 1265, 1263, 3, 2, 2, 2, 1265, 1266, 3, 
	2, 2, 2, 1266, 233, 3, 2, 2, 2, 1267, 1265, 3, 2, 2, 2, 1268, 1273, 5, 
	236, 119, 2, 1269, 1270, 9, 13, 2, 2, 1270, 1272, 5, 236, 119, 2, 1271, 
	1269, 3, 2, 2, 2, 1272, 1275, 3, 2, 2, 2, 1273, 1271, 3, 2, 2, 2, 1273, 
	1274, 3, 2, 2, 2, 1274, 235, 3, 2, 2, 2, 1275, 1273, 3, 2, 2, 2, 1276, 
	1277, 7, 71, 2, 2, 1277, 1278, 5, 176, 89, 2, 1278, 1279, 7, 72, 2, 2, 
	1279, 1280, 5, 236, 119, 2, 1280, 1283, 3, 2, 2, 2, 1281, 1283, 5, 238, 
	120, 2, 1282, 1276, 3, 2, 2, 2, 1282, 1281, 3, 2, 2, 2, 1283, 237, 3, 2, 
	2, 2, 1284, 1301, 5, 242, 122, 2, 1285, 1286, 7, 95, 2, 2, 1286, 1301, 
	5, 238, 120, 2, 1287, 1288, 7, 96, 2, 2, 1288, 1301, 5, 238, 120, 2, 1289, 
	1290, 5, 240, 121, 2, 1290, 1291, 5, 236, 119, 2, 1291, 1301, 3, 2, 2, 
	2, 1292, 1298, 7, 57, 2, 2, 1293, 1294, 7, 71, 2, 2, 1294, 1295, 5, 176, 
	89, 2, 1295, 1296, 7, 72, 2, 2, 1296, 1299, 3, 2, 2, 2, 1297, 1299, 5, 
	238, 120, 2, 1298, 1293, 3, 2, 2, 2, 1298, 1297, 3, 2, 2, 2, 1299, 1301, 
	3, 2, 2, 2, 1300, 1284, 3, 2, 2, 2, 1300, 1285, 3, 2, 2, 2, 1300, 1287, 
	3, 2, 2, 2, 1300, 1289, 3, 2, 2, 2, 1300, 1292, 3, 2, 2, 2, 1301, 239, 
	3, 2, 2, 2, 1302, 1303, 9, 14, 2, 2, 1303, 241, 3, 2, 2, 2, 1304, 1322, 
	5, 86, 44, 2, 1305, 1306, 7, 75, 2, 2, 1306, 1307, 5, 206, 104, 2, 1307, 
	1308, 7, 76, 2, 2, 1308, 1321, 3, 2, 2, 2, 1309, 1311, 7, 71, 2, 2, 1310, 
	1312, 5, 244, 123, 2, 1311, 1310, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 
	1313, 3, 2, 2, 2, 1313, 1321, 7, 72, 2, 2, 1314, 1315, 7, 79, 2, 2, 1315, 
	1321, 5, 246, 124, 2, 1316, 1317, 7, 80, 2, 2, 1317, 1321, 5, 246, 124, 
	2, 1318, 1321, 7, 95, 2, 2, 1319, 1321, 7, 96, 2, 2, 1320, 1305, 3, 2, 
	2, 2, 1320, 1309, 3, 2, 2, 2, 1320, 1314, 3, 2, 2, 2, 1320, 1316, 3, 2, 
	2, 2, 1320, 1318, 3, 2, 2, 2, 1320, 1319, 3, 2, 2, 2, 1321, 1324, 3, 2, 
	2, 2, 1322, 1320, 3, 2, 2, 2, 1322, 1323, 3, 2, 2, 2, 1323, 243, 3, 2, 
	2, 2, 1324, 1322, 3, 2, 2, 2, 1325, 1330, 5, 208, 105, 2, 1326, 1327, 7, 
	78, 2, 2, 1327, 1329, 5, 208, 105, 2, 1328, 1326, 3, 2, 2, 2, 1329, 1332, 
	3, 2, 2, 2, 1330, 1328, 3, 2, 2, 2, 1330, 1331, 3, 2, 2, 2, 1331, 245, 
	3, 2, 2, 2, 1332, 1330, 3, 2, 2, 2, 1333, 1334, 7, 127, 2, 2, 1334, 247, 
	3, 2, 2, 2, 1335, 1336, 9, 15, 2, 2, 1336, 249, 3, 2, 2, 2, 154, 253, 269, 
	277, 280, 283, 286, 294, 298, 301, 304, 312, 315, 318, 328, 335, 338, 341, 
	344, 361, 373, 378, 391, 410, 424, 433, 441, 451, 456, 464, 466, 475, 485, 
	487, 496, 500, 503, 511, 514, 516, 519, 525, 544, 551, 558, 564, 568, 581, 
	585, 592, 597, 618, 627, 633, 637, 644, 650, 654, 665, 670, 676, 683, 686, 
	698, 704, 706, 709, 721, 726, 728, 764, 768, 780, 787, 795, 797, 808, 814, 
	819, 825, 829, 838, 840, 847, 852, 856, 861, 868, 874, 896, 903, 907, 912, 
	916, 920, 923, 926, 934, 943, 949, 953, 957, 962, 965, 970, 974, 977, 986, 
	990, 994, 1000, 1011, 1015, 1020, 1023, 1027, 1032, 1035, 1042, 1048, 1062, 
	1076, 1081, 1083, 1095, 1103, 1110, 1121, 1125, 1129, 1152, 1164, 1167, 
	1174, 1182, 1192, 1201, 1209, 1217, 1225, 1233, 1241, 1249, 1257, 1265, 
	1273, 1282, 1298, 1300, 1311, 1320, 1322, 1330,
}
var literalNames = []string{
	"", "'@autoreleasepool'", "'@catch'", "'@class'", "'@dynamic'", "'@encode'", 
	"'@end'", "'@finally'", "'@implementation'", "'@interface'", "'@package'", 
	"'@protocol'", "'@optional'", "'@private'", "'@property'", "'@protected'", 
	"'@public'", "'@selector'", "'@synchronized'", "'@synthesize'", "'@throw'", 
	"'@try'", "'super'", "'self'", "'abstract'", "'auto'", "'boolean'", "'break'", 
	"'bycopy'", "'byref'", "'case'", "'char'", "'const'", "'continue'", "'default'", 
	"'do'", "'double'", "'else'", "'enum'", "'extern'", "'float'", "'for'", 
	"'id'", "'if'", "'in'", "'inout'", "'goto'", "'int'", "'long'", "'oneway'", 
	"'out'", "'register'", "'return'", "'short'", "'signed'", "'sizeof'", "'static'", 
	"'struct'", "'switch'", "'typedef'", "'union'", "'unsigned'", "'void'", 
	"'volatile'", "'while'", "'NS_OPTIONS'", "'NS_ENUM'", "'__weak'", "'__unsafe_unretained'", 
	"'('", "')'", "'{'", "'}'", "'['", "']'", "';'", "','", "'.'", "'->'", 
	"'@'", "'='", "'>'", "'<'", "'!'", "'~'", "'?'", "':'", "'=='", "'<='", 
	"'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'", 
	"'&'", "'|'", "'^'", "'%'", "'>>'", "'<<'", "'+='", "'-='", "'*='", "'/='", 
	"'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='", "'...'", "'assign'", 
	"'getter'", "'nonatomic'", "'setter'", "'strong'", "'retain'", "'readonly'", 
	"'readwrite'", "'weak'",
}
var symbolicNames = []string{
	"", "AUTORELEASEPOOL", "CATCH", "CLASS", "DYNAMIC", "ENCODE", "END", "FINALLY", 
	"IMPLEMENTATION", "INTERFACE", "PACKAGE", "PROTOCOL", "OPTIONAL", "PRIVATE", 
	"PROPERTY", "PROTECTED", "PUBLIC", "SELECTOR", "SYNCHRONIZED", "SYNTHESIZE", 
	"THROW", "TRY", "SUPER", "SELF", "ABSTRACT", "AUTO", "BOOLEAN", "BREAK", 
	"BYCOPY", "BYREF", "CASE", "CHAR", "CONST", "CONTINUE", "DEFAULT", "DO", 
	"DOUBLE", "ELSE", "ENUM", "EXTERN", "FLOAT", "FOR", "ID", "IF", "IN", "INOUT", 
	"GOTO", "INT", "LONG", "ONEWAY", "OUT", "REGISTER", "RETURN", "SHORT", 
	"SIGNED", "SIZEOF", "STATIC", "STRUCT", "SWITCH", "TYPEDEF", "UNION", "UNSIGNED", 
	"VOID", "VOLATILE", "WHILE", "NS_OPTIONS", "NS_ENUM", "WWEAK", "WUNSAFE_UNRETAINED", 
	"LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA", 
	"DOT", "STRUCTACCESS", "AT", "ASSIGN", "GT", "LT", "BANG", "TILDE", "QUESTION", 
	"COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", 
	"SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET", "MOD", "SHIFT_R", "SHIFT_L", 
	"ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", 
	"XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "ELIPSIS", 
	"ASSIGNPA", "GETTER", "NONATOMIC", "SETTER", "STRONG", "RETAIN", "READONLY", 
	"READWRITE", "WEAK", "IDENTIFIER", "CHARACTER_LITERAL", "STRING_LITERAL", 
	"HEX_LITERAL", "DECIMAL_LITERAL", "OCTAL_LITERAL", "FLOATING_POINT_LITERAL", 
	"IMPORT", "INCLUDE", "PRAGMA", "WS", "COMMENT", "LINE_COMMENT", "HDEFINE", 
	"HIF", "HELSE", "HUNDEF", "HIFNDEF", "HENDIF",
}

var ruleNames = []string{
	"translation_unit", "external_declaration", "preprocessor_declaration", 
	"class_interface", "category_interface", "class_implementation", "category_implementation", 
	"protocol_declaration", "protocol_declaration_list", "class_declaration_list", 
	"class_list", "protocol_reference_list", "protocol_list", "property_declaration", 
	"property_attributes_declaration", "property_attributes_list", "property_attribute", 
	"class_name", "superclass_name", "category_name", "protocol_name", "instance_variables", 
	"visibility_specification", "interface_declaration_list", "class_method_declaration", 
	"instance_method_declaration", "method_declaration", "implementation_definition_list", 
	"class_method_definition", "instance_method_definition", "method_definition", 
	"method_selector", "keyword_declarator", "selector", "method_type", "property_implementation", 
	"property_synthesize_list", "property_synthesize_item", "block_type", "type_specifier", 
	"type_qualifier", "protocol_qualifier", "primary_expression", "dictionary_pair", 
	"dictionary_expression", "array_expression", "box_expression", "block_parameters", 
	"block_expression", "message_expression", "receiver", "message_selector", 
	"keyword_argument", "selector_expression", "selector_name", "protocol_expression", 
	"encode_expression", "type_variable_declarator", "try_statement", "catch_statement", 
	"finally_statement", "throw_statement", "try_block", "synchronized_statement", 
	"autorelease_statement", "function_definition", "declaration", "declaration_specifiers", 
	"arc_behaviour_specifier", "storage_class_specifier", "init_declarator_list", 
	"init_declarator", "struct_or_union_specifier", "struct_declaration", "specifier_qualifier_list", 
	"struct_declarator_list", "struct_declarator", "enum_specifier", "enumerator_list", 
	"enumerator", "pointer", "declarator", "direct_declarator", "declarator_suffix", 
	"parameter_list", "parameter_declaration", "initializer", "type_name", 
	"abstract_declarator", "abstract_declarator_suffix", "parameter_declaration_list", 
	"statement_list", "statement", "labeled_statement", "compound_statement", 
	"selection_statement", "for_in_statement", "for_statement", "while_statement", 
	"do_statement", "iteration_statement", "jump_statement", "expression", 
	"assignment_expression", "assignment_operator", "conditional_expression", 
	"constant_expression", "logical_or_expression", "logical_and_expression", 
	"inclusive_or_expression", "exclusive_or_expression", "and_expression", 
	"equality_expression", "relational_expression", "shift_expression", "additive_expression", 
	"multiplicative_expression", "cast_expression", "unary_expression", "unary_operator", 
	"postfix_expression", "argument_expression_list", "identifier", "constant",
}
type ObjCParser struct {
	*antlr.BaseParser
}

// NewObjCParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ObjCParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewObjCParser(input antlr.TokenStream) *ObjCParser {
	this := new(ObjCParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ObjC.g4"

	return this
}


// ObjCParser tokens.
const (
	ObjCParserEOF = antlr.TokenEOF
	ObjCParserAUTORELEASEPOOL = 1
	ObjCParserCATCH = 2
	ObjCParserCLASS = 3
	ObjCParserDYNAMIC = 4
	ObjCParserENCODE = 5
	ObjCParserEND = 6
	ObjCParserFINALLY = 7
	ObjCParserIMPLEMENTATION = 8
	ObjCParserINTERFACE = 9
	ObjCParserPACKAGE = 10
	ObjCParserPROTOCOL = 11
	ObjCParserOPTIONAL = 12
	ObjCParserPRIVATE = 13
	ObjCParserPROPERTY = 14
	ObjCParserPROTECTED = 15
	ObjCParserPUBLIC = 16
	ObjCParserSELECTOR = 17
	ObjCParserSYNCHRONIZED = 18
	ObjCParserSYNTHESIZE = 19
	ObjCParserTHROW = 20
	ObjCParserTRY = 21
	ObjCParserSUPER = 22
	ObjCParserSELF = 23
	ObjCParserABSTRACT = 24
	ObjCParserAUTO = 25
	ObjCParserBOOLEAN = 26
	ObjCParserBREAK = 27
	ObjCParserBYCOPY = 28
	ObjCParserBYREF = 29
	ObjCParserCASE = 30
	ObjCParserCHAR = 31
	ObjCParserCONST = 32
	ObjCParserCONTINUE = 33
	ObjCParserDEFAULT = 34
	ObjCParserDO = 35
	ObjCParserDOUBLE = 36
	ObjCParserELSE = 37
	ObjCParserENUM = 38
	ObjCParserEXTERN = 39
	ObjCParserFLOAT = 40
	ObjCParserFOR = 41
	ObjCParserID = 42
	ObjCParserIF = 43
	ObjCParserIN = 44
	ObjCParserINOUT = 45
	ObjCParserGOTO = 46
	ObjCParserINT = 47
	ObjCParserLONG = 48
	ObjCParserONEWAY = 49
	ObjCParserOUT = 50
	ObjCParserREGISTER = 51
	ObjCParserRETURN = 52
	ObjCParserSHORT = 53
	ObjCParserSIGNED = 54
	ObjCParserSIZEOF = 55
	ObjCParserSTATIC = 56
	ObjCParserSTRUCT = 57
	ObjCParserSWITCH = 58
	ObjCParserTYPEDEF = 59
	ObjCParserUNION = 60
	ObjCParserUNSIGNED = 61
	ObjCParserVOID = 62
	ObjCParserVOLATILE = 63
	ObjCParserWHILE = 64
	ObjCParserNS_OPTIONS = 65
	ObjCParserNS_ENUM = 66
	ObjCParserWWEAK = 67
	ObjCParserWUNSAFE_UNRETAINED = 68
	ObjCParserLPAREN = 69
	ObjCParserRPAREN = 70
	ObjCParserLBRACE = 71
	ObjCParserRBRACE = 72
	ObjCParserLBRACK = 73
	ObjCParserRBRACK = 74
	ObjCParserSEMI = 75
	ObjCParserCOMMA = 76
	ObjCParserDOT = 77
	ObjCParserSTRUCTACCESS = 78
	ObjCParserAT = 79
	ObjCParserASSIGN = 80
	ObjCParserGT = 81
	ObjCParserLT = 82
	ObjCParserBANG = 83
	ObjCParserTILDE = 84
	ObjCParserQUESTION = 85
	ObjCParserCOLON = 86
	ObjCParserEQUAL = 87
	ObjCParserLE = 88
	ObjCParserGE = 89
	ObjCParserNOTEQUAL = 90
	ObjCParserAND = 91
	ObjCParserOR = 92
	ObjCParserINC = 93
	ObjCParserDEC = 94
	ObjCParserADD = 95
	ObjCParserSUB = 96
	ObjCParserMUL = 97
	ObjCParserDIV = 98
	ObjCParserBITAND = 99
	ObjCParserBITOR = 100
	ObjCParserCARET = 101
	ObjCParserMOD = 102
	ObjCParserSHIFT_R = 103
	ObjCParserSHIFT_L = 104
	ObjCParserADD_ASSIGN = 105
	ObjCParserSUB_ASSIGN = 106
	ObjCParserMUL_ASSIGN = 107
	ObjCParserDIV_ASSIGN = 108
	ObjCParserAND_ASSIGN = 109
	ObjCParserOR_ASSIGN = 110
	ObjCParserXOR_ASSIGN = 111
	ObjCParserMOD_ASSIGN = 112
	ObjCParserLSHIFT_ASSIGN = 113
	ObjCParserRSHIFT_ASSIGN = 114
	ObjCParserELIPSIS = 115
	ObjCParserASSIGNPA = 116
	ObjCParserGETTER = 117
	ObjCParserNONATOMIC = 118
	ObjCParserSETTER = 119
	ObjCParserSTRONG = 120
	ObjCParserRETAIN = 121
	ObjCParserREADONLY = 122
	ObjCParserREADWRITE = 123
	ObjCParserWEAK = 124
	ObjCParserIDENTIFIER = 125
	ObjCParserCHARACTER_LITERAL = 126
	ObjCParserSTRING_LITERAL = 127
	ObjCParserHEX_LITERAL = 128
	ObjCParserDECIMAL_LITERAL = 129
	ObjCParserOCTAL_LITERAL = 130
	ObjCParserFLOATING_POINT_LITERAL = 131
	ObjCParserIMPORT = 132
	ObjCParserINCLUDE = 133
	ObjCParserPRAGMA = 134
	ObjCParserWS = 135
	ObjCParserCOMMENT = 136
	ObjCParserLINE_COMMENT = 137
	ObjCParserHDEFINE = 138
	ObjCParserHIF = 139
	ObjCParserHELSE = 140
	ObjCParserHUNDEF = 141
	ObjCParserHIFNDEF = 142
	ObjCParserHENDIF = 143
)

// ObjCParser rules.
const (
	ObjCParserRULE_translation_unit = 0
	ObjCParserRULE_external_declaration = 1
	ObjCParserRULE_preprocessor_declaration = 2
	ObjCParserRULE_class_interface = 3
	ObjCParserRULE_category_interface = 4
	ObjCParserRULE_class_implementation = 5
	ObjCParserRULE_category_implementation = 6
	ObjCParserRULE_protocol_declaration = 7
	ObjCParserRULE_protocol_declaration_list = 8
	ObjCParserRULE_class_declaration_list = 9
	ObjCParserRULE_class_list = 10
	ObjCParserRULE_protocol_reference_list = 11
	ObjCParserRULE_protocol_list = 12
	ObjCParserRULE_property_declaration = 13
	ObjCParserRULE_property_attributes_declaration = 14
	ObjCParserRULE_property_attributes_list = 15
	ObjCParserRULE_property_attribute = 16
	ObjCParserRULE_class_name = 17
	ObjCParserRULE_superclass_name = 18
	ObjCParserRULE_category_name = 19
	ObjCParserRULE_protocol_name = 20
	ObjCParserRULE_instance_variables = 21
	ObjCParserRULE_visibility_specification = 22
	ObjCParserRULE_interface_declaration_list = 23
	ObjCParserRULE_class_method_declaration = 24
	ObjCParserRULE_instance_method_declaration = 25
	ObjCParserRULE_method_declaration = 26
	ObjCParserRULE_implementation_definition_list = 27
	ObjCParserRULE_class_method_definition = 28
	ObjCParserRULE_instance_method_definition = 29
	ObjCParserRULE_method_definition = 30
	ObjCParserRULE_method_selector = 31
	ObjCParserRULE_keyword_declarator = 32
	ObjCParserRULE_selector = 33
	ObjCParserRULE_method_type = 34
	ObjCParserRULE_property_implementation = 35
	ObjCParserRULE_property_synthesize_list = 36
	ObjCParserRULE_property_synthesize_item = 37
	ObjCParserRULE_block_type = 38
	ObjCParserRULE_type_specifier = 39
	ObjCParserRULE_type_qualifier = 40
	ObjCParserRULE_protocol_qualifier = 41
	ObjCParserRULE_primary_expression = 42
	ObjCParserRULE_dictionary_pair = 43
	ObjCParserRULE_dictionary_expression = 44
	ObjCParserRULE_array_expression = 45
	ObjCParserRULE_box_expression = 46
	ObjCParserRULE_block_parameters = 47
	ObjCParserRULE_block_expression = 48
	ObjCParserRULE_message_expression = 49
	ObjCParserRULE_receiver = 50
	ObjCParserRULE_message_selector = 51
	ObjCParserRULE_keyword_argument = 52
	ObjCParserRULE_selector_expression = 53
	ObjCParserRULE_selector_name = 54
	ObjCParserRULE_protocol_expression = 55
	ObjCParserRULE_encode_expression = 56
	ObjCParserRULE_type_variable_declarator = 57
	ObjCParserRULE_try_statement = 58
	ObjCParserRULE_catch_statement = 59
	ObjCParserRULE_finally_statement = 60
	ObjCParserRULE_throw_statement = 61
	ObjCParserRULE_try_block = 62
	ObjCParserRULE_synchronized_statement = 63
	ObjCParserRULE_autorelease_statement = 64
	ObjCParserRULE_function_definition = 65
	ObjCParserRULE_declaration = 66
	ObjCParserRULE_declaration_specifiers = 67
	ObjCParserRULE_arc_behaviour_specifier = 68
	ObjCParserRULE_storage_class_specifier = 69
	ObjCParserRULE_init_declarator_list = 70
	ObjCParserRULE_init_declarator = 71
	ObjCParserRULE_struct_or_union_specifier = 72
	ObjCParserRULE_struct_declaration = 73
	ObjCParserRULE_specifier_qualifier_list = 74
	ObjCParserRULE_struct_declarator_list = 75
	ObjCParserRULE_struct_declarator = 76
	ObjCParserRULE_enum_specifier = 77
	ObjCParserRULE_enumerator_list = 78
	ObjCParserRULE_enumerator = 79
	ObjCParserRULE_pointer = 80
	ObjCParserRULE_declarator = 81
	ObjCParserRULE_direct_declarator = 82
	ObjCParserRULE_declarator_suffix = 83
	ObjCParserRULE_parameter_list = 84
	ObjCParserRULE_parameter_declaration = 85
	ObjCParserRULE_initializer = 86
	ObjCParserRULE_type_name = 87
	ObjCParserRULE_abstract_declarator = 88
	ObjCParserRULE_abstract_declarator_suffix = 89
	ObjCParserRULE_parameter_declaration_list = 90
	ObjCParserRULE_statement_list = 91
	ObjCParserRULE_statement = 92
	ObjCParserRULE_labeled_statement = 93
	ObjCParserRULE_compound_statement = 94
	ObjCParserRULE_selection_statement = 95
	ObjCParserRULE_for_in_statement = 96
	ObjCParserRULE_for_statement = 97
	ObjCParserRULE_while_statement = 98
	ObjCParserRULE_do_statement = 99
	ObjCParserRULE_iteration_statement = 100
	ObjCParserRULE_jump_statement = 101
	ObjCParserRULE_expression = 102
	ObjCParserRULE_assignment_expression = 103
	ObjCParserRULE_assignment_operator = 104
	ObjCParserRULE_conditional_expression = 105
	ObjCParserRULE_constant_expression = 106
	ObjCParserRULE_logical_or_expression = 107
	ObjCParserRULE_logical_and_expression = 108
	ObjCParserRULE_inclusive_or_expression = 109
	ObjCParserRULE_exclusive_or_expression = 110
	ObjCParserRULE_and_expression = 111
	ObjCParserRULE_equality_expression = 112
	ObjCParserRULE_relational_expression = 113
	ObjCParserRULE_shift_expression = 114
	ObjCParserRULE_additive_expression = 115
	ObjCParserRULE_multiplicative_expression = 116
	ObjCParserRULE_cast_expression = 117
	ObjCParserRULE_unary_expression = 118
	ObjCParserRULE_unary_operator = 119
	ObjCParserRULE_postfix_expression = 120
	ObjCParserRULE_argument_expression_list = 121
	ObjCParserRULE_identifier = 122
	ObjCParserRULE_constant = 123
)

// ITranslation_unitContext is an interface to support dynamic dispatch.
type ITranslation_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslation_unitContext differentiates from other interfaces.
	IsTranslation_unitContext()
}

type Translation_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslation_unitContext() *Translation_unitContext {
	var p = new(Translation_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_translation_unit
	return p
}

func (*Translation_unitContext) IsTranslation_unitContext() {}

func NewTranslation_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Translation_unitContext {
	var p = new(Translation_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_translation_unit

	return p
}

func (s *Translation_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Translation_unitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ObjCParserEOF, 0)
}

func (s *Translation_unitContext) AllExternal_declaration() []IExternal_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExternal_declarationContext)(nil)).Elem())
	var tst = make([]IExternal_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExternal_declarationContext)
		}
	}

	return tst
}

func (s *Translation_unitContext) External_declaration(i int) IExternal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternal_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExternal_declarationContext)
}

func (s *Translation_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Translation_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Translation_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterTranslation_unit(s)
	}
}

func (s *Translation_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitTranslation_unit(s)
	}
}




func (p *ObjCParser) Translation_unit() (localctx ITranslation_unitContext) {
	localctx = NewTranslation_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ObjCParserRULE_translation_unit)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 3)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 3))) & ((1 << (ObjCParserCLASS - 3)) | (1 << (ObjCParserIMPLEMENTATION - 3)) | (1 << (ObjCParserINTERFACE - 3)) | (1 << (ObjCParserPROTOCOL - 3)) | (1 << (ObjCParserAUTO - 3)) | (1 << (ObjCParserBYCOPY - 3)) | (1 << (ObjCParserBYREF - 3)) | (1 << (ObjCParserCHAR - 3)) | (1 << (ObjCParserCONST - 3)))) != 0) || ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (ObjCParserDOUBLE - 36)) | (1 << (ObjCParserENUM - 36)) | (1 << (ObjCParserEXTERN - 36)) | (1 << (ObjCParserFLOAT - 36)) | (1 << (ObjCParserID - 36)) | (1 << (ObjCParserIN - 36)) | (1 << (ObjCParserINOUT - 36)) | (1 << (ObjCParserINT - 36)) | (1 << (ObjCParserLONG - 36)) | (1 << (ObjCParserONEWAY - 36)) | (1 << (ObjCParserOUT - 36)) | (1 << (ObjCParserREGISTER - 36)) | (1 << (ObjCParserSHORT - 36)) | (1 << (ObjCParserSIGNED - 36)) | (1 << (ObjCParserSTATIC - 36)) | (1 << (ObjCParserSTRUCT - 36)) | (1 << (ObjCParserTYPEDEF - 36)) | (1 << (ObjCParserUNION - 36)) | (1 << (ObjCParserUNSIGNED - 36)) | (1 << (ObjCParserVOID - 36)) | (1 << (ObjCParserVOLATILE - 36)) | (1 << (ObjCParserNS_OPTIONS - 36)) | (1 << (ObjCParserNS_ENUM - 36)) | (1 << (ObjCParserWWEAK - 36)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (ObjCParserWUNSAFE_UNRETAINED - 68)) | (1 << (ObjCParserLPAREN - 68)) | (1 << (ObjCParserMUL - 68)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserIMPORT - 125)) | (1 << (ObjCParserINCLUDE - 125)) | (1 << (ObjCParserCOMMENT - 125)) | (1 << (ObjCParserLINE_COMMENT - 125)))) != 0) {
		{
			p.SetState(248)
			p.External_declaration()
		}


		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(253)
		p.Match(ObjCParserEOF)
	}



	return localctx
}


// IExternal_declarationContext is an interface to support dynamic dispatch.
type IExternal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternal_declarationContext differentiates from other interfaces.
	IsExternal_declarationContext()
}

type External_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_declarationContext() *External_declarationContext {
	var p = new(External_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_external_declaration
	return p
}

func (*External_declarationContext) IsExternal_declarationContext() {}

func NewExternal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_declarationContext {
	var p = new(External_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_external_declaration

	return p
}

func (s *External_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *External_declarationContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMENT, 0)
}

func (s *External_declarationContext) LINE_COMMENT() antlr.TerminalNode {
	return s.GetToken(ObjCParserLINE_COMMENT, 0)
}

func (s *External_declarationContext) Preprocessor_declaration() IPreprocessor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreprocessor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreprocessor_declarationContext)
}

func (s *External_declarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *External_declarationContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *External_declarationContext) Class_interface() IClass_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_interfaceContext)
}

func (s *External_declarationContext) Class_implementation() IClass_implementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_implementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_implementationContext)
}

func (s *External_declarationContext) Category_interface() ICategory_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_interfaceContext)
}

func (s *External_declarationContext) Category_implementation() ICategory_implementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_implementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_implementationContext)
}

func (s *External_declarationContext) Protocol_declaration() IProtocol_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_declarationContext)
}

func (s *External_declarationContext) Protocol_declaration_list() IProtocol_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_declaration_listContext)
}

func (s *External_declarationContext) Class_declaration_list() IClass_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_declaration_listContext)
}

func (s *External_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *External_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterExternal_declaration(s)
	}
}

func (s *External_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitExternal_declaration(s)
	}
}




func (p *ObjCParser) External_declaration() (localctx IExternal_declarationContext) {
	localctx = NewExternal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ObjCParserRULE_external_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(255)
			p.Match(ObjCParserCOMMENT)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(256)
			p.Match(ObjCParserLINE_COMMENT)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(257)
			p.Preprocessor_declaration()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(258)
			p.Function_definition()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(259)
			p.Declaration()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(260)
			p.Class_interface()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(261)
			p.Class_implementation()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(262)
			p.Category_interface()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(263)
			p.Category_implementation()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(264)
			p.Protocol_declaration()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(265)
			p.Protocol_declaration_list()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(266)
			p.Class_declaration_list()
		}

	}


	return localctx
}


// IPreprocessor_declarationContext is an interface to support dynamic dispatch.
type IPreprocessor_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreprocessor_declarationContext differentiates from other interfaces.
	IsPreprocessor_declarationContext()
}

type Preprocessor_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreprocessor_declarationContext() *Preprocessor_declarationContext {
	var p = new(Preprocessor_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_preprocessor_declaration
	return p
}

func (*Preprocessor_declarationContext) IsPreprocessor_declarationContext() {}

func NewPreprocessor_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preprocessor_declarationContext {
	var p = new(Preprocessor_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_preprocessor_declaration

	return p
}

func (s *Preprocessor_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Preprocessor_declarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ObjCParserIMPORT, 0)
}

func (s *Preprocessor_declarationContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(ObjCParserINCLUDE, 0)
}

func (s *Preprocessor_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preprocessor_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Preprocessor_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterPreprocessor_declaration(s)
	}
}

func (s *Preprocessor_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitPreprocessor_declaration(s)
	}
}




func (p *ObjCParser) Preprocessor_declaration() (localctx IPreprocessor_declarationContext) {
	localctx = NewPreprocessor_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ObjCParserRULE_preprocessor_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjCParserIMPORT || _la == ObjCParserINCLUDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IClass_interfaceContext is an interface to support dynamic dispatch.
type IClass_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_interfaceContext differentiates from other interfaces.
	IsClass_interfaceContext()
}

type Class_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_interfaceContext() *Class_interfaceContext {
	var p = new(Class_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_interface
	return p
}

func (*Class_interfaceContext) IsClass_interfaceContext() {}

func NewClass_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_interfaceContext {
	var p = new(Class_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_interface

	return p
}

func (s *Class_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_interfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserINTERFACE, 0)
}

func (s *Class_interfaceContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_interfaceContext) END() antlr.TerminalNode {
	return s.GetToken(ObjCParserEND, 0)
}

func (s *Class_interfaceContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Class_interfaceContext) Superclass_name() ISuperclass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclass_nameContext)
}

func (s *Class_interfaceContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Class_interfaceContext) Instance_variables() IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Class_interfaceContext) Interface_declaration_list() IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Class_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_interface(s)
	}
}

func (s *Class_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_interface(s)
	}
}




func (p *ObjCParser) Class_interface() (localctx IClass_interfaceContext) {
	localctx = NewClass_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ObjCParserRULE_class_interface)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Match(ObjCParserINTERFACE)
	}
	{
		p.SetState(272)
		p.Class_name()
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOLON {
		{
			p.SetState(273)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(274)
			p.Superclass_name()
		}

	}
	p.SetState(278)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLT {
		{
			p.SetState(277)
			p.Protocol_reference_list()
		}

	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLBRACE {
		{
			p.SetState(280)
			p.Instance_variables()
		}

	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 14)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 14))) & ((1 << (ObjCParserPROPERTY - 14)) | (1 << (ObjCParserAUTO - 14)) | (1 << (ObjCParserBYCOPY - 14)) | (1 << (ObjCParserBYREF - 14)) | (1 << (ObjCParserCHAR - 14)) | (1 << (ObjCParserCONST - 14)) | (1 << (ObjCParserDOUBLE - 14)) | (1 << (ObjCParserENUM - 14)) | (1 << (ObjCParserEXTERN - 14)) | (1 << (ObjCParserFLOAT - 14)) | (1 << (ObjCParserID - 14)) | (1 << (ObjCParserIN - 14)) | (1 << (ObjCParserINOUT - 14)))) != 0) || ((((_la - 47)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 47))) & ((1 << (ObjCParserINT - 47)) | (1 << (ObjCParserLONG - 47)) | (1 << (ObjCParserONEWAY - 47)) | (1 << (ObjCParserOUT - 47)) | (1 << (ObjCParserREGISTER - 47)) | (1 << (ObjCParserSHORT - 47)) | (1 << (ObjCParserSIGNED - 47)) | (1 << (ObjCParserSTATIC - 47)) | (1 << (ObjCParserSTRUCT - 47)) | (1 << (ObjCParserTYPEDEF - 47)) | (1 << (ObjCParserUNION - 47)) | (1 << (ObjCParserUNSIGNED - 47)) | (1 << (ObjCParserVOID - 47)) | (1 << (ObjCParserVOLATILE - 47)) | (1 << (ObjCParserNS_OPTIONS - 47)) | (1 << (ObjCParserNS_ENUM - 47)) | (1 << (ObjCParserWWEAK - 47)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 47)))) != 0) || ((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (ObjCParserADD - 95)) | (1 << (ObjCParserSUB - 95)) | (1 << (ObjCParserIDENTIFIER - 95)))) != 0) {
		{
			p.SetState(283)
			p.Interface_declaration_list()
		}

	}
	{
		p.SetState(286)
		p.Match(ObjCParserEND)
	}



	return localctx
}


// ICategory_interfaceContext is an interface to support dynamic dispatch.
type ICategory_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_interfaceContext differentiates from other interfaces.
	IsCategory_interfaceContext()
}

type Category_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_interfaceContext() *Category_interfaceContext {
	var p = new(Category_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_category_interface
	return p
}

func (*Category_interfaceContext) IsCategory_interfaceContext() {}

func NewCategory_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_interfaceContext {
	var p = new(Category_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_category_interface

	return p
}

func (s *Category_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_interfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserINTERFACE, 0)
}

func (s *Category_interfaceContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Category_interfaceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Category_interfaceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Category_interfaceContext) END() antlr.TerminalNode {
	return s.GetToken(ObjCParserEND, 0)
}

func (s *Category_interfaceContext) Category_name() ICategory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_nameContext)
}

func (s *Category_interfaceContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Category_interfaceContext) Instance_variables() IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Category_interfaceContext) Interface_declaration_list() IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Category_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCategory_interface(s)
	}
}

func (s *Category_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCategory_interface(s)
	}
}




func (p *ObjCParser) Category_interface() (localctx ICategory_interfaceContext) {
	localctx = NewCategory_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ObjCParserRULE_category_interface)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.Match(ObjCParserINTERFACE)
	}
	{
		p.SetState(289)
		p.Class_name()
	}
	{
		p.SetState(290)
		p.Match(ObjCParserLPAREN)
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserIDENTIFIER {
		{
			p.SetState(291)
			p.Category_name()
		}

	}
	{
		p.SetState(294)
		p.Match(ObjCParserRPAREN)
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLT {
		{
			p.SetState(295)
			p.Protocol_reference_list()
		}

	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLBRACE {
		{
			p.SetState(298)
			p.Instance_variables()
		}

	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 14)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 14))) & ((1 << (ObjCParserPROPERTY - 14)) | (1 << (ObjCParserAUTO - 14)) | (1 << (ObjCParserBYCOPY - 14)) | (1 << (ObjCParserBYREF - 14)) | (1 << (ObjCParserCHAR - 14)) | (1 << (ObjCParserCONST - 14)) | (1 << (ObjCParserDOUBLE - 14)) | (1 << (ObjCParserENUM - 14)) | (1 << (ObjCParserEXTERN - 14)) | (1 << (ObjCParserFLOAT - 14)) | (1 << (ObjCParserID - 14)) | (1 << (ObjCParserIN - 14)) | (1 << (ObjCParserINOUT - 14)))) != 0) || ((((_la - 47)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 47))) & ((1 << (ObjCParserINT - 47)) | (1 << (ObjCParserLONG - 47)) | (1 << (ObjCParserONEWAY - 47)) | (1 << (ObjCParserOUT - 47)) | (1 << (ObjCParserREGISTER - 47)) | (1 << (ObjCParserSHORT - 47)) | (1 << (ObjCParserSIGNED - 47)) | (1 << (ObjCParserSTATIC - 47)) | (1 << (ObjCParserSTRUCT - 47)) | (1 << (ObjCParserTYPEDEF - 47)) | (1 << (ObjCParserUNION - 47)) | (1 << (ObjCParserUNSIGNED - 47)) | (1 << (ObjCParserVOID - 47)) | (1 << (ObjCParserVOLATILE - 47)) | (1 << (ObjCParserNS_OPTIONS - 47)) | (1 << (ObjCParserNS_ENUM - 47)) | (1 << (ObjCParserWWEAK - 47)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 47)))) != 0) || ((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (ObjCParserADD - 95)) | (1 << (ObjCParserSUB - 95)) | (1 << (ObjCParserIDENTIFIER - 95)))) != 0) {
		{
			p.SetState(301)
			p.Interface_declaration_list()
		}

	}
	{
		p.SetState(304)
		p.Match(ObjCParserEND)
	}



	return localctx
}


// IClass_implementationContext is an interface to support dynamic dispatch.
type IClass_implementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_implementationContext differentiates from other interfaces.
	IsClass_implementationContext()
}

type Class_implementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_implementationContext() *Class_implementationContext {
	var p = new(Class_implementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_implementation
	return p
}

func (*Class_implementationContext) IsClass_implementationContext() {}

func NewClass_implementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_implementationContext {
	var p = new(Class_implementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_implementation

	return p
}

func (s *Class_implementationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_implementationContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(ObjCParserIMPLEMENTATION, 0)
}

func (s *Class_implementationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjCParserEND, 0)
}

func (s *Class_implementationContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_implementationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Class_implementationContext) Superclass_name() ISuperclass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclass_nameContext)
}

func (s *Class_implementationContext) Instance_variables() IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Class_implementationContext) Implementation_definition_list() IImplementation_definition_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_definition_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_definition_listContext)
}

func (s *Class_implementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_implementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_implementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_implementation(s)
	}
}

func (s *Class_implementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_implementation(s)
	}
}




func (p *ObjCParser) Class_implementation() (localctx IClass_implementationContext) {
	localctx = NewClass_implementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ObjCParserRULE_class_implementation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		p.Match(ObjCParserIMPLEMENTATION)
	}

	{
		p.SetState(307)
		p.Class_name()
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOLON {
		{
			p.SetState(308)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(309)
			p.Superclass_name()
		}

	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLBRACE {
		{
			p.SetState(312)
			p.Instance_variables()
		}

	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserDYNAMIC) | (1 << ObjCParserSYNTHESIZE) | (1 << ObjCParserAUTO) | (1 << ObjCParserBYCOPY) | (1 << ObjCParserBYREF) | (1 << ObjCParserCHAR))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjCParserCONST - 32)) | (1 << (ObjCParserDOUBLE - 32)) | (1 << (ObjCParserENUM - 32)) | (1 << (ObjCParserEXTERN - 32)) | (1 << (ObjCParserFLOAT - 32)) | (1 << (ObjCParserID - 32)) | (1 << (ObjCParserIN - 32)) | (1 << (ObjCParserINOUT - 32)) | (1 << (ObjCParserINT - 32)) | (1 << (ObjCParserLONG - 32)) | (1 << (ObjCParserONEWAY - 32)) | (1 << (ObjCParserOUT - 32)) | (1 << (ObjCParserREGISTER - 32)) | (1 << (ObjCParserSHORT - 32)) | (1 << (ObjCParserSIGNED - 32)) | (1 << (ObjCParserSTATIC - 32)) | (1 << (ObjCParserSTRUCT - 32)) | (1 << (ObjCParserTYPEDEF - 32)) | (1 << (ObjCParserUNION - 32)) | (1 << (ObjCParserUNSIGNED - 32)) | (1 << (ObjCParserVOID - 32)) | (1 << (ObjCParserVOLATILE - 32)))) != 0) || ((((_la - 65)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 65))) & ((1 << (ObjCParserNS_OPTIONS - 65)) | (1 << (ObjCParserNS_ENUM - 65)) | (1 << (ObjCParserWWEAK - 65)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParserLPAREN - 65)) | (1 << (ObjCParserADD - 65)) | (1 << (ObjCParserSUB - 65)))) != 0) || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(315)
			p.Implementation_definition_list()
		}

	}

	{
		p.SetState(318)
		p.Match(ObjCParserEND)
	}



	return localctx
}


// ICategory_implementationContext is an interface to support dynamic dispatch.
type ICategory_implementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_implementationContext differentiates from other interfaces.
	IsCategory_implementationContext()
}

type Category_implementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_implementationContext() *Category_implementationContext {
	var p = new(Category_implementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_category_implementation
	return p
}

func (*Category_implementationContext) IsCategory_implementationContext() {}

func NewCategory_implementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_implementationContext {
	var p = new(Category_implementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_category_implementation

	return p
}

func (s *Category_implementationContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_implementationContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(ObjCParserIMPLEMENTATION, 0)
}

func (s *Category_implementationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjCParserEND, 0)
}

func (s *Category_implementationContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Category_implementationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Category_implementationContext) Category_name() ICategory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_nameContext)
}

func (s *Category_implementationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Category_implementationContext) Implementation_definition_list() IImplementation_definition_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_definition_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_definition_listContext)
}

func (s *Category_implementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_implementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_implementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCategory_implementation(s)
	}
}

func (s *Category_implementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCategory_implementation(s)
	}
}




func (p *ObjCParser) Category_implementation() (localctx ICategory_implementationContext) {
	localctx = NewCategory_implementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ObjCParserRULE_category_implementation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Match(ObjCParserIMPLEMENTATION)
	}

	{
		p.SetState(321)
		p.Class_name()
	}
	{
		p.SetState(322)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(323)
		p.Category_name()
	}
	{
		p.SetState(324)
		p.Match(ObjCParserRPAREN)
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserDYNAMIC) | (1 << ObjCParserSYNTHESIZE) | (1 << ObjCParserAUTO) | (1 << ObjCParserBYCOPY) | (1 << ObjCParserBYREF) | (1 << ObjCParserCHAR))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjCParserCONST - 32)) | (1 << (ObjCParserDOUBLE - 32)) | (1 << (ObjCParserENUM - 32)) | (1 << (ObjCParserEXTERN - 32)) | (1 << (ObjCParserFLOAT - 32)) | (1 << (ObjCParserID - 32)) | (1 << (ObjCParserIN - 32)) | (1 << (ObjCParserINOUT - 32)) | (1 << (ObjCParserINT - 32)) | (1 << (ObjCParserLONG - 32)) | (1 << (ObjCParserONEWAY - 32)) | (1 << (ObjCParserOUT - 32)) | (1 << (ObjCParserREGISTER - 32)) | (1 << (ObjCParserSHORT - 32)) | (1 << (ObjCParserSIGNED - 32)) | (1 << (ObjCParserSTATIC - 32)) | (1 << (ObjCParserSTRUCT - 32)) | (1 << (ObjCParserTYPEDEF - 32)) | (1 << (ObjCParserUNION - 32)) | (1 << (ObjCParserUNSIGNED - 32)) | (1 << (ObjCParserVOID - 32)) | (1 << (ObjCParserVOLATILE - 32)))) != 0) || ((((_la - 65)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 65))) & ((1 << (ObjCParserNS_OPTIONS - 65)) | (1 << (ObjCParserNS_ENUM - 65)) | (1 << (ObjCParserWWEAK - 65)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParserLPAREN - 65)) | (1 << (ObjCParserADD - 65)) | (1 << (ObjCParserSUB - 65)))) != 0) || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(325)
			p.Implementation_definition_list()
		}

	}

	{
		p.SetState(328)
		p.Match(ObjCParserEND)
	}



	return localctx
}


// IProtocol_declarationContext is an interface to support dynamic dispatch.
type IProtocol_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_declarationContext differentiates from other interfaces.
	IsProtocol_declarationContext()
}

type Protocol_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_declarationContext() *Protocol_declarationContext {
	var p = new(Protocol_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_declaration
	return p
}

func (*Protocol_declarationContext) IsProtocol_declarationContext() {}

func NewProtocol_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_declarationContext {
	var p = new(Protocol_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_declaration

	return p
}

func (s *Protocol_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_declarationContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjCParserPROTOCOL, 0)
}

func (s *Protocol_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(ObjCParserEND, 0)
}

func (s *Protocol_declarationContext) Protocol_name() IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_declarationContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Protocol_declarationContext) AllInterface_declaration_list() []IInterface_declaration_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem())
	var tst = make([]IInterface_declaration_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_declaration_listContext)
		}
	}

	return tst
}

func (s *Protocol_declarationContext) Interface_declaration_list(i int) IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Protocol_declarationContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserOPTIONAL, 0)
}

func (s *Protocol_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_declaration(s)
	}
}

func (s *Protocol_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_declaration(s)
	}
}




func (p *ObjCParser) Protocol_declaration() (localctx IProtocol_declarationContext) {
	localctx = NewProtocol_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ObjCParserRULE_protocol_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.Match(ObjCParserPROTOCOL)
	}

	{
		p.SetState(331)
		p.Protocol_name()
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLT {
		{
			p.SetState(332)
			p.Protocol_reference_list()
		}

	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(335)
			p.Interface_declaration_list()
		}


	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserOPTIONAL {
		{
			p.SetState(338)
			p.Match(ObjCParserOPTIONAL)
		}

	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 14)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 14))) & ((1 << (ObjCParserPROPERTY - 14)) | (1 << (ObjCParserAUTO - 14)) | (1 << (ObjCParserBYCOPY - 14)) | (1 << (ObjCParserBYREF - 14)) | (1 << (ObjCParserCHAR - 14)) | (1 << (ObjCParserCONST - 14)) | (1 << (ObjCParserDOUBLE - 14)) | (1 << (ObjCParserENUM - 14)) | (1 << (ObjCParserEXTERN - 14)) | (1 << (ObjCParserFLOAT - 14)) | (1 << (ObjCParserID - 14)) | (1 << (ObjCParserIN - 14)) | (1 << (ObjCParserINOUT - 14)))) != 0) || ((((_la - 47)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 47))) & ((1 << (ObjCParserINT - 47)) | (1 << (ObjCParserLONG - 47)) | (1 << (ObjCParserONEWAY - 47)) | (1 << (ObjCParserOUT - 47)) | (1 << (ObjCParserREGISTER - 47)) | (1 << (ObjCParserSHORT - 47)) | (1 << (ObjCParserSIGNED - 47)) | (1 << (ObjCParserSTATIC - 47)) | (1 << (ObjCParserSTRUCT - 47)) | (1 << (ObjCParserTYPEDEF - 47)) | (1 << (ObjCParserUNION - 47)) | (1 << (ObjCParserUNSIGNED - 47)) | (1 << (ObjCParserVOID - 47)) | (1 << (ObjCParserVOLATILE - 47)) | (1 << (ObjCParserNS_OPTIONS - 47)) | (1 << (ObjCParserNS_ENUM - 47)) | (1 << (ObjCParserWWEAK - 47)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 47)))) != 0) || ((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (ObjCParserADD - 95)) | (1 << (ObjCParserSUB - 95)) | (1 << (ObjCParserIDENTIFIER - 95)))) != 0) {
		{
			p.SetState(341)
			p.Interface_declaration_list()
		}

	}

	{
		p.SetState(344)
		p.Match(ObjCParserEND)
	}



	return localctx
}


// IProtocol_declaration_listContext is an interface to support dynamic dispatch.
type IProtocol_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_declaration_listContext differentiates from other interfaces.
	IsProtocol_declaration_listContext()
}

type Protocol_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_declaration_listContext() *Protocol_declaration_listContext {
	var p = new(Protocol_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_declaration_list
	return p
}

func (*Protocol_declaration_listContext) IsProtocol_declaration_listContext() {}

func NewProtocol_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_declaration_listContext {
	var p = new(Protocol_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_declaration_list

	return p
}

func (s *Protocol_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_declaration_listContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjCParserPROTOCOL, 0)
}

func (s *Protocol_declaration_listContext) Protocol_list() IProtocol_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_listContext)
}

func (s *Protocol_declaration_listContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Protocol_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_declaration_list(s)
	}
}

func (s *Protocol_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_declaration_list(s)
	}
}




func (p *ObjCParser) Protocol_declaration_list() (localctx IProtocol_declaration_listContext) {
	localctx = NewProtocol_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ObjCParserRULE_protocol_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(ObjCParserPROTOCOL)
	}
	{
		p.SetState(347)
		p.Protocol_list()
	}
	{
		p.SetState(348)
		p.Match(ObjCParserSEMI)
	}




	return localctx
}


// IClass_declaration_listContext is an interface to support dynamic dispatch.
type IClass_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_declaration_listContext differentiates from other interfaces.
	IsClass_declaration_listContext()
}

type Class_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_declaration_listContext() *Class_declaration_listContext {
	var p = new(Class_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_declaration_list
	return p
}

func (*Class_declaration_listContext) IsClass_declaration_listContext() {}

func NewClass_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_declaration_listContext {
	var p = new(Class_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_declaration_list

	return p
}

func (s *Class_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_declaration_listContext) CLASS() antlr.TerminalNode {
	return s.GetToken(ObjCParserCLASS, 0)
}

func (s *Class_declaration_listContext) Class_list() IClass_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_listContext)
}

func (s *Class_declaration_listContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Class_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_declaration_list(s)
	}
}

func (s *Class_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_declaration_list(s)
	}
}




func (p *ObjCParser) Class_declaration_list() (localctx IClass_declaration_listContext) {
	localctx = NewClass_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ObjCParserRULE_class_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(ObjCParserCLASS)
	}
	{
		p.SetState(351)
		p.Class_list()
	}
	{
		p.SetState(352)
		p.Match(ObjCParserSEMI)
	}




	return localctx
}


// IClass_listContext is an interface to support dynamic dispatch.
type IClass_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_listContext differentiates from other interfaces.
	IsClass_listContext()
}

type Class_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_listContext() *Class_listContext {
	var p = new(Class_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_list
	return p
}

func (*Class_listContext) IsClass_listContext() {}

func NewClass_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_listContext {
	var p = new(Class_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_list

	return p
}

func (s *Class_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_listContext) AllClass_name() []IClass_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_nameContext)(nil)).Elem())
	var tst = make([]IClass_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_nameContext)
		}
	}

	return tst
}

func (s *Class_listContext) Class_name(i int) IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Class_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Class_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_list(s)
	}
}

func (s *Class_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_list(s)
	}
}




func (p *ObjCParser) Class_list() (localctx IClass_listContext) {
	localctx = NewClass_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ObjCParserRULE_class_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Class_name()
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(355)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(356)
			p.Class_name()
		}


		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IProtocol_reference_listContext is an interface to support dynamic dispatch.
type IProtocol_reference_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_reference_listContext differentiates from other interfaces.
	IsProtocol_reference_listContext()
}

type Protocol_reference_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_reference_listContext() *Protocol_reference_listContext {
	var p = new(Protocol_reference_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_reference_list
	return p
}

func (*Protocol_reference_listContext) IsProtocol_reference_listContext() {}

func NewProtocol_reference_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_reference_listContext {
	var p = new(Protocol_reference_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_reference_list

	return p
}

func (s *Protocol_reference_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_reference_listContext) LT() antlr.TerminalNode {
	return s.GetToken(ObjCParserLT, 0)
}

func (s *Protocol_reference_listContext) Protocol_list() IProtocol_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_listContext)
}

func (s *Protocol_reference_listContext) GT() antlr.TerminalNode {
	return s.GetToken(ObjCParserGT, 0)
}

func (s *Protocol_reference_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_reference_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_reference_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_reference_list(s)
	}
}

func (s *Protocol_reference_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_reference_list(s)
	}
}




func (p *ObjCParser) Protocol_reference_list() (localctx IProtocol_reference_listContext) {
	localctx = NewProtocol_reference_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ObjCParserRULE_protocol_reference_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Match(ObjCParserLT)
	}
	{
		p.SetState(363)
		p.Protocol_list()
	}
	{
		p.SetState(364)
		p.Match(ObjCParserGT)
	}




	return localctx
}


// IProtocol_listContext is an interface to support dynamic dispatch.
type IProtocol_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_listContext differentiates from other interfaces.
	IsProtocol_listContext()
}

type Protocol_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_listContext() *Protocol_listContext {
	var p = new(Protocol_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_list
	return p
}

func (*Protocol_listContext) IsProtocol_listContext() {}

func NewProtocol_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_listContext {
	var p = new(Protocol_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_list

	return p
}

func (s *Protocol_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_listContext) AllProtocol_name() []IProtocol_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem())
	var tst = make([]IProtocol_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocol_nameContext)
		}
	}

	return tst
}

func (s *Protocol_listContext) Protocol_name(i int) IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Protocol_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Protocol_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_list(s)
	}
}

func (s *Protocol_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_list(s)
	}
}




func (p *ObjCParser) Protocol_list() (localctx IProtocol_listContext) {
	localctx = NewProtocol_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ObjCParserRULE_protocol_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Protocol_name()
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(367)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(368)
			p.Protocol_name()
		}


		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IProperty_declarationContext is an interface to support dynamic dispatch.
type IProperty_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_declarationContext differentiates from other interfaces.
	IsProperty_declarationContext()
}

type Property_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_declarationContext() *Property_declarationContext {
	var p = new(Property_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_declaration
	return p
}

func (*Property_declarationContext) IsProperty_declarationContext() {}

func NewProperty_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_declarationContext {
	var p = new(Property_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_declaration

	return p
}

func (s *Property_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_declarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(ObjCParserPROPERTY, 0)
}

func (s *Property_declarationContext) Struct_declaration() IStruct_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarationContext)
}

func (s *Property_declarationContext) Property_attributes_declaration() IProperty_attributes_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_attributes_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_attributes_declarationContext)
}

func (s *Property_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_declaration(s)
	}
}

func (s *Property_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_declaration(s)
	}
}




func (p *ObjCParser) Property_declaration() (localctx IProperty_declarationContext) {
	localctx = NewProperty_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ObjCParserRULE_property_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(ObjCParserPROPERTY)
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN {
		{
			p.SetState(375)
			p.Property_attributes_declaration()
		}

	}
	{
		p.SetState(378)
		p.Struct_declaration()
	}



	return localctx
}


// IProperty_attributes_declarationContext is an interface to support dynamic dispatch.
type IProperty_attributes_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_attributes_declarationContext differentiates from other interfaces.
	IsProperty_attributes_declarationContext()
}

type Property_attributes_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_attributes_declarationContext() *Property_attributes_declarationContext {
	var p = new(Property_attributes_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_attributes_declaration
	return p
}

func (*Property_attributes_declarationContext) IsProperty_attributes_declarationContext() {}

func NewProperty_attributes_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_attributes_declarationContext {
	var p = new(Property_attributes_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_attributes_declaration

	return p
}

func (s *Property_attributes_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_attributes_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Property_attributes_declarationContext) Property_attributes_list() IProperty_attributes_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_attributes_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_attributes_listContext)
}

func (s *Property_attributes_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Property_attributes_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_attributes_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_attributes_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_attributes_declaration(s)
	}
}

func (s *Property_attributes_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_attributes_declaration(s)
	}
}




func (p *ObjCParser) Property_attributes_declaration() (localctx IProperty_attributes_declarationContext) {
	localctx = NewProperty_attributes_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ObjCParserRULE_property_attributes_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(381)
		p.Property_attributes_list()
	}
	{
		p.SetState(382)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// IProperty_attributes_listContext is an interface to support dynamic dispatch.
type IProperty_attributes_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_attributes_listContext differentiates from other interfaces.
	IsProperty_attributes_listContext()
}

type Property_attributes_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_attributes_listContext() *Property_attributes_listContext {
	var p = new(Property_attributes_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_attributes_list
	return p
}

func (*Property_attributes_listContext) IsProperty_attributes_listContext() {}

func NewProperty_attributes_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_attributes_listContext {
	var p = new(Property_attributes_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_attributes_list

	return p
}

func (s *Property_attributes_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_attributes_listContext) AllProperty_attribute() []IProperty_attributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_attributeContext)(nil)).Elem())
	var tst = make([]IProperty_attributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_attributeContext)
		}
	}

	return tst
}

func (s *Property_attributes_listContext) Property_attribute(i int) IProperty_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_attributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_attributeContext)
}

func (s *Property_attributes_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Property_attributes_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Property_attributes_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_attributes_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_attributes_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_attributes_list(s)
	}
}

func (s *Property_attributes_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_attributes_list(s)
	}
}




func (p *ObjCParser) Property_attributes_list() (localctx IProperty_attributes_listContext) {
	localctx = NewProperty_attributes_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ObjCParserRULE_property_attributes_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Property_attribute()
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(385)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(386)
			p.Property_attribute()
		}


		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IProperty_attributeContext is an interface to support dynamic dispatch.
type IProperty_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_attributeContext differentiates from other interfaces.
	IsProperty_attributeContext()
}

type Property_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_attributeContext() *Property_attributeContext {
	var p = new(Property_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_attribute
	return p
}

func (*Property_attributeContext) IsProperty_attributeContext() {}

func NewProperty_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_attributeContext {
	var p = new(Property_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_attribute

	return p
}

func (s *Property_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_attributeContext) NONATOMIC() antlr.TerminalNode {
	return s.GetToken(ObjCParserNONATOMIC, 0)
}

func (s *Property_attributeContext) ASSIGNPA() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGNPA, 0)
}

func (s *Property_attributeContext) WEAK() antlr.TerminalNode {
	return s.GetToken(ObjCParserWEAK, 0)
}

func (s *Property_attributeContext) STRONG() antlr.TerminalNode {
	return s.GetToken(ObjCParserSTRONG, 0)
}

func (s *Property_attributeContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRETAIN, 0)
}

func (s *Property_attributeContext) READONLY() antlr.TerminalNode {
	return s.GetToken(ObjCParserREADONLY, 0)
}

func (s *Property_attributeContext) READWRITE() antlr.TerminalNode {
	return s.GetToken(ObjCParserREADWRITE, 0)
}

func (s *Property_attributeContext) GETTER() antlr.TerminalNode {
	return s.GetToken(ObjCParserGETTER, 0)
}

func (s *Property_attributeContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGN, 0)
}

func (s *Property_attributeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Property_attributeContext) SETTER() antlr.TerminalNode {
	return s.GetToken(ObjCParserSETTER, 0)
}

func (s *Property_attributeContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Property_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_attribute(s)
	}
}

func (s *Property_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_attribute(s)
	}
}




func (p *ObjCParser) Property_attribute() (localctx IProperty_attributeContext) {
	localctx = NewProperty_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ObjCParserRULE_property_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(408)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserNONATOMIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(392)
			p.Match(ObjCParserNONATOMIC)
		}


	case ObjCParserASSIGNPA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(393)
			p.Match(ObjCParserASSIGNPA)
		}


	case ObjCParserWEAK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(394)
			p.Match(ObjCParserWEAK)
		}


	case ObjCParserSTRONG:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(395)
			p.Match(ObjCParserSTRONG)
		}


	case ObjCParserRETAIN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(396)
			p.Match(ObjCParserRETAIN)
		}


	case ObjCParserREADONLY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(397)
			p.Match(ObjCParserREADONLY)
		}


	case ObjCParserREADWRITE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(398)
			p.Match(ObjCParserREADWRITE)
		}


	case ObjCParserRPAREN, ObjCParserCOMMA:
		p.EnterOuterAlt(localctx, 8)


	case ObjCParserGETTER:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(400)
			p.Match(ObjCParserGETTER)
		}
		{
			p.SetState(401)
			p.Match(ObjCParserASSIGN)
		}
		{
			p.SetState(402)
			p.Match(ObjCParserIDENTIFIER)
		}


	case ObjCParserSETTER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(403)
			p.Match(ObjCParserSETTER)
		}
		{
			p.SetState(404)
			p.Match(ObjCParserASSIGN)
		}
		{
			p.SetState(405)
			p.Match(ObjCParserIDENTIFIER)
		}
		{
			p.SetState(406)
			p.Match(ObjCParserCOLON)
		}


	case ObjCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(407)
			p.Match(ObjCParserIDENTIFIER)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IClass_nameContext is an interface to support dynamic dispatch.
type IClass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_nameContext differentiates from other interfaces.
	IsClass_nameContext()
}

type Class_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_nameContext() *Class_nameContext {
	var p = new(Class_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_name
	return p
}

func (*Class_nameContext) IsClass_nameContext() {}

func NewClass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_nameContext {
	var p = new(Class_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_name

	return p
}

func (s *Class_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Class_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_name(s)
	}
}

func (s *Class_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_name(s)
	}
}




func (p *ObjCParser) Class_name() (localctx IClass_nameContext) {
	localctx = NewClass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ObjCParserRULE_class_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// ISuperclass_nameContext is an interface to support dynamic dispatch.
type ISuperclass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperclass_nameContext differentiates from other interfaces.
	IsSuperclass_nameContext()
}

type Superclass_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperclass_nameContext() *Superclass_nameContext {
	var p = new(Superclass_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_superclass_name
	return p
}

func (*Superclass_nameContext) IsSuperclass_nameContext() {}

func NewSuperclass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Superclass_nameContext {
	var p = new(Superclass_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_superclass_name

	return p
}

func (s *Superclass_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Superclass_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Superclass_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Superclass_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Superclass_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSuperclass_name(s)
	}
}

func (s *Superclass_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSuperclass_name(s)
	}
}




func (p *ObjCParser) Superclass_name() (localctx ISuperclass_nameContext) {
	localctx = NewSuperclass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ObjCParserRULE_superclass_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// ICategory_nameContext is an interface to support dynamic dispatch.
type ICategory_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_nameContext differentiates from other interfaces.
	IsCategory_nameContext()
}

type Category_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_nameContext() *Category_nameContext {
	var p = new(Category_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_category_name
	return p
}

func (*Category_nameContext) IsCategory_nameContext() {}

func NewCategory_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_nameContext {
	var p = new(Category_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_category_name

	return p
}

func (s *Category_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Category_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCategory_name(s)
	}
}

func (s *Category_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCategory_name(s)
	}
}




func (p *ObjCParser) Category_name() (localctx ICategory_nameContext) {
	localctx = NewCategory_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ObjCParserRULE_category_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// IProtocol_nameContext is an interface to support dynamic dispatch.
type IProtocol_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_nameContext differentiates from other interfaces.
	IsProtocol_nameContext()
}

type Protocol_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_nameContext() *Protocol_nameContext {
	var p = new(Protocol_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_name
	return p
}

func (*Protocol_nameContext) IsProtocol_nameContext() {}

func NewProtocol_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_nameContext {
	var p = new(Protocol_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_name

	return p
}

func (s *Protocol_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Protocol_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_name(s)
	}
}

func (s *Protocol_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_name(s)
	}
}




func (p *ObjCParser) Protocol_name() (localctx IProtocol_nameContext) {
	localctx = NewProtocol_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ObjCParserRULE_protocol_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// IInstance_variablesContext is an interface to support dynamic dispatch.
type IInstance_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_variablesContext differentiates from other interfaces.
	IsInstance_variablesContext()
}

type Instance_variablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_variablesContext() *Instance_variablesContext {
	var p = new(Instance_variablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_instance_variables
	return p
}

func (*Instance_variablesContext) IsInstance_variablesContext() {}

func NewInstance_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_variablesContext {
	var p = new(Instance_variablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_instance_variables

	return p
}

func (s *Instance_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_variablesContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *Instance_variablesContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *Instance_variablesContext) AllStruct_declaration() []IStruct_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem())
	var tst = make([]IStruct_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declarationContext)
		}
	}

	return tst
}

func (s *Instance_variablesContext) Struct_declaration(i int) IStruct_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarationContext)
}

func (s *Instance_variablesContext) Visibility_specification() IVisibility_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibility_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibility_specificationContext)
}

func (s *Instance_variablesContext) Instance_variables() IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Instance_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInstance_variables(s)
	}
}

func (s *Instance_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInstance_variables(s)
	}
}




func (p *ObjCParser) Instance_variables() (localctx IInstance_variablesContext) {
	localctx = NewInstance_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ObjCParserRULE_instance_variables)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(418)
			p.Match(ObjCParserLBRACE)
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserCHAR - 28)) | (1 << (ObjCParserCONST - 28)) | (1 << (ObjCParserDOUBLE - 28)) | (1 << (ObjCParserENUM - 28)) | (1 << (ObjCParserFLOAT - 28)) | (1 << (ObjCParserID - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserINT - 28)) | (1 << (ObjCParserLONG - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)) | (1 << (ObjCParserSHORT - 28)) | (1 << (ObjCParserSIGNED - 28)) | (1 << (ObjCParserSTRUCT - 28)))) != 0) || ((((_la - 60)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 60))) & ((1 << (ObjCParserUNION - 60)) | (1 << (ObjCParserUNSIGNED - 60)) | (1 << (ObjCParserVOID - 60)) | (1 << (ObjCParserVOLATILE - 60)) | (1 << (ObjCParserNS_OPTIONS - 60)) | (1 << (ObjCParserNS_ENUM - 60)) | (1 << (ObjCParserWWEAK - 60)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 60)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(419)
				p.Struct_declaration()
			}


			p.SetState(424)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(425)
			p.Match(ObjCParserRBRACE)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(426)
			p.Match(ObjCParserLBRACE)
		}
		{
			p.SetState(427)
			p.Visibility_specification()
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserCHAR - 28)) | (1 << (ObjCParserCONST - 28)) | (1 << (ObjCParserDOUBLE - 28)) | (1 << (ObjCParserENUM - 28)) | (1 << (ObjCParserFLOAT - 28)) | (1 << (ObjCParserID - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserINT - 28)) | (1 << (ObjCParserLONG - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)) | (1 << (ObjCParserSHORT - 28)) | (1 << (ObjCParserSIGNED - 28)) | (1 << (ObjCParserSTRUCT - 28)))) != 0) || ((((_la - 60)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 60))) & ((1 << (ObjCParserUNION - 60)) | (1 << (ObjCParserUNSIGNED - 60)) | (1 << (ObjCParserVOID - 60)) | (1 << (ObjCParserVOLATILE - 60)) | (1 << (ObjCParserNS_OPTIONS - 60)) | (1 << (ObjCParserNS_ENUM - 60)) | (1 << (ObjCParserWWEAK - 60)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 60)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(428)
				p.Struct_declaration()
			}


			p.SetState(431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(433)
			p.Match(ObjCParserRBRACE)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(435)
			p.Match(ObjCParserLBRACE)
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserCHAR - 28)) | (1 << (ObjCParserCONST - 28)) | (1 << (ObjCParserDOUBLE - 28)) | (1 << (ObjCParserENUM - 28)) | (1 << (ObjCParserFLOAT - 28)) | (1 << (ObjCParserID - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserINT - 28)) | (1 << (ObjCParserLONG - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)) | (1 << (ObjCParserSHORT - 28)) | (1 << (ObjCParserSIGNED - 28)) | (1 << (ObjCParserSTRUCT - 28)))) != 0) || ((((_la - 60)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 60))) & ((1 << (ObjCParserUNION - 60)) | (1 << (ObjCParserUNSIGNED - 60)) | (1 << (ObjCParserVOID - 60)) | (1 << (ObjCParserVOLATILE - 60)) | (1 << (ObjCParserNS_OPTIONS - 60)) | (1 << (ObjCParserNS_ENUM - 60)) | (1 << (ObjCParserWWEAK - 60)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 60)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(436)
				p.Struct_declaration()
			}


			p.SetState(439)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(441)
			p.Instance_variables()
		}
		{
			p.SetState(442)
			p.Match(ObjCParserRBRACE)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(444)
			p.Match(ObjCParserLBRACE)
		}
		{
			p.SetState(445)
			p.Visibility_specification()
		}
		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserCHAR - 28)) | (1 << (ObjCParserCONST - 28)) | (1 << (ObjCParserDOUBLE - 28)) | (1 << (ObjCParserENUM - 28)) | (1 << (ObjCParserFLOAT - 28)) | (1 << (ObjCParserID - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserINT - 28)) | (1 << (ObjCParserLONG - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)) | (1 << (ObjCParserSHORT - 28)) | (1 << (ObjCParserSIGNED - 28)) | (1 << (ObjCParserSTRUCT - 28)))) != 0) || ((((_la - 60)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 60))) & ((1 << (ObjCParserUNION - 60)) | (1 << (ObjCParserUNSIGNED - 60)) | (1 << (ObjCParserVOID - 60)) | (1 << (ObjCParserVOLATILE - 60)) | (1 << (ObjCParserNS_OPTIONS - 60)) | (1 << (ObjCParserNS_ENUM - 60)) | (1 << (ObjCParserWWEAK - 60)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 60)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(446)
				p.Struct_declaration()
			}


			p.SetState(449)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(451)
			p.Instance_variables()
		}
		{
			p.SetState(452)
			p.Match(ObjCParserRBRACE)
		}

	}


	return localctx
}


// IVisibility_specificationContext is an interface to support dynamic dispatch.
type IVisibility_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibility_specificationContext differentiates from other interfaces.
	IsVisibility_specificationContext()
}

type Visibility_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibility_specificationContext() *Visibility_specificationContext {
	var p = new(Visibility_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_visibility_specification
	return p
}

func (*Visibility_specificationContext) IsVisibility_specificationContext() {}

func NewVisibility_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Visibility_specificationContext {
	var p = new(Visibility_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_visibility_specification

	return p
}

func (s *Visibility_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Visibility_specificationContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(ObjCParserPRIVATE, 0)
}

func (s *Visibility_specificationContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(ObjCParserPROTECTED, 0)
}

func (s *Visibility_specificationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(ObjCParserPACKAGE, 0)
}

func (s *Visibility_specificationContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(ObjCParserPUBLIC, 0)
}

func (s *Visibility_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Visibility_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Visibility_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterVisibility_specification(s)
	}
}

func (s *Visibility_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitVisibility_specification(s)
	}
}




func (p *ObjCParser) Visibility_specification() (localctx IVisibility_specificationContext) {
	localctx = NewVisibility_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ObjCParserRULE_visibility_specification)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserPACKAGE) | (1 << ObjCParserPRIVATE) | (1 << ObjCParserPROTECTED) | (1 << ObjCParserPUBLIC))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IInterface_declaration_listContext is an interface to support dynamic dispatch.
type IInterface_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declaration_listContext differentiates from other interfaces.
	IsInterface_declaration_listContext()
}

type Interface_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declaration_listContext() *Interface_declaration_listContext {
	var p = new(Interface_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_interface_declaration_list
	return p
}

func (*Interface_declaration_listContext) IsInterface_declaration_listContext() {}

func NewInterface_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declaration_listContext {
	var p = new(Interface_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_interface_declaration_list

	return p
}

func (s *Interface_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declaration_listContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Interface_declaration_listContext) AllClass_method_declaration() []IClass_method_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_method_declarationContext)(nil)).Elem())
	var tst = make([]IClass_method_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_method_declarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Class_method_declaration(i int) IClass_method_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_method_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_method_declarationContext)
}

func (s *Interface_declaration_listContext) AllInstance_method_declaration() []IInstance_method_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_method_declarationContext)(nil)).Elem())
	var tst = make([]IInstance_method_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_method_declarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Instance_method_declaration(i int) IInstance_method_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_method_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_method_declarationContext)
}

func (s *Interface_declaration_listContext) AllProperty_declaration() []IProperty_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_declarationContext)(nil)).Elem())
	var tst = make([]IProperty_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_declarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Property_declaration(i int) IProperty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_declarationContext)
}

func (s *Interface_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Interface_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInterface_declaration_list(s)
	}
}

func (s *Interface_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInterface_declaration_list(s)
	}
}




func (p *ObjCParser) Interface_declaration_list() (localctx IInterface_declaration_listContext) {
	localctx = NewInterface_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ObjCParserRULE_interface_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(462)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjCParserAUTO, ObjCParserBYCOPY, ObjCParserBYREF, ObjCParserCHAR, ObjCParserCONST, ObjCParserDOUBLE, ObjCParserENUM, ObjCParserEXTERN, ObjCParserFLOAT, ObjCParserID, ObjCParserIN, ObjCParserINOUT, ObjCParserINT, ObjCParserLONG, ObjCParserONEWAY, ObjCParserOUT, ObjCParserREGISTER, ObjCParserSHORT, ObjCParserSIGNED, ObjCParserSTATIC, ObjCParserSTRUCT, ObjCParserTYPEDEF, ObjCParserUNION, ObjCParserUNSIGNED, ObjCParserVOID, ObjCParserVOLATILE, ObjCParserNS_OPTIONS, ObjCParserNS_ENUM, ObjCParserWWEAK, ObjCParserWUNSAFE_UNRETAINED, ObjCParserIDENTIFIER:
					{
						p.SetState(458)
						p.Declaration()
					}


				case ObjCParserADD:
					{
						p.SetState(459)
						p.Class_method_declaration()
					}


				case ObjCParserSUB:
					{
						p.SetState(460)
						p.Instance_method_declaration()
					}


				case ObjCParserPROPERTY:
					{
						p.SetState(461)
						p.Property_declaration()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}



	return localctx
}


// IClass_method_declarationContext is an interface to support dynamic dispatch.
type IClass_method_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_method_declarationContext differentiates from other interfaces.
	IsClass_method_declarationContext()
}

type Class_method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_method_declarationContext() *Class_method_declarationContext {
	var p = new(Class_method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_method_declaration
	return p
}

func (*Class_method_declarationContext) IsClass_method_declarationContext() {}

func NewClass_method_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_method_declarationContext {
	var p = new(Class_method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_method_declaration

	return p
}

func (s *Class_method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_method_declarationContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjCParserADD, 0)
}

func (s *Class_method_declarationContext) Method_declaration() IMethod_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_declarationContext)
}

func (s *Class_method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_method_declaration(s)
	}
}

func (s *Class_method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_method_declaration(s)
	}
}




func (p *ObjCParser) Class_method_declaration() (localctx IClass_method_declarationContext) {
	localctx = NewClass_method_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ObjCParserRULE_class_method_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(ObjCParserADD)
	}
	{
		p.SetState(467)
		p.Method_declaration()
	}




	return localctx
}


// IInstance_method_declarationContext is an interface to support dynamic dispatch.
type IInstance_method_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_method_declarationContext differentiates from other interfaces.
	IsInstance_method_declarationContext()
}

type Instance_method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_method_declarationContext() *Instance_method_declarationContext {
	var p = new(Instance_method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_instance_method_declaration
	return p
}

func (*Instance_method_declarationContext) IsInstance_method_declarationContext() {}

func NewInstance_method_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_method_declarationContext {
	var p = new(Instance_method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_instance_method_declaration

	return p
}

func (s *Instance_method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_method_declarationContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUB, 0)
}

func (s *Instance_method_declarationContext) Method_declaration() IMethod_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_declarationContext)
}

func (s *Instance_method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInstance_method_declaration(s)
	}
}

func (s *Instance_method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInstance_method_declaration(s)
	}
}




func (p *ObjCParser) Instance_method_declaration() (localctx IInstance_method_declarationContext) {
	localctx = NewInstance_method_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ObjCParserRULE_instance_method_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(ObjCParserSUB)
	}
	{
		p.SetState(470)
		p.Method_declaration()
	}




	return localctx
}


// IMethod_declarationContext is an interface to support dynamic dispatch.
type IMethod_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_declarationContext differentiates from other interfaces.
	IsMethod_declarationContext()
}

type Method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_declarationContext() *Method_declarationContext {
	var p = new(Method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_method_declaration
	return p
}

func (*Method_declarationContext) IsMethod_declarationContext() {}

func NewMethod_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_declarationContext {
	var p = new(Method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_method_declaration

	return p
}

func (s *Method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_declarationContext) Method_selector() IMethod_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_selectorContext)
}

func (s *Method_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Method_declarationContext) Method_type() IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMethod_declaration(s)
	}
}

func (s *Method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMethod_declaration(s)
	}
}




func (p *ObjCParser) Method_declaration() (localctx IMethod_declarationContext) {
	localctx = NewMethod_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ObjCParserRULE_method_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN {
		{
			p.SetState(472)
			p.Method_type()
		}

	}
	{
		p.SetState(475)
		p.Method_selector()
	}
	{
		p.SetState(476)
		p.Match(ObjCParserSEMI)
	}



	return localctx
}


// IImplementation_definition_listContext is an interface to support dynamic dispatch.
type IImplementation_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementation_definition_listContext differentiates from other interfaces.
	IsImplementation_definition_listContext()
}

type Implementation_definition_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementation_definition_listContext() *Implementation_definition_listContext {
	var p = new(Implementation_definition_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_implementation_definition_list
	return p
}

func (*Implementation_definition_listContext) IsImplementation_definition_listContext() {}

func NewImplementation_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Implementation_definition_listContext {
	var p = new(Implementation_definition_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_implementation_definition_list

	return p
}

func (s *Implementation_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Implementation_definition_listContext) AllFunction_definition() []IFunction_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem())
	var tst = make([]IFunction_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Function_definition(i int) IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *Implementation_definition_listContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Implementation_definition_listContext) AllClass_method_definition() []IClass_method_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_method_definitionContext)(nil)).Elem())
	var tst = make([]IClass_method_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_method_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Class_method_definition(i int) IClass_method_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_method_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_method_definitionContext)
}

func (s *Implementation_definition_listContext) AllInstance_method_definition() []IInstance_method_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_method_definitionContext)(nil)).Elem())
	var tst = make([]IInstance_method_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_method_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Instance_method_definition(i int) IInstance_method_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_method_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_method_definitionContext)
}

func (s *Implementation_definition_listContext) AllProperty_implementation() []IProperty_implementationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_implementationContext)(nil)).Elem())
	var tst = make([]IProperty_implementationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_implementationContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Property_implementation(i int) IProperty_implementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_implementationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_implementationContext)
}

func (s *Implementation_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Implementation_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Implementation_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterImplementation_definition_list(s)
	}
}

func (s *Implementation_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitImplementation_definition_list(s)
	}
}




func (p *ObjCParser) Implementation_definition_list() (localctx IImplementation_definition_listContext) {
	localctx = NewImplementation_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ObjCParserRULE_implementation_definition_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserDYNAMIC) | (1 << ObjCParserSYNTHESIZE) | (1 << ObjCParserAUTO) | (1 << ObjCParserBYCOPY) | (1 << ObjCParserBYREF) | (1 << ObjCParserCHAR))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjCParserCONST - 32)) | (1 << (ObjCParserDOUBLE - 32)) | (1 << (ObjCParserENUM - 32)) | (1 << (ObjCParserEXTERN - 32)) | (1 << (ObjCParserFLOAT - 32)) | (1 << (ObjCParserID - 32)) | (1 << (ObjCParserIN - 32)) | (1 << (ObjCParserINOUT - 32)) | (1 << (ObjCParserINT - 32)) | (1 << (ObjCParserLONG - 32)) | (1 << (ObjCParserONEWAY - 32)) | (1 << (ObjCParserOUT - 32)) | (1 << (ObjCParserREGISTER - 32)) | (1 << (ObjCParserSHORT - 32)) | (1 << (ObjCParserSIGNED - 32)) | (1 << (ObjCParserSTATIC - 32)) | (1 << (ObjCParserSTRUCT - 32)) | (1 << (ObjCParserTYPEDEF - 32)) | (1 << (ObjCParserUNION - 32)) | (1 << (ObjCParserUNSIGNED - 32)) | (1 << (ObjCParserVOID - 32)) | (1 << (ObjCParserVOLATILE - 32)))) != 0) || ((((_la - 65)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 65))) & ((1 << (ObjCParserNS_OPTIONS - 65)) | (1 << (ObjCParserNS_ENUM - 65)) | (1 << (ObjCParserWWEAK - 65)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParserLPAREN - 65)) | (1 << (ObjCParserADD - 65)) | (1 << (ObjCParserSUB - 65)))) != 0) || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
		p.SetState(483)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(478)
				p.Function_definition()
			}


		case 2:
			{
				p.SetState(479)
				p.Declaration()
			}


		case 3:
			{
				p.SetState(480)
				p.Class_method_definition()
			}


		case 4:
			{
				p.SetState(481)
				p.Instance_method_definition()
			}


		case 5:
			{
				p.SetState(482)
				p.Property_implementation()
			}

		}

		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IClass_method_definitionContext is an interface to support dynamic dispatch.
type IClass_method_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_method_definitionContext differentiates from other interfaces.
	IsClass_method_definitionContext()
}

type Class_method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_method_definitionContext() *Class_method_definitionContext {
	var p = new(Class_method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_class_method_definition
	return p
}

func (*Class_method_definitionContext) IsClass_method_definitionContext() {}

func NewClass_method_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_method_definitionContext {
	var p = new(Class_method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_class_method_definition

	return p
}

func (s *Class_method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_method_definitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ObjCParserADD, 0)
}

func (s *Class_method_definitionContext) Method_definition() IMethod_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_definitionContext)
}

func (s *Class_method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterClass_method_definition(s)
	}
}

func (s *Class_method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitClass_method_definition(s)
	}
}




func (p *ObjCParser) Class_method_definition() (localctx IClass_method_definitionContext) {
	localctx = NewClass_method_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ObjCParserRULE_class_method_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(ObjCParserADD)
	}
	{
		p.SetState(488)
		p.Method_definition()
	}




	return localctx
}


// IInstance_method_definitionContext is an interface to support dynamic dispatch.
type IInstance_method_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_method_definitionContext differentiates from other interfaces.
	IsInstance_method_definitionContext()
}

type Instance_method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_method_definitionContext() *Instance_method_definitionContext {
	var p = new(Instance_method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_instance_method_definition
	return p
}

func (*Instance_method_definitionContext) IsInstance_method_definitionContext() {}

func NewInstance_method_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_method_definitionContext {
	var p = new(Instance_method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_instance_method_definition

	return p
}

func (s *Instance_method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_method_definitionContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUB, 0)
}

func (s *Instance_method_definitionContext) Method_definition() IMethod_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_definitionContext)
}

func (s *Instance_method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInstance_method_definition(s)
	}
}

func (s *Instance_method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInstance_method_definition(s)
	}
}




func (p *ObjCParser) Instance_method_definition() (localctx IInstance_method_definitionContext) {
	localctx = NewInstance_method_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ObjCParserRULE_instance_method_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)
		p.Match(ObjCParserSUB)
	}
	{
		p.SetState(491)
		p.Method_definition()
	}




	return localctx
}


// IMethod_definitionContext is an interface to support dynamic dispatch.
type IMethod_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_definitionContext differentiates from other interfaces.
	IsMethod_definitionContext()
}

type Method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_definitionContext() *Method_definitionContext {
	var p = new(Method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_method_definition
	return p
}

func (*Method_definitionContext) IsMethod_definitionContext() {}

func NewMethod_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_definitionContext {
	var p = new(Method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_method_definition

	return p
}

func (s *Method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_definitionContext) Method_selector() IMethod_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_selectorContext)
}

func (s *Method_definitionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Method_definitionContext) Method_type() IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Method_definitionContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Method_definitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMethod_definition(s)
	}
}

func (s *Method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMethod_definition(s)
	}
}




func (p *ObjCParser) Method_definition() (localctx IMethod_definitionContext) {
	localctx = NewMethod_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ObjCParserRULE_method_definition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN {
		{
			p.SetState(493)
			p.Method_type()
		}

	}
	{
		p.SetState(496)
		p.Method_selector()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(497)
			p.Init_declarator_list()
		}

	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserSEMI {
		{
			p.SetState(500)
			p.Match(ObjCParserSEMI)
		}

	}
	{
		p.SetState(503)
		p.Compound_statement()
	}



	return localctx
}


// IMethod_selectorContext is an interface to support dynamic dispatch.
type IMethod_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_selectorContext differentiates from other interfaces.
	IsMethod_selectorContext()
}

type Method_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_selectorContext() *Method_selectorContext {
	var p = new(Method_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_method_selector
	return p
}

func (*Method_selectorContext) IsMethod_selectorContext() {}

func NewMethod_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_selectorContext {
	var p = new(Method_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_method_selector

	return p
}

func (s *Method_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_selectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Method_selectorContext) AllKeyword_declarator() []IKeyword_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyword_declaratorContext)(nil)).Elem())
	var tst = make([]IKeyword_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyword_declaratorContext)
		}
	}

	return tst
}

func (s *Method_selectorContext) Keyword_declarator(i int) IKeyword_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyword_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyword_declaratorContext)
}

func (s *Method_selectorContext) Parameter_list() IParameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_listContext)
}

func (s *Method_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMethod_selector(s)
	}
}

func (s *Method_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMethod_selector(s)
	}
}




func (p *ObjCParser) Method_selector() (localctx IMethod_selectorContext) {
	localctx = NewMethod_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ObjCParserRULE_method_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(506)
						p.Keyword_declarator()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(509)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(511)
				p.Parameter_list()
			}


		}


	}


	return localctx
}


// IKeyword_declaratorContext is an interface to support dynamic dispatch.
type IKeyword_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyword_declaratorContext differentiates from other interfaces.
	IsKeyword_declaratorContext()
}

type Keyword_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_declaratorContext() *Keyword_declaratorContext {
	var p = new(Keyword_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_keyword_declarator
	return p
}

func (*Keyword_declaratorContext) IsKeyword_declaratorContext() {}

func NewKeyword_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_declaratorContext {
	var p = new(Keyword_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_keyword_declarator

	return p
}

func (s *Keyword_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_declaratorContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Keyword_declaratorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Keyword_declaratorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Keyword_declaratorContext) AllMethod_type() []IMethod_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem())
	var tst = make([]IMethod_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_typeContext)
		}
	}

	return tst
}

func (s *Keyword_declaratorContext) Method_type(i int) IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Keyword_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterKeyword_declarator(s)
	}
}

func (s *Keyword_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitKeyword_declarator(s)
	}
}




func (p *ObjCParser) Keyword_declarator() (localctx IKeyword_declaratorContext) {
	localctx = NewKeyword_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ObjCParserRULE_keyword_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserIDENTIFIER {
		{
			p.SetState(516)
			p.Selector()
		}

	}
	{
		p.SetState(519)
		p.Match(ObjCParserCOLON)
	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserLPAREN {
		{
			p.SetState(520)
			p.Method_type()
		}


		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(526)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_selector
	return p
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSelector(s)
	}
}

func (s *SelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSelector(s)
	}
}




func (p *ObjCParser) Selector() (localctx ISelectorContext) {
	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ObjCParserRULE_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// IMethod_typeContext is an interface to support dynamic dispatch.
type IMethod_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_typeContext differentiates from other interfaces.
	IsMethod_typeContext()
}

type Method_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_typeContext() *Method_typeContext {
	var p = new(Method_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_method_type
	return p
}

func (*Method_typeContext) IsMethod_typeContext() {}

func NewMethod_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_typeContext {
	var p = new(Method_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_method_type

	return p
}

func (s *Method_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_typeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Method_typeContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Method_typeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Method_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMethod_type(s)
	}
}

func (s *Method_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMethod_type(s)
	}
}




func (p *ObjCParser) Method_type() (localctx IMethod_typeContext) {
	localctx = NewMethod_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ObjCParserRULE_method_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(531)
		p.Type_name()
	}
	{
		p.SetState(532)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// IProperty_implementationContext is an interface to support dynamic dispatch.
type IProperty_implementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_implementationContext differentiates from other interfaces.
	IsProperty_implementationContext()
}

type Property_implementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_implementationContext() *Property_implementationContext {
	var p = new(Property_implementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_implementation
	return p
}

func (*Property_implementationContext) IsProperty_implementationContext() {}

func NewProperty_implementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_implementationContext {
	var p = new(Property_implementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_implementation

	return p
}

func (s *Property_implementationContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_implementationContext) SYNTHESIZE() antlr.TerminalNode {
	return s.GetToken(ObjCParserSYNTHESIZE, 0)
}

func (s *Property_implementationContext) Property_synthesize_list() IProperty_synthesize_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_synthesize_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_synthesize_listContext)
}

func (s *Property_implementationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Property_implementationContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(ObjCParserDYNAMIC, 0)
}

func (s *Property_implementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_implementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_implementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_implementation(s)
	}
}

func (s *Property_implementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_implementation(s)
	}
}




func (p *ObjCParser) Property_implementation() (localctx IProperty_implementationContext) {
	localctx = NewProperty_implementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ObjCParserRULE_property_implementation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(542)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserSYNTHESIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Match(ObjCParserSYNTHESIZE)
		}
		{
			p.SetState(535)
			p.Property_synthesize_list()
		}
		{
			p.SetState(536)
			p.Match(ObjCParserSEMI)
		}


	case ObjCParserDYNAMIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.Match(ObjCParserDYNAMIC)
		}
		{
			p.SetState(539)
			p.Property_synthesize_list()
		}
		{
			p.SetState(540)
			p.Match(ObjCParserSEMI)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IProperty_synthesize_listContext is an interface to support dynamic dispatch.
type IProperty_synthesize_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_synthesize_listContext differentiates from other interfaces.
	IsProperty_synthesize_listContext()
}

type Property_synthesize_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_synthesize_listContext() *Property_synthesize_listContext {
	var p = new(Property_synthesize_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_synthesize_list
	return p
}

func (*Property_synthesize_listContext) IsProperty_synthesize_listContext() {}

func NewProperty_synthesize_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_synthesize_listContext {
	var p = new(Property_synthesize_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_synthesize_list

	return p
}

func (s *Property_synthesize_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_synthesize_listContext) AllProperty_synthesize_item() []IProperty_synthesize_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_synthesize_itemContext)(nil)).Elem())
	var tst = make([]IProperty_synthesize_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_synthesize_itemContext)
		}
	}

	return tst
}

func (s *Property_synthesize_listContext) Property_synthesize_item(i int) IProperty_synthesize_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_synthesize_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_synthesize_itemContext)
}

func (s *Property_synthesize_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Property_synthesize_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Property_synthesize_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_synthesize_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_synthesize_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_synthesize_list(s)
	}
}

func (s *Property_synthesize_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_synthesize_list(s)
	}
}




func (p *ObjCParser) Property_synthesize_list() (localctx IProperty_synthesize_listContext) {
	localctx = NewProperty_synthesize_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ObjCParserRULE_property_synthesize_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Property_synthesize_item()
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(545)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(546)
			p.Property_synthesize_item()
		}


		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IProperty_synthesize_itemContext is an interface to support dynamic dispatch.
type IProperty_synthesize_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_synthesize_itemContext differentiates from other interfaces.
	IsProperty_synthesize_itemContext()
}

type Property_synthesize_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_synthesize_itemContext() *Property_synthesize_itemContext {
	var p = new(Property_synthesize_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_property_synthesize_item
	return p
}

func (*Property_synthesize_itemContext) IsProperty_synthesize_itemContext() {}

func NewProperty_synthesize_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_synthesize_itemContext {
	var p = new(Property_synthesize_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_property_synthesize_item

	return p
}

func (s *Property_synthesize_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_synthesize_itemContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserIDENTIFIER)
}

func (s *Property_synthesize_itemContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, i)
}

func (s *Property_synthesize_itemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGN, 0)
}

func (s *Property_synthesize_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_synthesize_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Property_synthesize_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProperty_synthesize_item(s)
	}
}

func (s *Property_synthesize_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProperty_synthesize_item(s)
	}
}




func (p *ObjCParser) Property_synthesize_item() (localctx IProperty_synthesize_itemContext) {
	localctx = NewProperty_synthesize_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ObjCParserRULE_property_synthesize_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.Match(ObjCParserIDENTIFIER)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(553)
			p.Match(ObjCParserIDENTIFIER)
		}
		{
			p.SetState(554)
			p.Match(ObjCParserASSIGN)
		}
		{
			p.SetState(555)
			p.Match(ObjCParserIDENTIFIER)
		}

	}


	return localctx
}


// IBlock_typeContext is an interface to support dynamic dispatch.
type IBlock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_typeContext differentiates from other interfaces.
	IsBlock_typeContext()
}

type Block_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_typeContext() *Block_typeContext {
	var p = new(Block_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_block_type
	return p
}

func (*Block_typeContext) IsBlock_typeContext() {}

func NewBlock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_typeContext {
	var p = new(Block_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_block_type

	return p
}

func (s *Block_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_typeContext) AllType_specifier() []IType_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specifierContext)(nil)).Elem())
	var tst = make([]IType_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specifierContext)
		}
	}

	return tst
}

func (s *Block_typeContext) Type_specifier(i int) IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Block_typeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Block_typeContext) CARET() antlr.TerminalNode {
	return s.GetToken(ObjCParserCARET, 0)
}

func (s *Block_typeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Block_typeContext) Block_parameters() IBlock_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_parametersContext)
}

func (s *Block_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Block_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterBlock_type(s)
	}
}

func (s *Block_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitBlock_type(s)
	}
}




func (p *ObjCParser) Block_type() (localctx IBlock_typeContext) {
	localctx = NewBlock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ObjCParserRULE_block_type)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Type_specifier()
	}
	{
		p.SetState(559)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(560)
		p.Match(ObjCParserCARET)
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 31)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 31))) & ((1 << (ObjCParserCHAR - 31)) | (1 << (ObjCParserDOUBLE - 31)) | (1 << (ObjCParserENUM - 31)) | (1 << (ObjCParserFLOAT - 31)) | (1 << (ObjCParserID - 31)) | (1 << (ObjCParserINT - 31)) | (1 << (ObjCParserLONG - 31)) | (1 << (ObjCParserSHORT - 31)) | (1 << (ObjCParserSIGNED - 31)) | (1 << (ObjCParserSTRUCT - 31)) | (1 << (ObjCParserUNION - 31)) | (1 << (ObjCParserUNSIGNED - 31)) | (1 << (ObjCParserVOID - 31)))) != 0) || _la == ObjCParserNS_OPTIONS || _la == ObjCParserNS_ENUM || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(561)
			p.Type_specifier()
		}

	}
	{
		p.SetState(564)
		p.Match(ObjCParserRPAREN)
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN {
		{
			p.SetState(565)
			p.Block_parameters()
		}

	}



	return localctx
}


// IType_specifierContext is an interface to support dynamic dispatch.
type IType_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifierContext differentiates from other interfaces.
	IsType_specifierContext()
}

type Type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifierContext() *Type_specifierContext {
	var p = new(Type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_type_specifier
	return p
}

func (*Type_specifierContext) IsType_specifierContext() {}

func NewType_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifierContext {
	var p = new(Type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_type_specifier

	return p
}

func (s *Type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifierContext) VOID() antlr.TerminalNode {
	return s.GetToken(ObjCParserVOID, 0)
}

func (s *Type_specifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(ObjCParserCHAR, 0)
}

func (s *Type_specifierContext) SHORT() antlr.TerminalNode {
	return s.GetToken(ObjCParserSHORT, 0)
}

func (s *Type_specifierContext) INT() antlr.TerminalNode {
	return s.GetToken(ObjCParserINT, 0)
}

func (s *Type_specifierContext) LONG() antlr.TerminalNode {
	return s.GetToken(ObjCParserLONG, 0)
}

func (s *Type_specifierContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ObjCParserFLOAT, 0)
}

func (s *Type_specifierContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(ObjCParserDOUBLE, 0)
}

func (s *Type_specifierContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(ObjCParserSIGNED, 0)
}

func (s *Type_specifierContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(ObjCParserUNSIGNED, 0)
}

func (s *Type_specifierContext) ID() antlr.TerminalNode {
	return s.GetToken(ObjCParserID, 0)
}

func (s *Type_specifierContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Type_specifierContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Type_specifierContext) Struct_or_union_specifier() IStruct_or_union_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_or_union_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_or_union_specifierContext)
}

func (s *Type_specifierContext) Enum_specifier() IEnum_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_specifierContext)
}

func (s *Type_specifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Type_specifierContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *Type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterType_specifier(s)
	}
}

func (s *Type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitType_specifier(s)
	}
}




func (p *ObjCParser) Type_specifier() (localctx IType_specifierContext) {
	localctx = NewType_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ObjCParserRULE_type_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(568)
			p.Match(ObjCParserVOID)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(569)
			p.Match(ObjCParserCHAR)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(570)
			p.Match(ObjCParserSHORT)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(571)
			p.Match(ObjCParserINT)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(572)
			p.Match(ObjCParserLONG)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(573)
			p.Match(ObjCParserFLOAT)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(574)
			p.Match(ObjCParserDOUBLE)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(575)
			p.Match(ObjCParserSIGNED)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(576)
			p.Match(ObjCParserUNSIGNED)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(577)
			p.Match(ObjCParserID)
		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserLT {
			{
				p.SetState(578)
				p.Protocol_reference_list()
			}

		}



	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(581)
			p.Class_name()
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserLT {
			{
				p.SetState(582)
				p.Protocol_reference_list()
			}

		}



	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(585)
			p.Struct_or_union_specifier()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(586)
			p.Enum_specifier()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(587)
			p.Match(ObjCParserIDENTIFIER)
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(588)
			p.Match(ObjCParserIDENTIFIER)
		}
		{
			p.SetState(589)
			p.Pointer()
		}

	}


	return localctx
}


// IType_qualifierContext is an interface to support dynamic dispatch.
type IType_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_qualifierContext differentiates from other interfaces.
	IsType_qualifierContext()
}

type Type_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_qualifierContext() *Type_qualifierContext {
	var p = new(Type_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_type_qualifier
	return p
}

func (*Type_qualifierContext) IsType_qualifierContext() {}

func NewType_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_qualifierContext {
	var p = new(Type_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_type_qualifier

	return p
}

func (s *Type_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_qualifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(ObjCParserCONST, 0)
}

func (s *Type_qualifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(ObjCParserVOLATILE, 0)
}

func (s *Type_qualifierContext) Protocol_qualifier() IProtocol_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_qualifierContext)
}

func (s *Type_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterType_qualifier(s)
	}
}

func (s *Type_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitType_qualifier(s)
	}
}




func (p *ObjCParser) Type_qualifier() (localctx IType_qualifierContext) {
	localctx = NewType_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ObjCParserRULE_type_qualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Match(ObjCParserCONST)
		}


	case ObjCParserVOLATILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Match(ObjCParserVOLATILE)
		}


	case ObjCParserBYCOPY, ObjCParserBYREF, ObjCParserIN, ObjCParserINOUT, ObjCParserONEWAY, ObjCParserOUT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(594)
			p.Protocol_qualifier()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IProtocol_qualifierContext is an interface to support dynamic dispatch.
type IProtocol_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_qualifierContext differentiates from other interfaces.
	IsProtocol_qualifierContext()
}

type Protocol_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_qualifierContext() *Protocol_qualifierContext {
	var p = new(Protocol_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_qualifier
	return p
}

func (*Protocol_qualifierContext) IsProtocol_qualifierContext() {}

func NewProtocol_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_qualifierContext {
	var p = new(Protocol_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_qualifier

	return p
}

func (s *Protocol_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_qualifierContext) IN() antlr.TerminalNode {
	return s.GetToken(ObjCParserIN, 0)
}

func (s *Protocol_qualifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(ObjCParserOUT, 0)
}

func (s *Protocol_qualifierContext) INOUT() antlr.TerminalNode {
	return s.GetToken(ObjCParserINOUT, 0)
}

func (s *Protocol_qualifierContext) BYCOPY() antlr.TerminalNode {
	return s.GetToken(ObjCParserBYCOPY, 0)
}

func (s *Protocol_qualifierContext) BYREF() antlr.TerminalNode {
	return s.GetToken(ObjCParserBYREF, 0)
}

func (s *Protocol_qualifierContext) ONEWAY() antlr.TerminalNode {
	return s.GetToken(ObjCParserONEWAY, 0)
}

func (s *Protocol_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_qualifier(s)
	}
}

func (s *Protocol_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_qualifier(s)
	}
}




func (p *ObjCParser) Protocol_qualifier() (localctx IProtocol_qualifierContext) {
	localctx = NewProtocol_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ObjCParserRULE_protocol_qualifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IPrimary_expressionContext is an interface to support dynamic dispatch.
type IPrimary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_expressionContext differentiates from other interfaces.
	IsPrimary_expressionContext()
}

type Primary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_expressionContext() *Primary_expressionContext {
	var p = new(Primary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_primary_expression
	return p
}

func (*Primary_expressionContext) IsPrimary_expressionContext() {}

func NewPrimary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_expressionContext {
	var p = new(Primary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_primary_expression

	return p
}

func (s *Primary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_expressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Primary_expressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Primary_expressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserSTRING_LITERAL, 0)
}

func (s *Primary_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Primary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Primary_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Primary_expressionContext) SELF() antlr.TerminalNode {
	return s.GetToken(ObjCParserSELF, 0)
}

func (s *Primary_expressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUPER, 0)
}

func (s *Primary_expressionContext) Message_expression() IMessage_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessage_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessage_expressionContext)
}

func (s *Primary_expressionContext) Selector_expression() ISelector_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelector_expressionContext)
}

func (s *Primary_expressionContext) Protocol_expression() IProtocol_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_expressionContext)
}

func (s *Primary_expressionContext) Encode_expression() IEncode_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncode_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncode_expressionContext)
}

func (s *Primary_expressionContext) Dictionary_expression() IDictionary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionary_expressionContext)
}

func (s *Primary_expressionContext) Array_expression() IArray_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_expressionContext)
}

func (s *Primary_expressionContext) Box_expression() IBox_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBox_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBox_expressionContext)
}

func (s *Primary_expressionContext) Block_expression() IBlock_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_expressionContext)
}

func (s *Primary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Primary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterPrimary_expression(s)
	}
}

func (s *Primary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitPrimary_expression(s)
	}
}




func (p *ObjCParser) Primary_expression() (localctx IPrimary_expressionContext) {
	localctx = NewPrimary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ObjCParserRULE_primary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(599)
			p.Match(ObjCParserIDENTIFIER)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(600)
			p.Constant()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(601)
			p.Match(ObjCParserSTRING_LITERAL)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(602)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(603)
			p.Expression()
		}
		{
			p.SetState(604)
			p.Match(ObjCParserRPAREN)
		}



	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(606)
			p.Match(ObjCParserSELF)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(607)
			p.Match(ObjCParserSUPER)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(608)
			p.Message_expression()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(609)
			p.Selector_expression()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(610)
			p.Protocol_expression()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(611)
			p.Encode_expression()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(612)
			p.Dictionary_expression()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(613)
			p.Array_expression()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(614)
			p.Box_expression()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(615)
			p.Block_expression()
		}

	}


	return localctx
}


// IDictionary_pairContext is an interface to support dynamic dispatch.
type IDictionary_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionary_pairContext differentiates from other interfaces.
	IsDictionary_pairContext()
}

type Dictionary_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionary_pairContext() *Dictionary_pairContext {
	var p = new(Dictionary_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_dictionary_pair
	return p
}

func (*Dictionary_pairContext) IsDictionary_pairContext() {}

func NewDictionary_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dictionary_pairContext {
	var p = new(Dictionary_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_dictionary_pair

	return p
}

func (s *Dictionary_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Dictionary_pairContext) AllPostfix_expression() []IPostfix_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem())
	var tst = make([]IPostfix_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfix_expressionContext)
		}
	}

	return tst
}

func (s *Dictionary_pairContext) Postfix_expression(i int) IPostfix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfix_expressionContext)
}

func (s *Dictionary_pairContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Dictionary_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dictionary_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dictionary_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDictionary_pair(s)
	}
}

func (s *Dictionary_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDictionary_pair(s)
	}
}




func (p *ObjCParser) Dictionary_pair() (localctx IDictionary_pairContext) {
	localctx = NewDictionary_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ObjCParserRULE_dictionary_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Postfix_expression()
	}
	{
		p.SetState(619)
		p.Match(ObjCParserCOLON)
	}
	{
		p.SetState(620)
		p.Postfix_expression()
	}



	return localctx
}


// IDictionary_expressionContext is an interface to support dynamic dispatch.
type IDictionary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionary_expressionContext differentiates from other interfaces.
	IsDictionary_expressionContext()
}

type Dictionary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionary_expressionContext() *Dictionary_expressionContext {
	var p = new(Dictionary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_dictionary_expression
	return p
}

func (*Dictionary_expressionContext) IsDictionary_expressionContext() {}

func NewDictionary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dictionary_expressionContext {
	var p = new(Dictionary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_dictionary_expression

	return p
}

func (s *Dictionary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Dictionary_expressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjCParserAT, 0)
}

func (s *Dictionary_expressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *Dictionary_expressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *Dictionary_expressionContext) AllDictionary_pair() []IDictionary_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDictionary_pairContext)(nil)).Elem())
	var tst = make([]IDictionary_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDictionary_pairContext)
		}
	}

	return tst
}

func (s *Dictionary_expressionContext) Dictionary_pair(i int) IDictionary_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionary_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDictionary_pairContext)
}

func (s *Dictionary_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Dictionary_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Dictionary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dictionary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dictionary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDictionary_expression(s)
	}
}

func (s *Dictionary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDictionary_expression(s)
	}
}




func (p *ObjCParser) Dictionary_expression() (localctx IDictionary_expressionContext) {
	localctx = NewDictionary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ObjCParserRULE_dictionary_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(ObjCParserAT)
	}
	{
		p.SetState(623)
		p.Match(ObjCParserLBRACE)
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 69)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 69))) & ((1 << (ObjCParserLPAREN - 69)) | (1 << (ObjCParserLBRACK - 69)) | (1 << (ObjCParserAT - 69)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjCParserCARET - 101)) | (1 << (ObjCParserIDENTIFIER - 101)) | (1 << (ObjCParserCHARACTER_LITERAL - 101)) | (1 << (ObjCParserSTRING_LITERAL - 101)) | (1 << (ObjCParserHEX_LITERAL - 101)) | (1 << (ObjCParserDECIMAL_LITERAL - 101)) | (1 << (ObjCParserOCTAL_LITERAL - 101)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
		{
			p.SetState(624)
			p.Dictionary_pair()
		}

	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(627)
				p.Match(ObjCParserCOMMA)
			}
			{
				p.SetState(628)
				p.Dictionary_pair()
			}


		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOMMA {
		{
			p.SetState(634)
			p.Match(ObjCParserCOMMA)
		}

	}
	{
		p.SetState(637)
		p.Match(ObjCParserRBRACE)
	}



	return localctx
}


// IArray_expressionContext is an interface to support dynamic dispatch.
type IArray_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_expressionContext differentiates from other interfaces.
	IsArray_expressionContext()
}

type Array_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_expressionContext() *Array_expressionContext {
	var p = new(Array_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_array_expression
	return p
}

func (*Array_expressionContext) IsArray_expressionContext() {}

func NewArray_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_expressionContext {
	var p = new(Array_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_array_expression

	return p
}

func (s *Array_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_expressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjCParserAT, 0)
}

func (s *Array_expressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, 0)
}

func (s *Array_expressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, 0)
}

func (s *Array_expressionContext) AllPostfix_expression() []IPostfix_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem())
	var tst = make([]IPostfix_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfix_expressionContext)
		}
	}

	return tst
}

func (s *Array_expressionContext) Postfix_expression(i int) IPostfix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfix_expressionContext)
}

func (s *Array_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Array_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Array_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Array_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterArray_expression(s)
	}
}

func (s *Array_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitArray_expression(s)
	}
}




func (p *ObjCParser) Array_expression() (localctx IArray_expressionContext) {
	localctx = NewArray_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ObjCParserRULE_array_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(ObjCParserAT)
	}
	{
		p.SetState(640)
		p.Match(ObjCParserLBRACK)
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 69)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 69))) & ((1 << (ObjCParserLPAREN - 69)) | (1 << (ObjCParserLBRACK - 69)) | (1 << (ObjCParserAT - 69)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjCParserCARET - 101)) | (1 << (ObjCParserIDENTIFIER - 101)) | (1 << (ObjCParserCHARACTER_LITERAL - 101)) | (1 << (ObjCParserSTRING_LITERAL - 101)) | (1 << (ObjCParserHEX_LITERAL - 101)) | (1 << (ObjCParserDECIMAL_LITERAL - 101)) | (1 << (ObjCParserOCTAL_LITERAL - 101)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
		{
			p.SetState(641)
			p.Postfix_expression()
		}

	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(644)
				p.Match(ObjCParserCOMMA)
			}
			{
				p.SetState(645)
				p.Postfix_expression()
			}


		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOMMA {
		{
			p.SetState(651)
			p.Match(ObjCParserCOMMA)
		}

	}
	{
		p.SetState(654)
		p.Match(ObjCParserRBRACK)
	}



	return localctx
}


// IBox_expressionContext is an interface to support dynamic dispatch.
type IBox_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBox_expressionContext differentiates from other interfaces.
	IsBox_expressionContext()
}

type Box_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBox_expressionContext() *Box_expressionContext {
	var p = new(Box_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_box_expression
	return p
}

func (*Box_expressionContext) IsBox_expressionContext() {}

func NewBox_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Box_expressionContext {
	var p = new(Box_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_box_expression

	return p
}

func (s *Box_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Box_expressionContext) AT() antlr.TerminalNode {
	return s.GetToken(ObjCParserAT, 0)
}

func (s *Box_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Box_expressionContext) Postfix_expression() IPostfix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfix_expressionContext)
}

func (s *Box_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Box_expressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Box_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Box_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Box_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterBox_expression(s)
	}
}

func (s *Box_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitBox_expression(s)
	}
}




func (p *ObjCParser) Box_expression() (localctx IBox_expressionContext) {
	localctx = NewBox_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ObjCParserRULE_box_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(656)
			p.Match(ObjCParserAT)
		}
		{
			p.SetState(657)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(658)
			p.Postfix_expression()
		}
		{
			p.SetState(659)
			p.Match(ObjCParserRPAREN)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(661)
			p.Match(ObjCParserAT)
		}
		{
			p.SetState(662)
			p.Constant()
		}

	}


	return localctx
}


// IBlock_parametersContext is an interface to support dynamic dispatch.
type IBlock_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_parametersContext differentiates from other interfaces.
	IsBlock_parametersContext()
}

type Block_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_parametersContext() *Block_parametersContext {
	var p = new(Block_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_block_parameters
	return p
}

func (*Block_parametersContext) IsBlock_parametersContext() {}

func NewBlock_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_parametersContext {
	var p = new(Block_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_block_parameters

	return p
}

func (s *Block_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_parametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Block_parametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Block_parametersContext) AllType_variable_declarator() []IType_variable_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_variable_declaratorContext)(nil)).Elem())
	var tst = make([]IType_variable_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_variable_declaratorContext)
		}
	}

	return tst
}

func (s *Block_parametersContext) Type_variable_declarator(i int) IType_variable_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_variable_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_variable_declaratorContext)
}

func (s *Block_parametersContext) VOID() antlr.TerminalNode {
	return s.GetToken(ObjCParserVOID, 0)
}

func (s *Block_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Block_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Block_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Block_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterBlock_parameters(s)
	}
}

func (s *Block_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitBlock_parameters(s)
	}
}




func (p *ObjCParser) Block_parameters() (localctx IBlock_parametersContext) {
	localctx = NewBlock_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ObjCParserRULE_block_parameters)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(ObjCParserLPAREN)
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(666)
			p.Type_variable_declarator()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(667)
			p.Match(ObjCParserVOID)
		}


	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(670)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(671)
			p.Type_variable_declarator()
		}


		p.SetState(676)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(677)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// IBlock_expressionContext is an interface to support dynamic dispatch.
type IBlock_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_expressionContext differentiates from other interfaces.
	IsBlock_expressionContext()
}

type Block_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_expressionContext() *Block_expressionContext {
	var p = new(Block_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_block_expression
	return p
}

func (*Block_expressionContext) IsBlock_expressionContext() {}

func NewBlock_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_expressionContext {
	var p = new(Block_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_block_expression

	return p
}

func (s *Block_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_expressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(ObjCParserCARET, 0)
}

func (s *Block_expressionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Block_expressionContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Block_expressionContext) Block_parameters() IBlock_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_parametersContext)
}

func (s *Block_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Block_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterBlock_expression(s)
	}
}

func (s *Block_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitBlock_expression(s)
	}
}




func (p *ObjCParser) Block_expression() (localctx IBlock_expressionContext) {
	localctx = NewBlock_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ObjCParserRULE_block_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(ObjCParserCARET)
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 31)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 31))) & ((1 << (ObjCParserCHAR - 31)) | (1 << (ObjCParserDOUBLE - 31)) | (1 << (ObjCParserENUM - 31)) | (1 << (ObjCParserFLOAT - 31)) | (1 << (ObjCParserID - 31)) | (1 << (ObjCParserINT - 31)) | (1 << (ObjCParserLONG - 31)) | (1 << (ObjCParserSHORT - 31)) | (1 << (ObjCParserSIGNED - 31)) | (1 << (ObjCParserSTRUCT - 31)) | (1 << (ObjCParserUNION - 31)) | (1 << (ObjCParserUNSIGNED - 31)) | (1 << (ObjCParserVOID - 31)))) != 0) || _la == ObjCParserNS_OPTIONS || _la == ObjCParserNS_ENUM || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(680)
			p.Type_specifier()
		}

	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN {
		{
			p.SetState(683)
			p.Block_parameters()
		}

	}
	{
		p.SetState(686)
		p.Compound_statement()
	}



	return localctx
}


// IMessage_expressionContext is an interface to support dynamic dispatch.
type IMessage_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessage_expressionContext differentiates from other interfaces.
	IsMessage_expressionContext()
}

type Message_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessage_expressionContext() *Message_expressionContext {
	var p = new(Message_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_message_expression
	return p
}

func (*Message_expressionContext) IsMessage_expressionContext() {}

func NewMessage_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Message_expressionContext {
	var p = new(Message_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_message_expression

	return p
}

func (s *Message_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Message_expressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, 0)
}

func (s *Message_expressionContext) Receiver() IReceiverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverContext)
}

func (s *Message_expressionContext) Message_selector() IMessage_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessage_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessage_selectorContext)
}

func (s *Message_expressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, 0)
}

func (s *Message_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Message_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Message_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMessage_expression(s)
	}
}

func (s *Message_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMessage_expression(s)
	}
}




func (p *ObjCParser) Message_expression() (localctx IMessage_expressionContext) {
	localctx = NewMessage_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ObjCParserRULE_message_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(ObjCParserLBRACK)
	}
	{
		p.SetState(689)
		p.Receiver()
	}
	{
		p.SetState(690)
		p.Message_selector()
	}
	{
		p.SetState(691)
		p.Match(ObjCParserRBRACK)
	}



	return localctx
}


// IReceiverContext is an interface to support dynamic dispatch.
type IReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverContext differentiates from other interfaces.
	IsReceiverContext()
}

type ReceiverContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverContext() *ReceiverContext {
	var p = new(ReceiverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_receiver
	return p
}

func (*ReceiverContext) IsReceiverContext() {}

func NewReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverContext {
	var p = new(ReceiverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_receiver

	return p
}

func (s *ReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReceiverContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *ReceiverContext) SUPER() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUPER, 0)
}

func (s *ReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterReceiver(s)
	}
}

func (s *ReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitReceiver(s)
	}
}




func (p *ObjCParser) Receiver() (localctx IReceiverContext) {
	localctx = NewReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ObjCParserRULE_receiver)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)
			p.Expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.Class_name()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(695)
			p.Match(ObjCParserSUPER)
		}

	}


	return localctx
}


// IMessage_selectorContext is an interface to support dynamic dispatch.
type IMessage_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessage_selectorContext differentiates from other interfaces.
	IsMessage_selectorContext()
}

type Message_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessage_selectorContext() *Message_selectorContext {
	var p = new(Message_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_message_selector
	return p
}

func (*Message_selectorContext) IsMessage_selectorContext() {}

func NewMessage_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Message_selectorContext {
	var p = new(Message_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_message_selector

	return p
}

func (s *Message_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Message_selectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Message_selectorContext) AllKeyword_argument() []IKeyword_argumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyword_argumentContext)(nil)).Elem())
	var tst = make([]IKeyword_argumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyword_argumentContext)
		}
	}

	return tst
}

func (s *Message_selectorContext) Keyword_argument(i int) IKeyword_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyword_argumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyword_argumentContext)
}

func (s *Message_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Message_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Message_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMessage_selector(s)
	}
}

func (s *Message_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMessage_selector(s)
	}
}




func (p *ObjCParser) Message_selector() (localctx IMessage_selectorContext) {
	localctx = NewMessage_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ObjCParserRULE_message_selector)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjCParserCOLON || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(699)
				p.Keyword_argument()
			}


			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}


	return localctx
}


// IKeyword_argumentContext is an interface to support dynamic dispatch.
type IKeyword_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyword_argumentContext differentiates from other interfaces.
	IsKeyword_argumentContext()
}

type Keyword_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_argumentContext() *Keyword_argumentContext {
	var p = new(Keyword_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_keyword_argument
	return p
}

func (*Keyword_argumentContext) IsKeyword_argumentContext() {}

func NewKeyword_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_argumentContext {
	var p = new(Keyword_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_keyword_argument

	return p
}

func (s *Keyword_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_argumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Keyword_argumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Keyword_argumentContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Keyword_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterKeyword_argument(s)
	}
}

func (s *Keyword_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitKeyword_argument(s)
	}
}




func (p *ObjCParser) Keyword_argument() (localctx IKeyword_argumentContext) {
	localctx = NewKeyword_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ObjCParserRULE_keyword_argument)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserIDENTIFIER {
		{
			p.SetState(706)
			p.Selector()
		}

	}
	{
		p.SetState(709)
		p.Match(ObjCParserCOLON)
	}
	{
		p.SetState(710)
		p.Expression()
	}



	return localctx
}


// ISelector_expressionContext is an interface to support dynamic dispatch.
type ISelector_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_expressionContext differentiates from other interfaces.
	IsSelector_expressionContext()
}

type Selector_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_expressionContext() *Selector_expressionContext {
	var p = new(Selector_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_selector_expression
	return p
}

func (*Selector_expressionContext) IsSelector_expressionContext() {}

func NewSelector_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_expressionContext {
	var p = new(Selector_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_selector_expression

	return p
}

func (s *Selector_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_expressionContext) SELECTOR() antlr.TerminalNode {
	return s.GetToken(ObjCParserSELECTOR, 0)
}

func (s *Selector_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Selector_expressionContext) Selector_name() ISelector_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelector_nameContext)
}

func (s *Selector_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Selector_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selector_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSelector_expression(s)
	}
}

func (s *Selector_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSelector_expression(s)
	}
}




func (p *ObjCParser) Selector_expression() (localctx ISelector_expressionContext) {
	localctx = NewSelector_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ObjCParserRULE_selector_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(ObjCParserSELECTOR)
	}
	{
		p.SetState(713)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(714)
		p.Selector_name()
	}
	{
		p.SetState(715)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// ISelector_nameContext is an interface to support dynamic dispatch.
type ISelector_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_nameContext differentiates from other interfaces.
	IsSelector_nameContext()
}

type Selector_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_nameContext() *Selector_nameContext {
	var p = new(Selector_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_selector_name
	return p
}

func (*Selector_nameContext) IsSelector_nameContext() {}

func NewSelector_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_nameContext {
	var p = new(Selector_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_selector_name

	return p
}

func (s *Selector_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_nameContext) AllSelector() []ISelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectorContext)(nil)).Elem())
	var tst = make([]ISelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectorContext)
		}
	}

	return tst
}

func (s *Selector_nameContext) Selector(i int) ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Selector_nameContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOLON)
}

func (s *Selector_nameContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, i)
}

func (s *Selector_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selector_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSelector_name(s)
	}
}

func (s *Selector_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSelector_name(s)
	}
}




func (p *ObjCParser) Selector_name() (localctx ISelector_nameContext) {
	localctx = NewSelector_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ObjCParserRULE_selector_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjCParserCOLON || _la == ObjCParserIDENTIFIER {
			p.SetState(719)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ObjCParserIDENTIFIER {
				{
					p.SetState(718)
					p.Selector()
				}

			}
			{
				p.SetState(721)
				p.Match(ObjCParserCOLON)
			}


			p.SetState(724)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}


	return localctx
}


// IProtocol_expressionContext is an interface to support dynamic dispatch.
type IProtocol_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_expressionContext differentiates from other interfaces.
	IsProtocol_expressionContext()
}

type Protocol_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_expressionContext() *Protocol_expressionContext {
	var p = new(Protocol_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_protocol_expression
	return p
}

func (*Protocol_expressionContext) IsProtocol_expressionContext() {}

func NewProtocol_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_expressionContext {
	var p = new(Protocol_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_protocol_expression

	return p
}

func (s *Protocol_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_expressionContext) PROTOCOL() antlr.TerminalNode {
	return s.GetToken(ObjCParserPROTOCOL, 0)
}

func (s *Protocol_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Protocol_expressionContext) Protocol_name() IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Protocol_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterProtocol_expression(s)
	}
}

func (s *Protocol_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitProtocol_expression(s)
	}
}




func (p *ObjCParser) Protocol_expression() (localctx IProtocol_expressionContext) {
	localctx = NewProtocol_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ObjCParserRULE_protocol_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(ObjCParserPROTOCOL)
	}
	{
		p.SetState(729)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(730)
		p.Protocol_name()
	}
	{
		p.SetState(731)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// IEncode_expressionContext is an interface to support dynamic dispatch.
type IEncode_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncode_expressionContext differentiates from other interfaces.
	IsEncode_expressionContext()
}

type Encode_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncode_expressionContext() *Encode_expressionContext {
	var p = new(Encode_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_encode_expression
	return p
}

func (*Encode_expressionContext) IsEncode_expressionContext() {}

func NewEncode_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encode_expressionContext {
	var p = new(Encode_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_encode_expression

	return p
}

func (s *Encode_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Encode_expressionContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(ObjCParserENCODE, 0)
}

func (s *Encode_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Encode_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Encode_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Encode_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encode_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Encode_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterEncode_expression(s)
	}
}

func (s *Encode_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitEncode_expression(s)
	}
}




func (p *ObjCParser) Encode_expression() (localctx IEncode_expressionContext) {
	localctx = NewEncode_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ObjCParserRULE_encode_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.Match(ObjCParserENCODE)
	}
	{
		p.SetState(734)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(735)
		p.Type_name()
	}
	{
		p.SetState(736)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// IType_variable_declaratorContext is an interface to support dynamic dispatch.
type IType_variable_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_variable_declaratorContext differentiates from other interfaces.
	IsType_variable_declaratorContext()
}

type Type_variable_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_variable_declaratorContext() *Type_variable_declaratorContext {
	var p = new(Type_variable_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_type_variable_declarator
	return p
}

func (*Type_variable_declaratorContext) IsType_variable_declaratorContext() {}

func NewType_variable_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_variable_declaratorContext {
	var p = new(Type_variable_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_type_variable_declarator

	return p
}

func (s *Type_variable_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_variable_declaratorContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *Type_variable_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Type_variable_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_variable_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_variable_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterType_variable_declarator(s)
	}
}

func (s *Type_variable_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitType_variable_declarator(s)
	}
}




func (p *ObjCParser) Type_variable_declarator() (localctx IType_variable_declaratorContext) {
	localctx = NewType_variable_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ObjCParserRULE_type_variable_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Declaration_specifiers()
	}
	{
		p.SetState(739)
		p.Declarator()
	}



	return localctx
}


// ITry_statementContext is an interface to support dynamic dispatch.
type ITry_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_statementContext differentiates from other interfaces.
	IsTry_statementContext()
}

type Try_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_statementContext() *Try_statementContext {
	var p = new(Try_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_try_statement
	return p
}

func (*Try_statementContext) IsTry_statementContext() {}

func NewTry_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_statementContext {
	var p = new(Try_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_try_statement

	return p
}

func (s *Try_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_statementContext) TRY() antlr.TerminalNode {
	return s.GetToken(ObjCParserTRY, 0)
}

func (s *Try_statementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Try_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterTry_statement(s)
	}
}

func (s *Try_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitTry_statement(s)
	}
}




func (p *ObjCParser) Try_statement() (localctx ITry_statementContext) {
	localctx = NewTry_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ObjCParserRULE_try_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Match(ObjCParserTRY)
	}
	{
		p.SetState(742)
		p.Compound_statement()
	}



	return localctx
}


// ICatch_statementContext is an interface to support dynamic dispatch.
type ICatch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatch_statementContext differentiates from other interfaces.
	IsCatch_statementContext()
}

type Catch_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatch_statementContext() *Catch_statementContext {
	var p = new(Catch_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_catch_statement
	return p
}

func (*Catch_statementContext) IsCatch_statementContext() {}

func NewCatch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Catch_statementContext {
	var p = new(Catch_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_catch_statement

	return p
}

func (s *Catch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Catch_statementContext) CATCH() antlr.TerminalNode {
	return s.GetToken(ObjCParserCATCH, 0)
}

func (s *Catch_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Catch_statementContext) Type_variable_declarator() IType_variable_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_variable_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_variable_declaratorContext)
}

func (s *Catch_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Catch_statementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Catch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Catch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Catch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCatch_statement(s)
	}
}

func (s *Catch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCatch_statement(s)
	}
}




func (p *ObjCParser) Catch_statement() (localctx ICatch_statementContext) {
	localctx = NewCatch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ObjCParserRULE_catch_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(ObjCParserCATCH)
	}
	{
		p.SetState(745)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(746)
		p.Type_variable_declarator()
	}
	{
		p.SetState(747)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(748)
		p.Compound_statement()
	}



	return localctx
}


// IFinally_statementContext is an interface to support dynamic dispatch.
type IFinally_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinally_statementContext differentiates from other interfaces.
	IsFinally_statementContext()
}

type Finally_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_statementContext() *Finally_statementContext {
	var p = new(Finally_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_finally_statement
	return p
}

func (*Finally_statementContext) IsFinally_statementContext() {}

func NewFinally_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_statementContext {
	var p = new(Finally_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_finally_statement

	return p
}

func (s *Finally_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Finally_statementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(ObjCParserFINALLY, 0)
}

func (s *Finally_statementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Finally_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Finally_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterFinally_statement(s)
	}
}

func (s *Finally_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitFinally_statement(s)
	}
}




func (p *ObjCParser) Finally_statement() (localctx IFinally_statementContext) {
	localctx = NewFinally_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ObjCParserRULE_finally_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(ObjCParserFINALLY)
	}
	{
		p.SetState(751)
		p.Compound_statement()
	}



	return localctx
}


// IThrow_statementContext is an interface to support dynamic dispatch.
type IThrow_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_statementContext differentiates from other interfaces.
	IsThrow_statementContext()
}

type Throw_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_statementContext() *Throw_statementContext {
	var p = new(Throw_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_throw_statement
	return p
}

func (*Throw_statementContext) IsThrow_statementContext() {}

func NewThrow_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_statementContext {
	var p = new(Throw_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_throw_statement

	return p
}

func (s *Throw_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_statementContext) THROW() antlr.TerminalNode {
	return s.GetToken(ObjCParserTHROW, 0)
}

func (s *Throw_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Throw_statementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Throw_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Throw_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Throw_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterThrow_statement(s)
	}
}

func (s *Throw_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitThrow_statement(s)
	}
}




func (p *ObjCParser) Throw_statement() (localctx IThrow_statementContext) {
	localctx = NewThrow_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ObjCParserRULE_throw_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(ObjCParserTHROW)
	}
	{
		p.SetState(754)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(755)
		p.Match(ObjCParserIDENTIFIER)
	}
	{
		p.SetState(756)
		p.Match(ObjCParserRPAREN)
	}



	return localctx
}


// ITry_blockContext is an interface to support dynamic dispatch.
type ITry_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_blockContext differentiates from other interfaces.
	IsTry_blockContext()
}

type Try_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_blockContext() *Try_blockContext {
	var p = new(Try_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_try_block
	return p
}

func (*Try_blockContext) IsTry_blockContext() {}

func NewTry_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_blockContext {
	var p = new(Try_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_try_block

	return p
}

func (s *Try_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_blockContext) Try_statement() ITry_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_statementContext)
}

func (s *Try_blockContext) AllCatch_statement() []ICatch_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatch_statementContext)(nil)).Elem())
	var tst = make([]ICatch_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatch_statementContext)
		}
	}

	return tst
}

func (s *Try_blockContext) Catch_statement(i int) ICatch_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatch_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatch_statementContext)
}

func (s *Try_blockContext) Finally_statement() IFinally_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinally_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinally_statementContext)
}

func (s *Try_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterTry_block(s)
	}
}

func (s *Try_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitTry_block(s)
	}
}




func (p *ObjCParser) Try_block() (localctx ITry_blockContext) {
	localctx = NewTry_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ObjCParserRULE_try_block)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Try_statement()
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCATCH {
		{
			p.SetState(759)
			p.Catch_statement()
		}


		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserFINALLY {
		{
			p.SetState(765)
			p.Finally_statement()
		}

	}



	return localctx
}


// ISynchronized_statementContext is an interface to support dynamic dispatch.
type ISynchronized_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSynchronized_statementContext differentiates from other interfaces.
	IsSynchronized_statementContext()
}

type Synchronized_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynchronized_statementContext() *Synchronized_statementContext {
	var p = new(Synchronized_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_synchronized_statement
	return p
}

func (*Synchronized_statementContext) IsSynchronized_statementContext() {}

func NewSynchronized_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Synchronized_statementContext {
	var p = new(Synchronized_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_synchronized_statement

	return p
}

func (s *Synchronized_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Synchronized_statementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(ObjCParserSYNCHRONIZED, 0)
}

func (s *Synchronized_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Synchronized_statementContext) Primary_expression() IPrimary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_expressionContext)
}

func (s *Synchronized_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Synchronized_statementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Synchronized_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Synchronized_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Synchronized_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSynchronized_statement(s)
	}
}

func (s *Synchronized_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSynchronized_statement(s)
	}
}




func (p *ObjCParser) Synchronized_statement() (localctx ISynchronized_statementContext) {
	localctx = NewSynchronized_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ObjCParserRULE_synchronized_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(ObjCParserSYNCHRONIZED)
	}
	{
		p.SetState(769)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(770)
		p.Primary_expression()
	}
	{
		p.SetState(771)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(772)
		p.Compound_statement()
	}



	return localctx
}


// IAutorelease_statementContext is an interface to support dynamic dispatch.
type IAutorelease_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAutorelease_statementContext differentiates from other interfaces.
	IsAutorelease_statementContext()
}

type Autorelease_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAutorelease_statementContext() *Autorelease_statementContext {
	var p = new(Autorelease_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_autorelease_statement
	return p
}

func (*Autorelease_statementContext) IsAutorelease_statementContext() {}

func NewAutorelease_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Autorelease_statementContext {
	var p = new(Autorelease_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_autorelease_statement

	return p
}

func (s *Autorelease_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Autorelease_statementContext) AUTORELEASEPOOL() antlr.TerminalNode {
	return s.GetToken(ObjCParserAUTORELEASEPOOL, 0)
}

func (s *Autorelease_statementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Autorelease_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Autorelease_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Autorelease_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAutorelease_statement(s)
	}
}

func (s *Autorelease_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAutorelease_statement(s)
	}
}




func (p *ObjCParser) Autorelease_statement() (localctx IAutorelease_statementContext) {
	localctx = NewAutorelease_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ObjCParserRULE_autorelease_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(ObjCParserAUTORELEASEPOOL)
	}
	{
		p.SetState(775)
		p.Compound_statement()
	}



	return localctx
}


// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Function_definitionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Function_definitionContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}




func (p *ObjCParser) Function_definition() (localctx IFunction_definitionContext) {
	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ObjCParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(777)
			p.Declaration_specifiers()
		}


	}
	{
		p.SetState(780)
		p.Declarator()
	}
	{
		p.SetState(781)
		p.Compound_statement()
	}



	return localctx
}


// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *DeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *DeclarationContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDeclaration(s)
	}
}




func (p *ObjCParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ObjCParserRULE_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Declaration_specifiers()
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserLPAREN || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
		{
			p.SetState(784)
			p.Init_declarator_list()
		}

	}
	{
		p.SetState(787)
		p.Match(ObjCParserSEMI)
	}



	return localctx
}


// IDeclaration_specifiersContext is an interface to support dynamic dispatch.
type IDeclaration_specifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_specifiersContext differentiates from other interfaces.
	IsDeclaration_specifiersContext()
}

type Declaration_specifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_specifiersContext() *Declaration_specifiersContext {
	var p = new(Declaration_specifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_declaration_specifiers
	return p
}

func (*Declaration_specifiersContext) IsDeclaration_specifiersContext() {}

func NewDeclaration_specifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_specifiersContext {
	var p = new(Declaration_specifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_declaration_specifiers

	return p
}

func (s *Declaration_specifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_specifiersContext) AllArc_behaviour_specifier() []IArc_behaviour_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArc_behaviour_specifierContext)(nil)).Elem())
	var tst = make([]IArc_behaviour_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArc_behaviour_specifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Arc_behaviour_specifier(i int) IArc_behaviour_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArc_behaviour_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArc_behaviour_specifierContext)
}

func (s *Declaration_specifiersContext) AllStorage_class_specifier() []IStorage_class_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStorage_class_specifierContext)(nil)).Elem())
	var tst = make([]IStorage_class_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStorage_class_specifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Storage_class_specifier(i int) IStorage_class_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStorage_class_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStorage_class_specifierContext)
}

func (s *Declaration_specifiersContext) AllType_specifier() []IType_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specifierContext)(nil)).Elem())
	var tst = make([]IType_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Type_specifier(i int) IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Declaration_specifiersContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *Declaration_specifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_specifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declaration_specifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDeclaration_specifiers(s)
	}
}

func (s *Declaration_specifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDeclaration_specifiers(s)
	}
}




func (p *ObjCParser) Declaration_specifiers() (localctx IDeclaration_specifiersContext) {
	localctx = NewDeclaration_specifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ObjCParserRULE_declaration_specifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(793)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjCParserWWEAK, ObjCParserWUNSAFE_UNRETAINED:
					{
						p.SetState(789)
						p.Arc_behaviour_specifier()
					}


				case ObjCParserAUTO, ObjCParserEXTERN, ObjCParserREGISTER, ObjCParserSTATIC, ObjCParserTYPEDEF:
					{
						p.SetState(790)
						p.Storage_class_specifier()
					}


				case ObjCParserCHAR, ObjCParserDOUBLE, ObjCParserENUM, ObjCParserFLOAT, ObjCParserID, ObjCParserINT, ObjCParserLONG, ObjCParserSHORT, ObjCParserSIGNED, ObjCParserSTRUCT, ObjCParserUNION, ObjCParserUNSIGNED, ObjCParserVOID, ObjCParserNS_OPTIONS, ObjCParserNS_ENUM, ObjCParserIDENTIFIER:
					{
						p.SetState(791)
						p.Type_specifier()
					}


				case ObjCParserBYCOPY, ObjCParserBYREF, ObjCParserCONST, ObjCParserIN, ObjCParserINOUT, ObjCParserONEWAY, ObjCParserOUT, ObjCParserVOLATILE:
					{
						p.SetState(792)
						p.Type_qualifier()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())
	}



	return localctx
}


// IArc_behaviour_specifierContext is an interface to support dynamic dispatch.
type IArc_behaviour_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArc_behaviour_specifierContext differentiates from other interfaces.
	IsArc_behaviour_specifierContext()
}

type Arc_behaviour_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArc_behaviour_specifierContext() *Arc_behaviour_specifierContext {
	var p = new(Arc_behaviour_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_arc_behaviour_specifier
	return p
}

func (*Arc_behaviour_specifierContext) IsArc_behaviour_specifierContext() {}

func NewArc_behaviour_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arc_behaviour_specifierContext {
	var p = new(Arc_behaviour_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_arc_behaviour_specifier

	return p
}

func (s *Arc_behaviour_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Arc_behaviour_specifierContext) WUNSAFE_UNRETAINED() antlr.TerminalNode {
	return s.GetToken(ObjCParserWUNSAFE_UNRETAINED, 0)
}

func (s *Arc_behaviour_specifierContext) WWEAK() antlr.TerminalNode {
	return s.GetToken(ObjCParserWWEAK, 0)
}

func (s *Arc_behaviour_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arc_behaviour_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Arc_behaviour_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterArc_behaviour_specifier(s)
	}
}

func (s *Arc_behaviour_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitArc_behaviour_specifier(s)
	}
}




func (p *ObjCParser) Arc_behaviour_specifier() (localctx IArc_behaviour_specifierContext) {
	localctx = NewArc_behaviour_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ObjCParserRULE_arc_behaviour_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjCParserWWEAK || _la == ObjCParserWUNSAFE_UNRETAINED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IStorage_class_specifierContext is an interface to support dynamic dispatch.
type IStorage_class_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorage_class_specifierContext differentiates from other interfaces.
	IsStorage_class_specifierContext()
}

type Storage_class_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorage_class_specifierContext() *Storage_class_specifierContext {
	var p = new(Storage_class_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_storage_class_specifier
	return p
}

func (*Storage_class_specifierContext) IsStorage_class_specifierContext() {}

func NewStorage_class_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Storage_class_specifierContext {
	var p = new(Storage_class_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_storage_class_specifier

	return p
}

func (s *Storage_class_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Storage_class_specifierContext) AUTO() antlr.TerminalNode {
	return s.GetToken(ObjCParserAUTO, 0)
}

func (s *Storage_class_specifierContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(ObjCParserREGISTER, 0)
}

func (s *Storage_class_specifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(ObjCParserSTATIC, 0)
}

func (s *Storage_class_specifierContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ObjCParserEXTERN, 0)
}

func (s *Storage_class_specifierContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(ObjCParserTYPEDEF, 0)
}

func (s *Storage_class_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Storage_class_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Storage_class_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStorage_class_specifier(s)
	}
}

func (s *Storage_class_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStorage_class_specifier(s)
	}
}




func (p *ObjCParser) Storage_class_specifier() (localctx IStorage_class_specifierContext) {
	localctx = NewStorage_class_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ObjCParserRULE_storage_class_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjCParserAUTO || ((((_la - 39)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 39))) & ((1 << (ObjCParserEXTERN - 39)) | (1 << (ObjCParserREGISTER - 39)) | (1 << (ObjCParserSTATIC - 39)) | (1 << (ObjCParserTYPEDEF - 39)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IInit_declarator_listContext is an interface to support dynamic dispatch.
type IInit_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declarator_listContext differentiates from other interfaces.
	IsInit_declarator_listContext()
}

type Init_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declarator_listContext() *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_init_declarator_list
	return p
}

func (*Init_declarator_listContext) IsInit_declarator_listContext() {}

func NewInit_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_init_declarator_list

	return p
}

func (s *Init_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declarator_listContext) AllInit_declarator() []IInit_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem())
	var tst = make([]IInit_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInit_declaratorContext)
		}
	}

	return tst
}

func (s *Init_declarator_listContext) Init_declarator(i int) IInit_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInit_declaratorContext)
}

func (s *Init_declarator_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Init_declarator_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Init_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Init_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInit_declarator_list(s)
	}
}

func (s *Init_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInit_declarator_list(s)
	}
}




func (p *ObjCParser) Init_declarator_list() (localctx IInit_declarator_listContext) {
	localctx = NewInit_declarator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ObjCParserRULE_init_declarator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Init_declarator()
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(802)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(803)
			p.Init_declarator()
		}


		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IInit_declaratorContext is an interface to support dynamic dispatch.
type IInit_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declaratorContext differentiates from other interfaces.
	IsInit_declaratorContext()
}

type Init_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declaratorContext() *Init_declaratorContext {
	var p = new(Init_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_init_declarator
	return p
}

func (*Init_declaratorContext) IsInit_declaratorContext() {}

func NewInit_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declaratorContext {
	var p = new(Init_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_init_declarator

	return p
}

func (s *Init_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Init_declaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGN, 0)
}

func (s *Init_declaratorContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *Init_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Init_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInit_declarator(s)
	}
}

func (s *Init_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInit_declarator(s)
	}
}




func (p *ObjCParser) Init_declarator() (localctx IInit_declaratorContext) {
	localctx = NewInit_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ObjCParserRULE_init_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Declarator()
	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserASSIGN {
		{
			p.SetState(810)
			p.Match(ObjCParserASSIGN)
		}
		{
			p.SetState(811)
			p.Initializer()
		}

	}



	return localctx
}


// IStruct_or_union_specifierContext is an interface to support dynamic dispatch.
type IStruct_or_union_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_or_union_specifierContext differentiates from other interfaces.
	IsStruct_or_union_specifierContext()
}

type Struct_or_union_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_or_union_specifierContext() *Struct_or_union_specifierContext {
	var p = new(Struct_or_union_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_struct_or_union_specifier
	return p
}

func (*Struct_or_union_specifierContext) IsStruct_or_union_specifierContext() {}

func NewStruct_or_union_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_or_union_specifierContext {
	var p = new(Struct_or_union_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_struct_or_union_specifier

	return p
}

func (s *Struct_or_union_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_or_union_specifierContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(ObjCParserSTRUCT, 0)
}

func (s *Struct_or_union_specifierContext) UNION() antlr.TerminalNode {
	return s.GetToken(ObjCParserUNION, 0)
}

func (s *Struct_or_union_specifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *Struct_or_union_specifierContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *Struct_or_union_specifierContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *Struct_or_union_specifierContext) AllStruct_declaration() []IStruct_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem())
	var tst = make([]IStruct_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declarationContext)
		}
	}

	return tst
}

func (s *Struct_or_union_specifierContext) Struct_declaration(i int) IStruct_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarationContext)
}

func (s *Struct_or_union_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_or_union_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_or_union_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStruct_or_union_specifier(s)
	}
}

func (s *Struct_or_union_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStruct_or_union_specifier(s)
	}
}




func (p *ObjCParser) Struct_or_union_specifier() (localctx IStruct_or_union_specifierContext) {
	localctx = NewStruct_or_union_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ObjCParserRULE_struct_or_union_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjCParserSTRUCT || _la == ObjCParserUNION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(815)
			p.Match(ObjCParserIDENTIFIER)
		}


	case 2:
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserIDENTIFIER {
			{
				p.SetState(816)
				p.Match(ObjCParserIDENTIFIER)
			}

		}
		{
			p.SetState(819)
			p.Match(ObjCParserLBRACE)
		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (ObjCParserBYCOPY - 28)) | (1 << (ObjCParserBYREF - 28)) | (1 << (ObjCParserCHAR - 28)) | (1 << (ObjCParserCONST - 28)) | (1 << (ObjCParserDOUBLE - 28)) | (1 << (ObjCParserENUM - 28)) | (1 << (ObjCParserFLOAT - 28)) | (1 << (ObjCParserID - 28)) | (1 << (ObjCParserIN - 28)) | (1 << (ObjCParserINOUT - 28)) | (1 << (ObjCParserINT - 28)) | (1 << (ObjCParserLONG - 28)) | (1 << (ObjCParserONEWAY - 28)) | (1 << (ObjCParserOUT - 28)) | (1 << (ObjCParserSHORT - 28)) | (1 << (ObjCParserSIGNED - 28)) | (1 << (ObjCParserSTRUCT - 28)))) != 0) || ((((_la - 60)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 60))) & ((1 << (ObjCParserUNION - 60)) | (1 << (ObjCParserUNSIGNED - 60)) | (1 << (ObjCParserVOID - 60)) | (1 << (ObjCParserVOLATILE - 60)) | (1 << (ObjCParserNS_OPTIONS - 60)) | (1 << (ObjCParserNS_ENUM - 60)) | (1 << (ObjCParserWWEAK - 60)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 60)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(820)
				p.Struct_declaration()
			}


			p.SetState(823)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(825)
			p.Match(ObjCParserRBRACE)
		}

	}



	return localctx
}


// IStruct_declarationContext is an interface to support dynamic dispatch.
type IStruct_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declarationContext differentiates from other interfaces.
	IsStruct_declarationContext()
}

type Struct_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declarationContext() *Struct_declarationContext {
	var p = new(Struct_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_struct_declaration
	return p
}

func (*Struct_declarationContext) IsStruct_declarationContext() {}

func NewStruct_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declarationContext {
	var p = new(Struct_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_struct_declaration

	return p
}

func (s *Struct_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declarationContext) Specifier_qualifier_list() ISpecifier_qualifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifier_qualifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifier_qualifier_listContext)
}

func (s *Struct_declarationContext) Struct_declarator_list() IStruct_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarator_listContext)
}

func (s *Struct_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Struct_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStruct_declaration(s)
	}
}

func (s *Struct_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStruct_declaration(s)
	}
}




func (p *ObjCParser) Struct_declaration() (localctx IStruct_declarationContext) {
	localctx = NewStruct_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ObjCParserRULE_struct_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Specifier_qualifier_list()
	}
	{
		p.SetState(830)
		p.Struct_declarator_list()
	}
	{
		p.SetState(831)
		p.Match(ObjCParserSEMI)
	}



	return localctx
}


// ISpecifier_qualifier_listContext is an interface to support dynamic dispatch.
type ISpecifier_qualifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecifier_qualifier_listContext differentiates from other interfaces.
	IsSpecifier_qualifier_listContext()
}

type Specifier_qualifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifier_qualifier_listContext() *Specifier_qualifier_listContext {
	var p = new(Specifier_qualifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_specifier_qualifier_list
	return p
}

func (*Specifier_qualifier_listContext) IsSpecifier_qualifier_listContext() {}

func NewSpecifier_qualifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specifier_qualifier_listContext {
	var p = new(Specifier_qualifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_specifier_qualifier_list

	return p
}

func (s *Specifier_qualifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Specifier_qualifier_listContext) AllArc_behaviour_specifier() []IArc_behaviour_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArc_behaviour_specifierContext)(nil)).Elem())
	var tst = make([]IArc_behaviour_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArc_behaviour_specifierContext)
		}
	}

	return tst
}

func (s *Specifier_qualifier_listContext) Arc_behaviour_specifier(i int) IArc_behaviour_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArc_behaviour_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArc_behaviour_specifierContext)
}

func (s *Specifier_qualifier_listContext) AllType_specifier() []IType_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specifierContext)(nil)).Elem())
	var tst = make([]IType_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specifierContext)
		}
	}

	return tst
}

func (s *Specifier_qualifier_listContext) Type_specifier(i int) IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Specifier_qualifier_listContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *Specifier_qualifier_listContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *Specifier_qualifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specifier_qualifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Specifier_qualifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSpecifier_qualifier_list(s)
	}
}

func (s *Specifier_qualifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSpecifier_qualifier_list(s)
	}
}




func (p *ObjCParser) Specifier_qualifier_list() (localctx ISpecifier_qualifier_listContext) {
	localctx = NewSpecifier_qualifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ObjCParserRULE_specifier_qualifier_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(836)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjCParserWWEAK, ObjCParserWUNSAFE_UNRETAINED:
					{
						p.SetState(833)
						p.Arc_behaviour_specifier()
					}


				case ObjCParserCHAR, ObjCParserDOUBLE, ObjCParserENUM, ObjCParserFLOAT, ObjCParserID, ObjCParserINT, ObjCParserLONG, ObjCParserSHORT, ObjCParserSIGNED, ObjCParserSTRUCT, ObjCParserUNION, ObjCParserUNSIGNED, ObjCParserVOID, ObjCParserNS_OPTIONS, ObjCParserNS_ENUM, ObjCParserIDENTIFIER:
					{
						p.SetState(834)
						p.Type_specifier()
					}


				case ObjCParserBYCOPY, ObjCParserBYREF, ObjCParserCONST, ObjCParserIN, ObjCParserINOUT, ObjCParserONEWAY, ObjCParserOUT, ObjCParserVOLATILE:
					{
						p.SetState(835)
						p.Type_qualifier()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}



	return localctx
}


// IStruct_declarator_listContext is an interface to support dynamic dispatch.
type IStruct_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declarator_listContext differentiates from other interfaces.
	IsStruct_declarator_listContext()
}

type Struct_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declarator_listContext() *Struct_declarator_listContext {
	var p = new(Struct_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_struct_declarator_list
	return p
}

func (*Struct_declarator_listContext) IsStruct_declarator_listContext() {}

func NewStruct_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declarator_listContext {
	var p = new(Struct_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_struct_declarator_list

	return p
}

func (s *Struct_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declarator_listContext) AllStruct_declarator() []IStruct_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declaratorContext)(nil)).Elem())
	var tst = make([]IStruct_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declaratorContext)
		}
	}

	return tst
}

func (s *Struct_declarator_listContext) Struct_declarator(i int) IStruct_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declaratorContext)
}

func (s *Struct_declarator_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Struct_declarator_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Struct_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStruct_declarator_list(s)
	}
}

func (s *Struct_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStruct_declarator_list(s)
	}
}




func (p *ObjCParser) Struct_declarator_list() (localctx IStruct_declarator_listContext) {
	localctx = NewStruct_declarator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ObjCParserRULE_struct_declarator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Struct_declarator()
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(841)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(842)
			p.Struct_declarator()
		}


		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IStruct_declaratorContext is an interface to support dynamic dispatch.
type IStruct_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declaratorContext differentiates from other interfaces.
	IsStruct_declaratorContext()
}

type Struct_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declaratorContext() *Struct_declaratorContext {
	var p = new(Struct_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_struct_declarator
	return p
}

func (*Struct_declaratorContext) IsStruct_declaratorContext() {}

func NewStruct_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declaratorContext {
	var p = new(Struct_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_struct_declarator

	return p
}

func (s *Struct_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Struct_declaratorContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Struct_declaratorContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Struct_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStruct_declarator(s)
	}
}

func (s *Struct_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStruct_declarator(s)
	}
}




func (p *ObjCParser) Struct_declarator() (localctx IStruct_declaratorContext) {
	localctx = NewStruct_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ObjCParserRULE_struct_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.Declarator()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserLPAREN || _la == ObjCParserMUL || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(849)
				p.Declarator()
			}

		}
		{
			p.SetState(852)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(853)
			p.Constant()
		}

	}


	return localctx
}


// IEnum_specifierContext is an interface to support dynamic dispatch.
type IEnum_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_specifierContext differentiates from other interfaces.
	IsEnum_specifierContext()
}

type Enum_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_specifierContext() *Enum_specifierContext {
	var p = new(Enum_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_enum_specifier
	return p
}

func (*Enum_specifierContext) IsEnum_specifierContext() {}

func NewEnum_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_specifierContext {
	var p = new(Enum_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_enum_specifier

	return p
}

func (s *Enum_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_specifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(ObjCParserENUM, 0)
}

func (s *Enum_specifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enum_specifierContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *Enum_specifierContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enum_specifierContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *Enum_specifierContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Enum_specifierContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Enum_specifierContext) NS_OPTIONS() antlr.TerminalNode {
	return s.GetToken(ObjCParserNS_OPTIONS, 0)
}

func (s *Enum_specifierContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Enum_specifierContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, 0)
}

func (s *Enum_specifierContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Enum_specifierContext) NS_ENUM() antlr.TerminalNode {
	return s.GetToken(ObjCParserNS_ENUM, 0)
}

func (s *Enum_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Enum_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterEnum_specifier(s)
	}
}

func (s *Enum_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitEnum_specifier(s)
	}
}




func (p *ObjCParser) Enum_specifier() (localctx IEnum_specifierContext) {
	localctx = NewEnum_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ObjCParserRULE_enum_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(894)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserENUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(856)
			p.Match(ObjCParserENUM)
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserCOLON {
			{
				p.SetState(857)
				p.Match(ObjCParserCOLON)
			}
			{
				p.SetState(858)
				p.Type_name()
			}

		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjCParserIDENTIFIER:
			{
				p.SetState(861)
				p.Identifier()
			}
			p.SetState(866)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(862)
					p.Match(ObjCParserLBRACE)
				}
				{
					p.SetState(863)
					p.Enumerator_list()
				}
				{
					p.SetState(864)
					p.Match(ObjCParserRBRACE)
				}


			}


		case ObjCParserLBRACE:
			{
				p.SetState(868)
				p.Match(ObjCParserLBRACE)
			}
			{
				p.SetState(869)
				p.Enumerator_list()
			}
			{
				p.SetState(870)
				p.Match(ObjCParserRBRACE)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case ObjCParserNS_OPTIONS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.Match(ObjCParserNS_OPTIONS)
		}
		{
			p.SetState(875)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(876)
			p.Type_name()
		}
		{
			p.SetState(877)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(878)
			p.Identifier()
		}
		{
			p.SetState(879)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(880)
			p.Match(ObjCParserLBRACE)
		}
		{
			p.SetState(881)
			p.Enumerator_list()
		}
		{
			p.SetState(882)
			p.Match(ObjCParserRBRACE)
		}


	case ObjCParserNS_ENUM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(884)
			p.Match(ObjCParserNS_ENUM)
		}
		{
			p.SetState(885)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(886)
			p.Type_name()
		}
		{
			p.SetState(887)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(888)
			p.Identifier()
		}
		{
			p.SetState(889)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(890)
			p.Match(ObjCParserLBRACE)
		}
		{
			p.SetState(891)
			p.Enumerator_list()
		}
		{
			p.SetState(892)
			p.Match(ObjCParserRBRACE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IEnumerator_listContext is an interface to support dynamic dispatch.
type IEnumerator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_listContext differentiates from other interfaces.
	IsEnumerator_listContext()
}

type Enumerator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_listContext() *Enumerator_listContext {
	var p = new(Enumerator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_enumerator_list
	return p
}

func (*Enumerator_listContext) IsEnumerator_listContext() {}

func NewEnumerator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_listContext {
	var p = new(Enumerator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_enumerator_list

	return p
}

func (s *Enumerator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_listContext) AllEnumerator() []IEnumeratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem())
	var tst = make([]IEnumeratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeratorContext)
		}
	}

	return tst
}

func (s *Enumerator_listContext) Enumerator(i int) IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enumerator_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Enumerator_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Enumerator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Enumerator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterEnumerator_list(s)
	}
}

func (s *Enumerator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitEnumerator_list(s)
	}
}




func (p *ObjCParser) Enumerator_list() (localctx IEnumerator_listContext) {
	localctx = NewEnumerator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ObjCParserRULE_enumerator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.Enumerator()
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(897)
				p.Match(ObjCParserCOMMA)
			}
			{
				p.SetState(898)
				p.Enumerator()
			}


		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOMMA {
		{
			p.SetState(904)
			p.Match(ObjCParserCOMMA)
		}

	}



	return localctx
}


// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumeratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGN, 0)
}

func (s *EnumeratorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitEnumerator(s)
	}
}




func (p *ObjCParser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ObjCParserRULE_enumerator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.Identifier()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserASSIGN {
		{
			p.SetState(908)
			p.Match(ObjCParserASSIGN)
		}
		{
			p.SetState(909)
			p.Constant_expression()
		}

	}



	return localctx
}


// IPointerContext is an interface to support dynamic dispatch.
type IPointerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPointerContext differentiates from other interfaces.
	IsPointerContext()
}

type PointerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerContext() *PointerContext {
	var p = new(PointerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_pointer
	return p
}

func (*PointerContext) IsPointerContext() {}

func NewPointerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerContext {
	var p = new(PointerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_pointer

	return p
}

func (s *PointerContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerContext) MUL() antlr.TerminalNode {
	return s.GetToken(ObjCParserMUL, 0)
}

func (s *PointerContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *PointerContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *PointerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PointerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterPointer(s)
	}
}

func (s *PointerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitPointer(s)
	}
}




func (p *ObjCParser) Pointer() (localctx IPointerContext) {
	localctx = NewPointerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ObjCParserRULE_pointer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(912)
			p.Match(ObjCParserMUL)
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(913)
				p.Declaration_specifiers()
			}


		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.Match(ObjCParserMUL)
		}
		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 25)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 25))) & ((1 << (ObjCParserAUTO - 25)) | (1 << (ObjCParserBYCOPY - 25)) | (1 << (ObjCParserBYREF - 25)) | (1 << (ObjCParserCHAR - 25)) | (1 << (ObjCParserCONST - 25)) | (1 << (ObjCParserDOUBLE - 25)) | (1 << (ObjCParserENUM - 25)) | (1 << (ObjCParserEXTERN - 25)) | (1 << (ObjCParserFLOAT - 25)) | (1 << (ObjCParserID - 25)) | (1 << (ObjCParserIN - 25)) | (1 << (ObjCParserINOUT - 25)) | (1 << (ObjCParserINT - 25)) | (1 << (ObjCParserLONG - 25)) | (1 << (ObjCParserONEWAY - 25)) | (1 << (ObjCParserOUT - 25)) | (1 << (ObjCParserREGISTER - 25)) | (1 << (ObjCParserSHORT - 25)) | (1 << (ObjCParserSIGNED - 25)) | (1 << (ObjCParserSTATIC - 25)))) != 0) || ((((_la - 57)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 57))) & ((1 << (ObjCParserSTRUCT - 57)) | (1 << (ObjCParserTYPEDEF - 57)) | (1 << (ObjCParserUNION - 57)) | (1 << (ObjCParserUNSIGNED - 57)) | (1 << (ObjCParserVOID - 57)) | (1 << (ObjCParserVOLATILE - 57)) | (1 << (ObjCParserNS_OPTIONS - 57)) | (1 << (ObjCParserNS_ENUM - 57)) | (1 << (ObjCParserWWEAK - 57)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 57)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(917)
				p.Declaration_specifiers()
			}

		}
		{
			p.SetState(920)
			p.Pointer()
		}

	}


	return localctx
}


// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Direct_declarator() IDirect_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirect_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirect_declaratorContext)
}

func (s *DeclaratorContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDeclarator(s)
	}
}




func (p *ObjCParser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ObjCParserRULE_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserMUL {
		{
			p.SetState(923)
			p.Pointer()
		}

	}
	{
		p.SetState(926)
		p.Direct_declarator()
	}



	return localctx
}


// IDirect_declaratorContext is an interface to support dynamic dispatch.
type IDirect_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirect_declaratorContext differentiates from other interfaces.
	IsDirect_declaratorContext()
}

type Direct_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirect_declaratorContext() *Direct_declaratorContext {
	var p = new(Direct_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_direct_declarator
	return p
}

func (*Direct_declaratorContext) IsDirect_declaratorContext() {}

func NewDirect_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Direct_declaratorContext {
	var p = new(Direct_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_direct_declarator

	return p
}

func (s *Direct_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Direct_declaratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Direct_declaratorContext) AllDeclarator_suffix() []IDeclarator_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarator_suffixContext)(nil)).Elem())
	var tst = make([]IDeclarator_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarator_suffixContext)
		}
	}

	return tst
}

func (s *Direct_declaratorContext) Declarator_suffix(i int) IDeclarator_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarator_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarator_suffixContext)
}

func (s *Direct_declaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Direct_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Direct_declaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Direct_declaratorContext) CARET() antlr.TerminalNode {
	return s.GetToken(ObjCParserCARET, 0)
}

func (s *Direct_declaratorContext) Block_parameters() IBlock_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_parametersContext)
}

func (s *Direct_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Direct_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Direct_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDirect_declarator(s)
	}
}

func (s *Direct_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDirect_declarator(s)
	}
}




func (p *ObjCParser) Direct_declarator() (localctx IDirect_declaratorContext) {
	localctx = NewDirect_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ObjCParserRULE_direct_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Identifier()
		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(929)
					p.Declarator_suffix()
				}


			}
			p.SetState(934)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(935)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(936)
			p.Declarator()
		}
		{
			p.SetState(937)
			p.Match(ObjCParserRPAREN)
		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(938)
					p.Declarator_suffix()
				}


			}
			p.SetState(943)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(945)
			p.Match(ObjCParserCARET)
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserIDENTIFIER {
			{
				p.SetState(946)
				p.Identifier()
			}

		}
		{
			p.SetState(949)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(950)
			p.Block_parameters()
		}

	}


	return localctx
}


// IDeclarator_suffixContext is an interface to support dynamic dispatch.
type IDeclarator_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarator_suffixContext differentiates from other interfaces.
	IsDeclarator_suffixContext()
}

type Declarator_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarator_suffixContext() *Declarator_suffixContext {
	var p = new(Declarator_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_declarator_suffix
	return p
}

func (*Declarator_suffixContext) IsDeclarator_suffixContext() {}

func NewDeclarator_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declarator_suffixContext {
	var p = new(Declarator_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_declarator_suffix

	return p
}

func (s *Declarator_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Declarator_suffixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, 0)
}

func (s *Declarator_suffixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, 0)
}

func (s *Declarator_suffixContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Declarator_suffixContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Declarator_suffixContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Declarator_suffixContext) Parameter_list() IParameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_listContext)
}

func (s *Declarator_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declarator_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declarator_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDeclarator_suffix(s)
	}
}

func (s *Declarator_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDeclarator_suffix(s)
	}
}




func (p *ObjCParser) Declarator_suffix() (localctx IDeclarator_suffixContext) {
	localctx = NewDeclarator_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ObjCParserRULE_declarator_suffix)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(963)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Match(ObjCParserLBRACK)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
			{
				p.SetState(954)
				p.Constant_expression()
			}

		}
		{
			p.SetState(957)
			p.Match(ObjCParserRBRACK)
		}


	case ObjCParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(958)
			p.Match(ObjCParserLPAREN)
		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 25)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 25))) & ((1 << (ObjCParserAUTO - 25)) | (1 << (ObjCParserBYCOPY - 25)) | (1 << (ObjCParserBYREF - 25)) | (1 << (ObjCParserCHAR - 25)) | (1 << (ObjCParserCONST - 25)) | (1 << (ObjCParserDOUBLE - 25)) | (1 << (ObjCParserENUM - 25)) | (1 << (ObjCParserEXTERN - 25)) | (1 << (ObjCParserFLOAT - 25)) | (1 << (ObjCParserID - 25)) | (1 << (ObjCParserIN - 25)) | (1 << (ObjCParserINOUT - 25)) | (1 << (ObjCParserINT - 25)) | (1 << (ObjCParserLONG - 25)) | (1 << (ObjCParserONEWAY - 25)) | (1 << (ObjCParserOUT - 25)) | (1 << (ObjCParserREGISTER - 25)) | (1 << (ObjCParserSHORT - 25)) | (1 << (ObjCParserSIGNED - 25)) | (1 << (ObjCParserSTATIC - 25)))) != 0) || ((((_la - 57)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 57))) & ((1 << (ObjCParserSTRUCT - 57)) | (1 << (ObjCParserTYPEDEF - 57)) | (1 << (ObjCParserUNION - 57)) | (1 << (ObjCParserUNSIGNED - 57)) | (1 << (ObjCParserVOID - 57)) | (1 << (ObjCParserVOLATILE - 57)) | (1 << (ObjCParserNS_OPTIONS - 57)) | (1 << (ObjCParserNS_ENUM - 57)) | (1 << (ObjCParserWWEAK - 57)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 57)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(959)
				p.Parameter_list()
			}

		}
		{
			p.SetState(962)
			p.Match(ObjCParserRPAREN)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IParameter_listContext is an interface to support dynamic dispatch.
type IParameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_listContext differentiates from other interfaces.
	IsParameter_listContext()
}

type Parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_listContext() *Parameter_listContext {
	var p = new(Parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_parameter_list
	return p
}

func (*Parameter_listContext) IsParameter_listContext() {}

func NewParameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_listContext {
	var p = new(Parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_parameter_list

	return p
}

func (s *Parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_listContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_listContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, 0)
}

func (s *Parameter_listContext) ELIPSIS() antlr.TerminalNode {
	return s.GetToken(ObjCParserELIPSIS, 0)
}

func (s *Parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterParameter_list(s)
	}
}

func (s *Parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitParameter_list(s)
	}
}




func (p *ObjCParser) Parameter_list() (localctx IParameter_listContext) {
	localctx = NewParameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ObjCParserRULE_parameter_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Parameter_declaration_list()
	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserCOMMA {
		{
			p.SetState(966)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(967)
			p.Match(ObjCParserELIPSIS)
		}

	}



	return localctx
}


// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *Parameter_declarationContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Parameter_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}




func (p *ObjCParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ObjCParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.Declaration_specifiers()
	}
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.SetState(972)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(971)
				p.Declarator()
			}


		}


	case 2:
		{
			p.SetState(974)
			p.Abstract_declarator()
		}

	}



	return localctx
}


// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *InitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *InitializerContext) AllInitializer() []IInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializerContext)(nil)).Elem())
	var tst = make([]IInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializerContext)
		}
	}

	return tst
}

func (s *InitializerContext) Initializer(i int) IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *InitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *InitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInitializer(s)
	}
}




func (p *ObjCParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ObjCParserRULE_initializer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(992)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserENCODE, ObjCParserPROTOCOL, ObjCParserSELECTOR, ObjCParserSUPER, ObjCParserSELF, ObjCParserSIZEOF, ObjCParserLPAREN, ObjCParserLBRACK, ObjCParserAT, ObjCParserBANG, ObjCParserTILDE, ObjCParserINC, ObjCParserDEC, ObjCParserSUB, ObjCParserMUL, ObjCParserBITAND, ObjCParserCARET, ObjCParserIDENTIFIER, ObjCParserCHARACTER_LITERAL, ObjCParserSTRING_LITERAL, ObjCParserHEX_LITERAL, ObjCParserDECIMAL_LITERAL, ObjCParserOCTAL_LITERAL, ObjCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Assignment_expression()
		}


	case ObjCParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.Match(ObjCParserLBRACE)
		}
		{
			p.SetState(979)
			p.Initializer()
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(980)
					p.Match(ObjCParserCOMMA)
				}
				{
					p.SetState(981)
					p.Initializer()
				}


			}
			p.SetState(986)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjCParserCOMMA {
			{
				p.SetState(987)
				p.Match(ObjCParserCOMMA)
			}

		}
		{
			p.SetState(990)
			p.Match(ObjCParserRBRACE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_type_name
	return p
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Specifier_qualifier_list() ISpecifier_qualifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifier_qualifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifier_qualifier_listContext)
}

func (s *Type_nameContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Type_nameContext) Block_type() IBlock_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_typeContext)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitType_name(s)
	}
}




func (p *ObjCParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ObjCParserRULE_type_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(994)
			p.Specifier_qualifier_list()
		}
		{
			p.SetState(995)
			p.Abstract_declarator()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(997)
			p.Block_type()
		}

	}


	return localctx
}


// IAbstract_declaratorContext is an interface to support dynamic dispatch.
type IAbstract_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_declaratorContext differentiates from other interfaces.
	IsAbstract_declaratorContext()
}

type Abstract_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_declaratorContext() *Abstract_declaratorContext {
	var p = new(Abstract_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_abstract_declarator
	return p
}

func (*Abstract_declaratorContext) IsAbstract_declaratorContext() {}

func NewAbstract_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_declaratorContext {
	var p = new(Abstract_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_abstract_declarator

	return p
}

func (s *Abstract_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_declaratorContext) Pointer() IPointerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPointerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPointerContext)
}

func (s *Abstract_declaratorContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Abstract_declaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Abstract_declaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Abstract_declaratorContext) AllAbstract_declarator_suffix() []IAbstract_declarator_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAbstract_declarator_suffixContext)(nil)).Elem())
	var tst = make([]IAbstract_declarator_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAbstract_declarator_suffixContext)
		}
	}

	return tst
}

func (s *Abstract_declaratorContext) Abstract_declarator_suffix(i int) IAbstract_declarator_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declarator_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declarator_suffixContext)
}

func (s *Abstract_declaratorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserLBRACK)
}

func (s *Abstract_declaratorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, i)
}

func (s *Abstract_declaratorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserRBRACK)
}

func (s *Abstract_declaratorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, i)
}

func (s *Abstract_declaratorContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Abstract_declaratorContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Abstract_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Abstract_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAbstract_declarator(s)
	}
}

func (s *Abstract_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAbstract_declarator(s)
	}
}




func (p *ObjCParser) Abstract_declarator() (localctx IAbstract_declaratorContext) {
	localctx = NewAbstract_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ObjCParserRULE_abstract_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1000)
			p.Pointer()
		}
		{
			p.SetState(1001)
			p.Abstract_declarator()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1003)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(1004)
			p.Abstract_declarator()
		}
		{
			p.SetState(1005)
			p.Match(ObjCParserRPAREN)
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(1006)
						p.Abstract_declarator_suffix()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1009)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjCParserLBRACK {
			{
				p.SetState(1011)
				p.Match(ObjCParserLBRACK)
			}
			p.SetState(1013)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
				{
					p.SetState(1012)
					p.Constant_expression()
				}

			}
			{
				p.SetState(1015)
				p.Match(ObjCParserRBRACK)
			}


			p.SetState(1018)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)

	}


	return localctx
}


// IAbstract_declarator_suffixContext is an interface to support dynamic dispatch.
type IAbstract_declarator_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_declarator_suffixContext differentiates from other interfaces.
	IsAbstract_declarator_suffixContext()
}

type Abstract_declarator_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_declarator_suffixContext() *Abstract_declarator_suffixContext {
	var p = new(Abstract_declarator_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_abstract_declarator_suffix
	return p
}

func (*Abstract_declarator_suffixContext) IsAbstract_declarator_suffixContext() {}

func NewAbstract_declarator_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_declarator_suffixContext {
	var p = new(Abstract_declarator_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_abstract_declarator_suffix

	return p
}

func (s *Abstract_declarator_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_declarator_suffixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, 0)
}

func (s *Abstract_declarator_suffixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, 0)
}

func (s *Abstract_declarator_suffixContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Abstract_declarator_suffixContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Abstract_declarator_suffixContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Abstract_declarator_suffixContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Abstract_declarator_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_declarator_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Abstract_declarator_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAbstract_declarator_suffix(s)
	}
}

func (s *Abstract_declarator_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAbstract_declarator_suffix(s)
	}
}




func (p *ObjCParser) Abstract_declarator_suffix() (localctx IAbstract_declarator_suffixContext) {
	localctx = NewAbstract_declarator_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ObjCParserRULE_abstract_declarator_suffix)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1033)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1023)
			p.Match(ObjCParserLBRACK)
		}
		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
			{
				p.SetState(1024)
				p.Constant_expression()
			}

		}
		{
			p.SetState(1027)
			p.Match(ObjCParserRBRACK)
		}


	case ObjCParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1028)
			p.Match(ObjCParserLPAREN)
		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 25)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 25))) & ((1 << (ObjCParserAUTO - 25)) | (1 << (ObjCParserBYCOPY - 25)) | (1 << (ObjCParserBYREF - 25)) | (1 << (ObjCParserCHAR - 25)) | (1 << (ObjCParserCONST - 25)) | (1 << (ObjCParserDOUBLE - 25)) | (1 << (ObjCParserENUM - 25)) | (1 << (ObjCParserEXTERN - 25)) | (1 << (ObjCParserFLOAT - 25)) | (1 << (ObjCParserID - 25)) | (1 << (ObjCParserIN - 25)) | (1 << (ObjCParserINOUT - 25)) | (1 << (ObjCParserINT - 25)) | (1 << (ObjCParserLONG - 25)) | (1 << (ObjCParserONEWAY - 25)) | (1 << (ObjCParserOUT - 25)) | (1 << (ObjCParserREGISTER - 25)) | (1 << (ObjCParserSHORT - 25)) | (1 << (ObjCParserSIGNED - 25)) | (1 << (ObjCParserSTATIC - 25)))) != 0) || ((((_la - 57)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 57))) & ((1 << (ObjCParserSTRUCT - 57)) | (1 << (ObjCParserTYPEDEF - 57)) | (1 << (ObjCParserUNION - 57)) | (1 << (ObjCParserUNSIGNED - 57)) | (1 << (ObjCParserVOID - 57)) | (1 << (ObjCParserVOLATILE - 57)) | (1 << (ObjCParserNS_OPTIONS - 57)) | (1 << (ObjCParserNS_ENUM - 57)) | (1 << (ObjCParserWWEAK - 57)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 57)))) != 0) || _la == ObjCParserIDENTIFIER {
			{
				p.SetState(1029)
				p.Parameter_declaration_list()
			}

		}
		{
			p.SetState(1032)
			p.Match(ObjCParserRPAREN)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IParameter_declaration_listContext is an interface to support dynamic dispatch.
type IParameter_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_listContext differentiates from other interfaces.
	IsParameter_declaration_listContext()
}

type Parameter_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_listContext() *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_parameter_declaration_list
	return p
}

func (*Parameter_declaration_listContext) IsParameter_declaration_listContext() {}

func NewParameter_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_parameter_declaration_list

	return p
}

func (s *Parameter_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_listContext) AllParameter_declaration() []IParameter_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem())
	var tst = make([]IParameter_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_declarationContext)
		}
	}

	return tst
}

func (s *Parameter_declaration_listContext) Parameter_declaration(i int) IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_declaration_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Parameter_declaration_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Parameter_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterParameter_declaration_list(s)
	}
}

func (s *Parameter_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitParameter_declaration_list(s)
	}
}




func (p *ObjCParser) Parameter_declaration_list() (localctx IParameter_declaration_listContext) {
	localctx = NewParameter_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ObjCParserRULE_parameter_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Parameter_declaration()
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1036)
				p.Match(ObjCParserCOMMA)
			}
			{
				p.SetState(1037)
				p.Parameter_declaration()
			}


		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
	}



	return localctx
}


// IStatement_listContext is an interface to support dynamic dispatch.
type IStatement_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_listContext differentiates from other interfaces.
	IsStatement_listContext()
}

type Statement_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_listContext() *Statement_listContext {
	var p = new(Statement_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_statement_list
	return p
}

func (*Statement_listContext) IsStatement_listContext() {}

func NewStatement_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_listContext {
	var p = new(Statement_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_statement_list

	return p
}

func (s *Statement_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_listContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Statement_listContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Statement_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStatement_list(s)
	}
}

func (s *Statement_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStatement_list(s)
	}
}




func (p *ObjCParser) Statement_list() (localctx IStatement_listContext) {
	localctx = NewStatement_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ObjCParserRULE_statement_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(1043)
					p.Statement()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}



	return localctx
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Labeled_statement() ILabeled_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeled_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeled_statementContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *StatementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *StatementContext) Selection_statement() ISelection_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelection_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelection_statementContext)
}

func (s *StatementContext) Iteration_statement() IIteration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_statementContext)
}

func (s *StatementContext) Jump_statement() IJump_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_statementContext)
}

func (s *StatementContext) Synchronized_statement() ISynchronized_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISynchronized_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISynchronized_statementContext)
}

func (s *StatementContext) Autorelease_statement() IAutorelease_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAutorelease_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAutorelease_statementContext)
}

func (s *StatementContext) Try_block() ITry_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_blockContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitStatement(s)
	}
}




func (p *ObjCParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ObjCParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1060)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.Labeled_statement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.Expression()
		}
		{
			p.SetState(1050)
			p.Match(ObjCParserSEMI)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1052)
			p.Compound_statement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1053)
			p.Selection_statement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1054)
			p.Iteration_statement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1055)
			p.Jump_statement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1056)
			p.Synchronized_statement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1057)
			p.Autorelease_statement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1058)
			p.Try_block()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1059)
			p.Match(ObjCParserSEMI)
		}

	}


	return localctx
}


// ILabeled_statementContext is an interface to support dynamic dispatch.
type ILabeled_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeled_statementContext differentiates from other interfaces.
	IsLabeled_statementContext()
}

type Labeled_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeled_statementContext() *Labeled_statementContext {
	var p = new(Labeled_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_labeled_statement
	return p
}

func (*Labeled_statementContext) IsLabeled_statementContext() {}

func NewLabeled_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Labeled_statementContext {
	var p = new(Labeled_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_labeled_statement

	return p
}

func (s *Labeled_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Labeled_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Labeled_statementContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Labeled_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Labeled_statementContext) CASE() antlr.TerminalNode {
	return s.GetToken(ObjCParserCASE, 0)
}

func (s *Labeled_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Labeled_statementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ObjCParserDEFAULT, 0)
}

func (s *Labeled_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Labeled_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Labeled_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterLabeled_statement(s)
	}
}

func (s *Labeled_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitLabeled_statement(s)
	}
}




func (p *ObjCParser) Labeled_statement() (localctx ILabeled_statementContext) {
	localctx = NewLabeled_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ObjCParserRULE_labeled_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1074)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1062)
			p.Identifier()
		}
		{
			p.SetState(1063)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(1064)
			p.Statement()
		}


	case ObjCParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.Match(ObjCParserCASE)
		}
		{
			p.SetState(1067)
			p.Constant_expression()
		}
		{
			p.SetState(1068)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(1069)
			p.Statement()
		}


	case ObjCParserDEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1071)
			p.Match(ObjCParserDEFAULT)
		}
		{
			p.SetState(1072)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(1073)
			p.Statement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ICompound_statementContext is an interface to support dynamic dispatch.
type ICompound_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_statementContext differentiates from other interfaces.
	IsCompound_statementContext()
}

type Compound_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_statementContext() *Compound_statementContext {
	var p = new(Compound_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_compound_statement
	return p
}

func (*Compound_statementContext) IsCompound_statementContext() {}

func NewCompound_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_statementContext {
	var p = new(Compound_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_compound_statement

	return p
}

func (s *Compound_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_statementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACE, 0)
}

func (s *Compound_statementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACE, 0)
}

func (s *Compound_statementContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Compound_statementContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Compound_statementContext) AllStatement_list() []IStatement_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_listContext)(nil)).Elem())
	var tst = make([]IStatement_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_listContext)
		}
	}

	return tst
}

func (s *Compound_statementContext) Statement_list(i int) IStatement_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_listContext)
}

func (s *Compound_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCompound_statement(s)
	}
}

func (s *Compound_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCompound_statement(s)
	}
}




func (p *ObjCParser) Compound_statement() (localctx ICompound_statementContext) {
	localctx = NewCompound_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ObjCParserRULE_compound_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Match(ObjCParserLBRACE)
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserAUTORELEASEPOOL) | (1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSYNCHRONIZED) | (1 << ObjCParserTRY) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF) | (1 << ObjCParserAUTO) | (1 << ObjCParserBREAK) | (1 << ObjCParserBYCOPY) | (1 << ObjCParserBYREF) | (1 << ObjCParserCASE) | (1 << ObjCParserCHAR))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjCParserCONST - 32)) | (1 << (ObjCParserCONTINUE - 32)) | (1 << (ObjCParserDEFAULT - 32)) | (1 << (ObjCParserDO - 32)) | (1 << (ObjCParserDOUBLE - 32)) | (1 << (ObjCParserENUM - 32)) | (1 << (ObjCParserEXTERN - 32)) | (1 << (ObjCParserFLOAT - 32)) | (1 << (ObjCParserFOR - 32)) | (1 << (ObjCParserID - 32)) | (1 << (ObjCParserIF - 32)) | (1 << (ObjCParserIN - 32)) | (1 << (ObjCParserINOUT - 32)) | (1 << (ObjCParserGOTO - 32)) | (1 << (ObjCParserINT - 32)) | (1 << (ObjCParserLONG - 32)) | (1 << (ObjCParserONEWAY - 32)) | (1 << (ObjCParserOUT - 32)) | (1 << (ObjCParserREGISTER - 32)) | (1 << (ObjCParserRETURN - 32)) | (1 << (ObjCParserSHORT - 32)) | (1 << (ObjCParserSIGNED - 32)) | (1 << (ObjCParserSIZEOF - 32)) | (1 << (ObjCParserSTATIC - 32)) | (1 << (ObjCParserSTRUCT - 32)) | (1 << (ObjCParserSWITCH - 32)) | (1 << (ObjCParserTYPEDEF - 32)) | (1 << (ObjCParserUNION - 32)) | (1 << (ObjCParserUNSIGNED - 32)) | (1 << (ObjCParserVOID - 32)) | (1 << (ObjCParserVOLATILE - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjCParserWHILE - 64)) | (1 << (ObjCParserNS_OPTIONS - 64)) | (1 << (ObjCParserNS_ENUM - 64)) | (1 << (ObjCParserWWEAK - 64)) | (1 << (ObjCParserWUNSAFE_UNRETAINED - 64)) | (1 << (ObjCParserLPAREN - 64)) | (1 << (ObjCParserLBRACE - 64)) | (1 << (ObjCParserLBRACK - 64)) | (1 << (ObjCParserSEMI - 64)) | (1 << (ObjCParserAT - 64)) | (1 << (ObjCParserBANG - 64)) | (1 << (ObjCParserTILDE - 64)) | (1 << (ObjCParserINC - 64)) | (1 << (ObjCParserDEC - 64)))) != 0) || ((((_la - 96)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 96))) & ((1 << (ObjCParserSUB - 96)) | (1 << (ObjCParserMUL - 96)) | (1 << (ObjCParserBITAND - 96)) | (1 << (ObjCParserCARET - 96)) | (1 << (ObjCParserIDENTIFIER - 96)) | (1 << (ObjCParserCHARACTER_LITERAL - 96)) | (1 << (ObjCParserSTRING_LITERAL - 96)))) != 0) || ((((_la - 128)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 128))) & ((1 << (ObjCParserHEX_LITERAL - 128)) | (1 << (ObjCParserDECIMAL_LITERAL - 128)) | (1 << (ObjCParserOCTAL_LITERAL - 128)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 128)))) != 0) {
		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1077)
				p.Declaration()
			}


		case 2:
			{
				p.SetState(1078)
				p.Statement_list()
			}

		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1084)
		p.Match(ObjCParserRBRACE)
	}



	return localctx
}


// ISelection_statementContext is an interface to support dynamic dispatch.
type ISelection_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelection_statementContext differentiates from other interfaces.
	IsSelection_statementContext()
}

type Selection_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelection_statementContext() *Selection_statementContext {
	var p = new(Selection_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_selection_statement
	return p
}

func (*Selection_statementContext) IsSelection_statementContext() {}

func NewSelection_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selection_statementContext {
	var p = new(Selection_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_selection_statement

	return p
}

func (s *Selection_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Selection_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(ObjCParserIF, 0)
}

func (s *Selection_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Selection_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Selection_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Selection_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Selection_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Selection_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ObjCParserELSE, 0)
}

func (s *Selection_statementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ObjCParserSWITCH, 0)
}

func (s *Selection_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selection_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selection_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterSelection_statement(s)
	}
}

func (s *Selection_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitSelection_statement(s)
	}
}




func (p *ObjCParser) Selection_statement() (localctx ISelection_statementContext) {
	localctx = NewSelection_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ObjCParserRULE_selection_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1101)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.Match(ObjCParserIF)
		}
		{
			p.SetState(1087)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(1088)
			p.Expression()
		}
		{
			p.SetState(1089)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(1090)
			p.Statement()
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1091)
				p.Match(ObjCParserELSE)
			}
			{
				p.SetState(1092)
				p.Statement()
			}


		}


	case ObjCParserSWITCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1095)
			p.Match(ObjCParserSWITCH)
		}
		{
			p.SetState(1096)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(1097)
			p.Expression()
		}
		{
			p.SetState(1098)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(1099)
			p.Statement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFor_in_statementContext is an interface to support dynamic dispatch.
type IFor_in_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_in_statementContext differentiates from other interfaces.
	IsFor_in_statementContext()
}

type For_in_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_in_statementContext() *For_in_statementContext {
	var p = new(For_in_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_for_in_statement
	return p
}

func (*For_in_statementContext) IsFor_in_statementContext() {}

func NewFor_in_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_in_statementContext {
	var p = new(For_in_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_for_in_statement

	return p
}

func (s *For_in_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_in_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ObjCParserFOR, 0)
}

func (s *For_in_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *For_in_statementContext) Type_variable_declarator() IType_variable_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_variable_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_variable_declaratorContext)
}

func (s *For_in_statementContext) IN() antlr.TerminalNode {
	return s.GetToken(ObjCParserIN, 0)
}

func (s *For_in_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *For_in_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *For_in_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_in_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_in_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_in_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterFor_in_statement(s)
	}
}

func (s *For_in_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitFor_in_statement(s)
	}
}




func (p *ObjCParser) For_in_statement() (localctx IFor_in_statementContext) {
	localctx = NewFor_in_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ObjCParserRULE_for_in_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(ObjCParserFOR)
	}
	{
		p.SetState(1104)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(1105)
		p.Type_variable_declarator()
	}
	{
		p.SetState(1106)
		p.Match(ObjCParserIN)
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
		{
			p.SetState(1107)
			p.Expression()
		}

	}
	{
		p.SetState(1110)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(1111)
		p.Statement()
	}



	return localctx
}


// IFor_statementContext is an interface to support dynamic dispatch.
type IFor_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_statementContext differentiates from other interfaces.
	IsFor_statementContext()
}

type For_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_statementContext() *For_statementContext {
	var p = new(For_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_for_statement
	return p
}

func (*For_statementContext) IsFor_statementContext() {}

func NewFor_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_statementContext {
	var p = new(For_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_for_statement

	return p
}

func (s *For_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(ObjCParserFOR, 0)
}

func (s *For_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *For_statementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserSEMI)
}

func (s *For_statementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, i)
}

func (s *For_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *For_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *For_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *For_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_statementContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *For_statementContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *For_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterFor_statement(s)
	}
}

func (s *For_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitFor_statement(s)
	}
}




func (p *ObjCParser) For_statement() (localctx IFor_statementContext) {
	localctx = NewFor_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ObjCParserRULE_for_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Match(ObjCParserFOR)
	}
	{
		p.SetState(1114)
		p.Match(ObjCParserLPAREN)
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1115)
			p.Declaration_specifiers()
		}
		{
			p.SetState(1116)
			p.Init_declarator_list()
		}


	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1118)
			p.Expression()
		}


	}
	{
		p.SetState(1121)
		p.Match(ObjCParserSEMI)
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
		{
			p.SetState(1122)
			p.Expression()
		}

	}
	{
		p.SetState(1125)
		p.Match(ObjCParserSEMI)
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
		{
			p.SetState(1126)
			p.Expression()
		}

	}
	{
		p.SetState(1129)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(1130)
		p.Statement()
	}



	return localctx
}


// IWhile_statementContext is an interface to support dynamic dispatch.
type IWhile_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_statementContext differentiates from other interfaces.
	IsWhile_statementContext()
}

type While_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_statementContext() *While_statementContext {
	var p = new(While_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_while_statement
	return p
}

func (*While_statementContext) IsWhile_statementContext() {}

func NewWhile_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_statementContext {
	var p = new(While_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_while_statement

	return p
}

func (s *While_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *While_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ObjCParserWHILE, 0)
}

func (s *While_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *While_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *While_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *While_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *While_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *While_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterWhile_statement(s)
	}
}

func (s *While_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitWhile_statement(s)
	}
}




func (p *ObjCParser) While_statement() (localctx IWhile_statementContext) {
	localctx = NewWhile_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ObjCParserRULE_while_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1132)
		p.Match(ObjCParserWHILE)
	}
	{
		p.SetState(1133)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(1134)
		p.Expression()
	}
	{
		p.SetState(1135)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(1136)
		p.Statement()
	}



	return localctx
}


// IDo_statementContext is an interface to support dynamic dispatch.
type IDo_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDo_statementContext differentiates from other interfaces.
	IsDo_statementContext()
}

type Do_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_statementContext() *Do_statementContext {
	var p = new(Do_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_do_statement
	return p
}

func (*Do_statementContext) IsDo_statementContext() {}

func NewDo_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_statementContext {
	var p = new(Do_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_do_statement

	return p
}

func (s *Do_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_statementContext) DO() antlr.TerminalNode {
	return s.GetToken(ObjCParserDO, 0)
}

func (s *Do_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Do_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ObjCParserWHILE, 0)
}

func (s *Do_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Do_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Do_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Do_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Do_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Do_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterDo_statement(s)
	}
}

func (s *Do_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitDo_statement(s)
	}
}




func (p *ObjCParser) Do_statement() (localctx IDo_statementContext) {
	localctx = NewDo_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ObjCParserRULE_do_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		p.Match(ObjCParserDO)
	}
	{
		p.SetState(1139)
		p.Statement()
	}
	{
		p.SetState(1140)
		p.Match(ObjCParserWHILE)
	}
	{
		p.SetState(1141)
		p.Match(ObjCParserLPAREN)
	}
	{
		p.SetState(1142)
		p.Expression()
	}
	{
		p.SetState(1143)
		p.Match(ObjCParserRPAREN)
	}
	{
		p.SetState(1144)
		p.Match(ObjCParserSEMI)
	}



	return localctx
}


// IIteration_statementContext is an interface to support dynamic dispatch.
type IIteration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_statementContext differentiates from other interfaces.
	IsIteration_statementContext()
}

type Iteration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_statementContext() *Iteration_statementContext {
	var p = new(Iteration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_iteration_statement
	return p
}

func (*Iteration_statementContext) IsIteration_statementContext() {}

func NewIteration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_statementContext {
	var p = new(Iteration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_iteration_statement

	return p
}

func (s *Iteration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_statementContext) While_statement() IWhile_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_statementContext)
}

func (s *Iteration_statementContext) Do_statement() IDo_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDo_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDo_statementContext)
}

func (s *Iteration_statementContext) For_statement() IFor_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_statementContext)
}

func (s *Iteration_statementContext) For_in_statement() IFor_in_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_in_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_in_statementContext)
}

func (s *Iteration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Iteration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterIteration_statement(s)
	}
}

func (s *Iteration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitIteration_statement(s)
	}
}




func (p *ObjCParser) Iteration_statement() (localctx IIteration_statementContext) {
	localctx = NewIteration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ObjCParserRULE_iteration_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1146)
			p.While_statement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1147)
			p.Do_statement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1148)
			p.For_statement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1149)
			p.For_in_statement()
		}

	}


	return localctx
}


// IJump_statementContext is an interface to support dynamic dispatch.
type IJump_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_statementContext differentiates from other interfaces.
	IsJump_statementContext()
}

type Jump_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_statementContext() *Jump_statementContext {
	var p = new(Jump_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_jump_statement
	return p
}

func (*Jump_statementContext) IsJump_statementContext() {}

func NewJump_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_statementContext {
	var p = new(Jump_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_jump_statement

	return p
}

func (s *Jump_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_statementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(ObjCParserGOTO, 0)
}

func (s *Jump_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Jump_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ObjCParserSEMI, 0)
}

func (s *Jump_statementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ObjCParserCONTINUE, 0)
}

func (s *Jump_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ObjCParserBREAK, 0)
}

func (s *Jump_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRETURN, 0)
}

func (s *Jump_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Jump_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Jump_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterJump_statement(s)
	}
}

func (s *Jump_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitJump_statement(s)
	}
}




func (p *ObjCParser) Jump_statement() (localctx IJump_statementContext) {
	localctx = NewJump_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ObjCParserRULE_jump_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1165)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserGOTO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1152)
			p.Match(ObjCParserGOTO)
		}
		{
			p.SetState(1153)
			p.Identifier()
		}
		{
			p.SetState(1154)
			p.Match(ObjCParserSEMI)
		}


	case ObjCParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.Match(ObjCParserCONTINUE)
		}
		{
			p.SetState(1157)
			p.Match(ObjCParserSEMI)
		}


	case ObjCParserBREAK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1158)
			p.Match(ObjCParserBREAK)
		}
		{
			p.SetState(1159)
			p.Match(ObjCParserSEMI)
		}


	case ObjCParserRETURN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1160)
			p.Match(ObjCParserRETURN)
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
			{
				p.SetState(1161)
				p.Expression()
			}

		}
		{
			p.SetState(1164)
			p.Match(ObjCParserSEMI)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllAssignment_expression() []IAssignment_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem())
	var tst = make([]IAssignment_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignment_expressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Assignment_expression(i int) IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *ExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *ExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitExpression(s)
	}
}




func (p *ObjCParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ObjCParserRULE_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Assignment_expression()
	}
	p.SetState(1172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(1168)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(1169)
			p.Assignment_expression()
		}


		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssignment_expressionContext is an interface to support dynamic dispatch.
type IAssignment_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_expressionContext differentiates from other interfaces.
	IsAssignment_expressionContext()
}

type Assignment_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_expressionContext() *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_assignment_expression
	return p
}

func (*Assignment_expressionContext) IsAssignment_expressionContext() {}

func NewAssignment_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_assignment_expression

	return p
}

func (s *Assignment_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Assignment_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Assignment_expressionContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Assignment_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Assignment_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAssignment_expression(s)
	}
}

func (s *Assignment_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAssignment_expression(s)
	}
}




func (p *ObjCParser) Assignment_expression() (localctx IAssignment_expressionContext) {
	localctx = NewAssignment_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ObjCParserRULE_assignment_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1175)
			p.Conditional_expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1176)
			p.Unary_expression()
		}
		{
			p.SetState(1177)
			p.Assignment_operator()
		}
		{
			p.SetState(1178)
			p.Assignment_expression()
		}

	}


	return localctx
}


// IAssignment_operatorContext is an interface to support dynamic dispatch.
type IAssignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_operatorContext differentiates from other interfaces.
	IsAssignment_operatorContext()
}

type Assignment_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_operatorContext() *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_assignment_operator
	return p
}

func (*Assignment_operatorContext) IsAssignment_operatorContext() {}

func NewAssignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_assignment_operator

	return p
}

func (s *Assignment_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_operatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserASSIGN, 0)
}

func (s *Assignment_operatorContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserMUL_ASSIGN, 0)
}

func (s *Assignment_operatorContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserDIV_ASSIGN, 0)
}

func (s *Assignment_operatorContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserMOD_ASSIGN, 0)
}

func (s *Assignment_operatorContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserADD_ASSIGN, 0)
}

func (s *Assignment_operatorContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUB_ASSIGN, 0)
}

func (s *Assignment_operatorContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLSHIFT_ASSIGN, 0)
}

func (s *Assignment_operatorContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRSHIFT_ASSIGN, 0)
}

func (s *Assignment_operatorContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserAND_ASSIGN, 0)
}

func (s *Assignment_operatorContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserXOR_ASSIGN, 0)
}

func (s *Assignment_operatorContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ObjCParserOR_ASSIGN, 0)
}

func (s *Assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAssignment_operator(s)
	}
}




func (p *ObjCParser) Assignment_operator() (localctx IAssignment_operatorContext) {
	localctx = NewAssignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ObjCParserRULE_assignment_operator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 80)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 80))) & ((1 << (ObjCParserASSIGN - 80)) | (1 << (ObjCParserADD_ASSIGN - 80)) | (1 << (ObjCParserSUB_ASSIGN - 80)) | (1 << (ObjCParserMUL_ASSIGN - 80)) | (1 << (ObjCParserDIV_ASSIGN - 80)) | (1 << (ObjCParserAND_ASSIGN - 80)) | (1 << (ObjCParserOR_ASSIGN - 80)) | (1 << (ObjCParserXOR_ASSIGN - 80)))) != 0) || ((((_la - 112)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 112))) & ((1 << (ObjCParserMOD_ASSIGN - 112)) | (1 << (ObjCParserLSHIFT_ASSIGN - 112)) | (1 << (ObjCParserRSHIFT_ASSIGN - 112)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Conditional_expressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ObjCParserQUESTION, 0)
}

func (s *Conditional_expressionContext) AllConditional_expression() []IConditional_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem())
	var tst = make([]IConditional_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditional_expressionContext)
		}
	}

	return tst
}

func (s *Conditional_expressionContext) Conditional_expression(i int) IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Conditional_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(ObjCParserCOLON, 0)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}




func (p *ObjCParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ObjCParserRULE_conditional_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.Logical_or_expression()
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjCParserQUESTION {
		{
			p.SetState(1185)
			p.Match(ObjCParserQUESTION)
		}
		{
			p.SetState(1186)
			p.Conditional_expression()
		}
		{
			p.SetState(1187)
			p.Match(ObjCParserCOLON)
		}
		{
			p.SetState(1188)
			p.Conditional_expression()
		}

	}



	return localctx
}


// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}




func (p *ObjCParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ObjCParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.Conditional_expression()
	}



	return localctx
}


// ILogical_or_expressionContext is an interface to support dynamic dispatch.
type ILogical_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_or_expressionContext differentiates from other interfaces.
	IsLogical_or_expressionContext()
}

type Logical_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_or_expressionContext() *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_logical_or_expression
	return p
}

func (*Logical_or_expressionContext) IsLogical_or_expressionContext() {}

func NewLogical_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_logical_or_expression

	return p
}

func (s *Logical_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_or_expressionContext) AllLogical_and_expression() []ILogical_and_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem())
	var tst = make([]ILogical_and_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_and_expressionContext)
		}
	}

	return tst
}

func (s *Logical_or_expressionContext) Logical_and_expression(i int) ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_or_expressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserOR)
}

func (s *Logical_or_expressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserOR, i)
}

func (s *Logical_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Logical_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterLogical_or_expression(s)
	}
}

func (s *Logical_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitLogical_or_expression(s)
	}
}




func (p *ObjCParser) Logical_or_expression() (localctx ILogical_or_expressionContext) {
	localctx = NewLogical_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ObjCParserRULE_logical_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1194)
		p.Logical_and_expression()
	}
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserOR {
		{
			p.SetState(1195)
			p.Match(ObjCParserOR)
		}
		{
			p.SetState(1196)
			p.Logical_and_expression()
		}


		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ILogical_and_expressionContext is an interface to support dynamic dispatch.
type ILogical_and_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_and_expressionContext differentiates from other interfaces.
	IsLogical_and_expressionContext()
}

type Logical_and_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_and_expressionContext() *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_logical_and_expression
	return p
}

func (*Logical_and_expressionContext) IsLogical_and_expressionContext() {}

func NewLogical_and_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_logical_and_expression

	return p
}

func (s *Logical_and_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_and_expressionContext) AllInclusive_or_expression() []IInclusive_or_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInclusive_or_expressionContext)(nil)).Elem())
	var tst = make([]IInclusive_or_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInclusive_or_expressionContext)
		}
	}

	return tst
}

func (s *Logical_and_expressionContext) Inclusive_or_expression(i int) IInclusive_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusive_or_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInclusive_or_expressionContext)
}

func (s *Logical_and_expressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserAND)
}

func (s *Logical_and_expressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserAND, i)
}

func (s *Logical_and_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_and_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Logical_and_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterLogical_and_expression(s)
	}
}

func (s *Logical_and_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitLogical_and_expression(s)
	}
}




func (p *ObjCParser) Logical_and_expression() (localctx ILogical_and_expressionContext) {
	localctx = NewLogical_and_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ObjCParserRULE_logical_and_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1202)
		p.Inclusive_or_expression()
	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserAND {
		{
			p.SetState(1203)
			p.Match(ObjCParserAND)
		}
		{
			p.SetState(1204)
			p.Inclusive_or_expression()
		}


		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IInclusive_or_expressionContext is an interface to support dynamic dispatch.
type IInclusive_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclusive_or_expressionContext differentiates from other interfaces.
	IsInclusive_or_expressionContext()
}

type Inclusive_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusive_or_expressionContext() *Inclusive_or_expressionContext {
	var p = new(Inclusive_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_inclusive_or_expression
	return p
}

func (*Inclusive_or_expressionContext) IsInclusive_or_expressionContext() {}

func NewInclusive_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inclusive_or_expressionContext {
	var p = new(Inclusive_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_inclusive_or_expression

	return p
}

func (s *Inclusive_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inclusive_or_expressionContext) AllExclusive_or_expression() []IExclusive_or_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExclusive_or_expressionContext)(nil)).Elem())
	var tst = make([]IExclusive_or_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExclusive_or_expressionContext)
		}
	}

	return tst
}

func (s *Inclusive_or_expressionContext) Exclusive_or_expression(i int) IExclusive_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusive_or_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExclusive_or_expressionContext)
}

func (s *Inclusive_or_expressionContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserBITOR)
}

func (s *Inclusive_or_expressionContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserBITOR, i)
}

func (s *Inclusive_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inclusive_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Inclusive_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterInclusive_or_expression(s)
	}
}

func (s *Inclusive_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitInclusive_or_expression(s)
	}
}




func (p *ObjCParser) Inclusive_or_expression() (localctx IInclusive_or_expressionContext) {
	localctx = NewInclusive_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ObjCParserRULE_inclusive_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Exclusive_or_expression()
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserBITOR {
		{
			p.SetState(1211)
			p.Match(ObjCParserBITOR)
		}
		{
			p.SetState(1212)
			p.Exclusive_or_expression()
		}


		p.SetState(1217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IExclusive_or_expressionContext is an interface to support dynamic dispatch.
type IExclusive_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusive_or_expressionContext differentiates from other interfaces.
	IsExclusive_or_expressionContext()
}

type Exclusive_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusive_or_expressionContext() *Exclusive_or_expressionContext {
	var p = new(Exclusive_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_exclusive_or_expression
	return p
}

func (*Exclusive_or_expressionContext) IsExclusive_or_expressionContext() {}

func NewExclusive_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exclusive_or_expressionContext {
	var p = new(Exclusive_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_exclusive_or_expression

	return p
}

func (s *Exclusive_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Exclusive_or_expressionContext) AllAnd_expression() []IAnd_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem())
	var tst = make([]IAnd_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_expressionContext)
		}
	}

	return tst
}

func (s *Exclusive_or_expressionContext) And_expression(i int) IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *Exclusive_or_expressionContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCARET)
}

func (s *Exclusive_or_expressionContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCARET, i)
}

func (s *Exclusive_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exclusive_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exclusive_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterExclusive_or_expression(s)
	}
}

func (s *Exclusive_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitExclusive_or_expression(s)
	}
}




func (p *ObjCParser) Exclusive_or_expression() (localctx IExclusive_or_expressionContext) {
	localctx = NewExclusive_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ObjCParserRULE_exclusive_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.And_expression()
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCARET {
		{
			p.SetState(1219)
			p.Match(ObjCParserCARET)
		}
		{
			p.SetState(1220)
			p.And_expression()
		}


		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_and_expression
	return p
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) AllEquality_expression() []IEquality_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem())
	var tst = make([]IEquality_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquality_expressionContext)
		}
	}

	return tst
}

func (s *And_expressionContext) Equality_expression(i int) IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *And_expressionContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserBITAND)
}

func (s *And_expressionContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserBITAND, i)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}




func (p *ObjCParser) And_expression() (localctx IAnd_expressionContext) {
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ObjCParserRULE_and_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Equality_expression()
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserBITAND {
		{
			p.SetState(1227)
			p.Match(ObjCParserBITAND)
		}
		{
			p.SetState(1228)
			p.Equality_expression()
		}


		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IEquality_expressionContext is an interface to support dynamic dispatch.
type IEquality_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquality_expressionContext differentiates from other interfaces.
	IsEquality_expressionContext()
}

type Equality_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquality_expressionContext() *Equality_expressionContext {
	var p = new(Equality_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_equality_expression
	return p
}

func (*Equality_expressionContext) IsEquality_expressionContext() {}

func NewEquality_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Equality_expressionContext {
	var p = new(Equality_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_equality_expression

	return p
}

func (s *Equality_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Equality_expressionContext) AllRelational_expression() []IRelational_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem())
	var tst = make([]IRelational_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelational_expressionContext)
		}
	}

	return tst
}

func (s *Equality_expressionContext) Relational_expression(i int) IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Equality_expressionContext) AllNOTEQUAL() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserNOTEQUAL)
}

func (s *Equality_expressionContext) NOTEQUAL(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserNOTEQUAL, i)
}

func (s *Equality_expressionContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserEQUAL)
}

func (s *Equality_expressionContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserEQUAL, i)
}

func (s *Equality_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equality_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Equality_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterEquality_expression(s)
	}
}

func (s *Equality_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitEquality_expression(s)
	}
}




func (p *ObjCParser) Equality_expression() (localctx IEquality_expressionContext) {
	localctx = NewEquality_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ObjCParserRULE_equality_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1234)
		p.Relational_expression()
	}
	p.SetState(1239)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserEQUAL || _la == ObjCParserNOTEQUAL {
		{
			p.SetState(1235)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjCParserEQUAL || _la == ObjCParserNOTEQUAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1236)
			p.Relational_expression()
		}


		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IRelational_expressionContext is an interface to support dynamic dispatch.
type IRelational_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_expressionContext differentiates from other interfaces.
	IsRelational_expressionContext()
}

type Relational_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_expressionContext() *Relational_expressionContext {
	var p = new(Relational_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_relational_expression
	return p
}

func (*Relational_expressionContext) IsRelational_expressionContext() {}

func NewRelational_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_expressionContext {
	var p = new(Relational_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_relational_expression

	return p
}

func (s *Relational_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_expressionContext) AllShift_expression() []IShift_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem())
	var tst = make([]IShift_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_expressionContext)
		}
	}

	return tst
}

func (s *Relational_expressionContext) Shift_expression(i int) IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Relational_expressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserLT)
}

func (s *Relational_expressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserLT, i)
}

func (s *Relational_expressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserGT)
}

func (s *Relational_expressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserGT, i)
}

func (s *Relational_expressionContext) AllLE() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserLE)
}

func (s *Relational_expressionContext) LE(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserLE, i)
}

func (s *Relational_expressionContext) AllGE() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserGE)
}

func (s *Relational_expressionContext) GE(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserGE, i)
}

func (s *Relational_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Relational_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterRelational_expression(s)
	}
}

func (s *Relational_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitRelational_expression(s)
	}
}




func (p *ObjCParser) Relational_expression() (localctx IRelational_expressionContext) {
	localctx = NewRelational_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ObjCParserRULE_relational_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1242)
		p.Shift_expression()
	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 81)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 81))) & ((1 << (ObjCParserGT - 81)) | (1 << (ObjCParserLT - 81)) | (1 << (ObjCParserLE - 81)) | (1 << (ObjCParserGE - 81)))) != 0) {
		{
			p.SetState(1243)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 81)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 81))) & ((1 << (ObjCParserGT - 81)) | (1 << (ObjCParserLT - 81)) | (1 << (ObjCParserLE - 81)) | (1 << (ObjCParserGE - 81)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1244)
			p.Shift_expression()
		}


		p.SetState(1249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) AllAdditive_expression() []IAdditive_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem())
	var tst = make([]IAdditive_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditive_expressionContext)
		}
	}

	return tst
}

func (s *Shift_expressionContext) Additive_expression(i int) IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Shift_expressionContext) AllSHIFT_L() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserSHIFT_L)
}

func (s *Shift_expressionContext) SHIFT_L(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserSHIFT_L, i)
}

func (s *Shift_expressionContext) AllSHIFT_R() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserSHIFT_R)
}

func (s *Shift_expressionContext) SHIFT_R(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserSHIFT_R, i)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitShift_expression(s)
	}
}




func (p *ObjCParser) Shift_expression() (localctx IShift_expressionContext) {
	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ObjCParserRULE_shift_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1250)
		p.Additive_expression()
	}
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserSHIFT_R || _la == ObjCParserSHIFT_L {
		{
			p.SetState(1251)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjCParserSHIFT_R || _la == ObjCParserSHIFT_L) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1252)
			p.Additive_expression()
		}


		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAdditive_expressionContext is an interface to support dynamic dispatch.
type IAdditive_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditive_expressionContext differentiates from other interfaces.
	IsAdditive_expressionContext()
}

type Additive_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditive_expressionContext() *Additive_expressionContext {
	var p = new(Additive_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_additive_expression
	return p
}

func (*Additive_expressionContext) IsAdditive_expressionContext() {}

func NewAdditive_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Additive_expressionContext {
	var p = new(Additive_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_additive_expression

	return p
}

func (s *Additive_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Additive_expressionContext) AllMultiplicative_expression() []IMultiplicative_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem())
	var tst = make([]IMultiplicative_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicative_expressionContext)
		}
	}

	return tst
}

func (s *Additive_expressionContext) Multiplicative_expression(i int) IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Additive_expressionContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserADD)
}

func (s *Additive_expressionContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserADD, i)
}

func (s *Additive_expressionContext) AllSUB() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserSUB)
}

func (s *Additive_expressionContext) SUB(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserSUB, i)
}

func (s *Additive_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Additive_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Additive_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterAdditive_expression(s)
	}
}

func (s *Additive_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitAdditive_expression(s)
	}
}




func (p *ObjCParser) Additive_expression() (localctx IAdditive_expressionContext) {
	localctx = NewAdditive_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ObjCParserRULE_additive_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Multiplicative_expression()
	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserADD || _la == ObjCParserSUB {
		{
			p.SetState(1259)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjCParserADD || _la == ObjCParserSUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1260)
			p.Multiplicative_expression()
		}


		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IMultiplicative_expressionContext is an interface to support dynamic dispatch.
type IMultiplicative_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicative_expressionContext differentiates from other interfaces.
	IsMultiplicative_expressionContext()
}

type Multiplicative_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicative_expressionContext() *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_multiplicative_expression
	return p
}

func (*Multiplicative_expressionContext) IsMultiplicative_expressionContext() {}

func NewMultiplicative_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_multiplicative_expression

	return p
}

func (s *Multiplicative_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplicative_expressionContext) AllCast_expression() []ICast_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem())
	var tst = make([]ICast_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICast_expressionContext)
		}
	}

	return tst
}

func (s *Multiplicative_expressionContext) Cast_expression(i int) ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Multiplicative_expressionContext) AllMUL() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserMUL)
}

func (s *Multiplicative_expressionContext) MUL(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserMUL, i)
}

func (s *Multiplicative_expressionContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserDIV)
}

func (s *Multiplicative_expressionContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserDIV, i)
}

func (s *Multiplicative_expressionContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserMOD)
}

func (s *Multiplicative_expressionContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserMOD, i)
}

func (s *Multiplicative_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplicative_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Multiplicative_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterMultiplicative_expression(s)
	}
}

func (s *Multiplicative_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitMultiplicative_expression(s)
	}
}




func (p *ObjCParser) Multiplicative_expression() (localctx IMultiplicative_expressionContext) {
	localctx = NewMultiplicative_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ObjCParserRULE_multiplicative_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Cast_expression()
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 97)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 97))) & ((1 << (ObjCParserMUL - 97)) | (1 << (ObjCParserDIV - 97)) | (1 << (ObjCParserMOD - 97)))) != 0) {
		{
			p.SetState(1267)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 97)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 97))) & ((1 << (ObjCParserMUL - 97)) | (1 << (ObjCParserDIV - 97)) | (1 << (ObjCParserMOD - 97)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1268)
			p.Cast_expression()
		}


		p.SetState(1273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ICast_expressionContext is an interface to support dynamic dispatch.
type ICast_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCast_expressionContext differentiates from other interfaces.
	IsCast_expressionContext()
}

type Cast_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_expressionContext() *Cast_expressionContext {
	var p = new(Cast_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_cast_expression
	return p
}

func (*Cast_expressionContext) IsCast_expressionContext() {}

func NewCast_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_expressionContext {
	var p = new(Cast_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_cast_expression

	return p
}

func (s *Cast_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Cast_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Cast_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Cast_expressionContext) Cast_expression() ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Cast_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Cast_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cast_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterCast_expression(s)
	}
}

func (s *Cast_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitCast_expression(s)
	}
}




func (p *ObjCParser) Cast_expression() (localctx ICast_expressionContext) {
	localctx = NewCast_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ObjCParserRULE_cast_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1274)
			p.Match(ObjCParserLPAREN)
		}
		{
			p.SetState(1275)
			p.Type_name()
		}
		{
			p.SetState(1276)
			p.Match(ObjCParserRPAREN)
		}
		{
			p.SetState(1277)
			p.Cast_expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1279)
			p.Unary_expression()
		}

	}


	return localctx
}


// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Postfix_expression() IPostfix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfix_expressionContext)
}

func (s *Unary_expressionContext) INC() antlr.TerminalNode {
	return s.GetToken(ObjCParserINC, 0)
}

func (s *Unary_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Unary_expressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(ObjCParserDEC, 0)
}

func (s *Unary_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_expressionContext) Cast_expression() ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Unary_expressionContext) SIZEOF() antlr.TerminalNode {
	return s.GetToken(ObjCParserSIZEOF, 0)
}

func (s *Unary_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, 0)
}

func (s *Unary_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Unary_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, 0)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}




func (p *ObjCParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ObjCParserRULE_unary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1298)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjCParserENCODE, ObjCParserPROTOCOL, ObjCParserSELECTOR, ObjCParserSUPER, ObjCParserSELF, ObjCParserLPAREN, ObjCParserLBRACK, ObjCParserAT, ObjCParserCARET, ObjCParserIDENTIFIER, ObjCParserCHARACTER_LITERAL, ObjCParserSTRING_LITERAL, ObjCParserHEX_LITERAL, ObjCParserDECIMAL_LITERAL, ObjCParserOCTAL_LITERAL, ObjCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1282)
			p.Postfix_expression()
		}


	case ObjCParserINC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1283)
			p.Match(ObjCParserINC)
		}
		{
			p.SetState(1284)
			p.Unary_expression()
		}


	case ObjCParserDEC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1285)
			p.Match(ObjCParserDEC)
		}
		{
			p.SetState(1286)
			p.Unary_expression()
		}


	case ObjCParserBANG, ObjCParserTILDE, ObjCParserSUB, ObjCParserMUL, ObjCParserBITAND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1287)
			p.Unary_operator()
		}
		{
			p.SetState(1288)
			p.Cast_expression()
		}


	case ObjCParserSIZEOF:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1290)
			p.Match(ObjCParserSIZEOF)
		}
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1291)
				p.Match(ObjCParserLPAREN)
			}
			{
				p.SetState(1292)
				p.Type_name()
			}
			{
				p.SetState(1293)
				p.Match(ObjCParserRPAREN)
			}


		case 2:
			{
				p.SetState(1295)
				p.Unary_expression()
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) BITAND() antlr.TerminalNode {
	return s.GetToken(ObjCParserBITAND, 0)
}

func (s *Unary_operatorContext) MUL() antlr.TerminalNode {
	return s.GetToken(ObjCParserMUL, 0)
}

func (s *Unary_operatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(ObjCParserSUB, 0)
}

func (s *Unary_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ObjCParserTILDE, 0)
}

func (s *Unary_operatorContext) BANG() antlr.TerminalNode {
	return s.GetToken(ObjCParserBANG, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}




func (p *ObjCParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ObjCParserRULE_unary_operator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 83)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 83))) & ((1 << (ObjCParserBANG - 83)) | (1 << (ObjCParserTILDE - 83)) | (1 << (ObjCParserSUB - 83)) | (1 << (ObjCParserMUL - 83)) | (1 << (ObjCParserBITAND - 83)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IPostfix_expressionContext is an interface to support dynamic dispatch.
type IPostfix_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfix_expressionContext differentiates from other interfaces.
	IsPostfix_expressionContext()
}

type Postfix_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfix_expressionContext() *Postfix_expressionContext {
	var p = new(Postfix_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_postfix_expression
	return p
}

func (*Postfix_expressionContext) IsPostfix_expressionContext() {}

func NewPostfix_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Postfix_expressionContext {
	var p = new(Postfix_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_postfix_expression

	return p
}

func (s *Postfix_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Postfix_expressionContext) Primary_expression() IPrimary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_expressionContext)
}

func (s *Postfix_expressionContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserLBRACK)
}

func (s *Postfix_expressionContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserLBRACK, i)
}

func (s *Postfix_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Postfix_expressionContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserRBRACK)
}

func (s *Postfix_expressionContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserRBRACK, i)
}

func (s *Postfix_expressionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserLPAREN)
}

func (s *Postfix_expressionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserLPAREN, i)
}

func (s *Postfix_expressionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserRPAREN)
}

func (s *Postfix_expressionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserRPAREN, i)
}

func (s *Postfix_expressionContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserDOT)
}

func (s *Postfix_expressionContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserDOT, i)
}

func (s *Postfix_expressionContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Postfix_expressionContext) AllSTRUCTACCESS() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserSTRUCTACCESS)
}

func (s *Postfix_expressionContext) STRUCTACCESS(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserSTRUCTACCESS, i)
}

func (s *Postfix_expressionContext) AllINC() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserINC)
}

func (s *Postfix_expressionContext) INC(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserINC, i)
}

func (s *Postfix_expressionContext) AllDEC() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserDEC)
}

func (s *Postfix_expressionContext) DEC(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserDEC, i)
}

func (s *Postfix_expressionContext) AllArgument_expression_list() []IArgument_expression_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgument_expression_listContext)(nil)).Elem())
	var tst = make([]IArgument_expression_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgument_expression_listContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Argument_expression_list(i int) IArgument_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgument_expression_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgument_expression_listContext)
}

func (s *Postfix_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Postfix_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Postfix_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterPostfix_expression(s)
	}
}

func (s *Postfix_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitPostfix_expression(s)
	}
}




func (p *ObjCParser) Postfix_expression() (localctx IPostfix_expressionContext) {
	localctx = NewPostfix_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ObjCParserRULE_postfix_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Primary_expression()
	}
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 69)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 69))) & ((1 << (ObjCParserLPAREN - 69)) | (1 << (ObjCParserLBRACK - 69)) | (1 << (ObjCParserDOT - 69)) | (1 << (ObjCParserSTRUCTACCESS - 69)) | (1 << (ObjCParserINC - 69)) | (1 << (ObjCParserDEC - 69)))) != 0) {
		p.SetState(1318)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjCParserLBRACK:
			{
				p.SetState(1303)
				p.Match(ObjCParserLBRACK)
			}
			{
				p.SetState(1304)
				p.Expression()
			}
			{
				p.SetState(1305)
				p.Match(ObjCParserRBRACK)
			}


		case ObjCParserLPAREN:
			{
				p.SetState(1307)
				p.Match(ObjCParserLPAREN)
			}
			p.SetState(1309)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjCParserENCODE) | (1 << ObjCParserPROTOCOL) | (1 << ObjCParserSELECTOR) | (1 << ObjCParserSUPER) | (1 << ObjCParserSELF))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (ObjCParserSIZEOF - 55)) | (1 << (ObjCParserLPAREN - 55)) | (1 << (ObjCParserLBRACK - 55)) | (1 << (ObjCParserAT - 55)) | (1 << (ObjCParserBANG - 55)) | (1 << (ObjCParserTILDE - 55)))) != 0) || ((((_la - 93)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 93))) & ((1 << (ObjCParserINC - 93)) | (1 << (ObjCParserDEC - 93)) | (1 << (ObjCParserSUB - 93)) | (1 << (ObjCParserMUL - 93)) | (1 << (ObjCParserBITAND - 93)) | (1 << (ObjCParserCARET - 93)))) != 0) || ((((_la - 125)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 125))) & ((1 << (ObjCParserIDENTIFIER - 125)) | (1 << (ObjCParserCHARACTER_LITERAL - 125)) | (1 << (ObjCParserSTRING_LITERAL - 125)) | (1 << (ObjCParserHEX_LITERAL - 125)) | (1 << (ObjCParserDECIMAL_LITERAL - 125)) | (1 << (ObjCParserOCTAL_LITERAL - 125)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 125)))) != 0) {
				{
					p.SetState(1308)
					p.Argument_expression_list()
				}

			}
			{
				p.SetState(1311)
				p.Match(ObjCParserRPAREN)
			}


		case ObjCParserDOT:
			{
				p.SetState(1312)
				p.Match(ObjCParserDOT)
			}
			{
				p.SetState(1313)
				p.Identifier()
			}


		case ObjCParserSTRUCTACCESS:
			{
				p.SetState(1314)
				p.Match(ObjCParserSTRUCTACCESS)
			}
			{
				p.SetState(1315)
				p.Identifier()
			}


		case ObjCParserINC:
			{
				p.SetState(1316)
				p.Match(ObjCParserINC)
			}


		case ObjCParserDEC:
			{
				p.SetState(1317)
				p.Match(ObjCParserDEC)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArgument_expression_listContext is an interface to support dynamic dispatch.
type IArgument_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgument_expression_listContext differentiates from other interfaces.
	IsArgument_expression_listContext()
}

type Argument_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgument_expression_listContext() *Argument_expression_listContext {
	var p = new(Argument_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_argument_expression_list
	return p
}

func (*Argument_expression_listContext) IsArgument_expression_listContext() {}

func NewArgument_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Argument_expression_listContext {
	var p = new(Argument_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_argument_expression_list

	return p
}

func (s *Argument_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Argument_expression_listContext) AllAssignment_expression() []IAssignment_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem())
	var tst = make([]IAssignment_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignment_expressionContext)
		}
	}

	return tst
}

func (s *Argument_expression_listContext) Assignment_expression(i int) IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Argument_expression_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ObjCParserCOMMA)
}

func (s *Argument_expression_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ObjCParserCOMMA, i)
}

func (s *Argument_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Argument_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Argument_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterArgument_expression_list(s)
	}
}

func (s *Argument_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitArgument_expression_list(s)
	}
}




func (p *ObjCParser) Argument_expression_list() (localctx IArgument_expression_listContext) {
	localctx = NewArgument_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ObjCParserRULE_argument_expression_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1323)
		p.Assignment_expression()
	}
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjCParserCOMMA {
		{
			p.SetState(1324)
			p.Match(ObjCParserCOMMA)
		}
		{
			p.SetState(1325)
			p.Assignment_expression()
		}


		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjCParserIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitIdentifier(s)
	}
}




func (p *ObjCParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ObjCParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Match(ObjCParserIDENTIFIER)
	}



	return localctx
}


// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjCParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjCParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserDECIMAL_LITERAL, 0)
}

func (s *ConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserHEX_LITERAL, 0)
}

func (s *ConstantContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserOCTAL_LITERAL, 0)
}

func (s *ConstantContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserCHARACTER_LITERAL, 0)
}

func (s *ConstantContext) FLOATING_POINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjCParserFLOATING_POINT_LITERAL, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjCListener); ok {
		listenerT.ExitConstant(s)
	}
}




func (p *ObjCParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ObjCParserRULE_constant)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1333)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 126)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 126))) & ((1 << (ObjCParserCHARACTER_LITERAL - 126)) | (1 << (ObjCParserHEX_LITERAL - 126)) | (1 << (ObjCParserDECIMAL_LITERAL - 126)) | (1 << (ObjCParserOCTAL_LITERAL - 126)) | (1 << (ObjCParserFLOATING_POINT_LITERAL - 126)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


