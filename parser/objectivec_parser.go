// Code generated from ObjectiveC.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // ObjectiveC

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 126, 1060, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4, 
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97, 
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102, 
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106, 
	4, 107, 9, 107, 3, 2, 6, 2, 216, 10, 2, 13, 2, 14, 2, 217, 3, 2, 3, 2, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	5, 3, 234, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 251, 10, 4, 3, 5, 3, 5, 3, 5, 
	5, 5, 256, 10, 5, 6, 5, 258, 10, 5, 13, 5, 14, 5, 259, 3, 5, 3, 5, 3, 6, 
	3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 270, 10, 7, 3, 7, 5, 7, 273, 10, 7, 
	3, 7, 5, 7, 276, 10, 7, 3, 7, 5, 7, 279, 10, 7, 3, 7, 3, 7, 3, 8, 3, 8, 
	3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 289, 10, 8, 3, 8, 5, 8, 292, 10, 8, 3, 8, 
	3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 300, 10, 9, 3, 9, 5, 9, 303, 10, 9, 
	3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 313, 10, 10, 
	3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 5, 11, 320, 10, 11, 3, 11, 5, 11, 323, 
	10, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 
	3, 13, 3, 14, 3, 14, 3, 14, 7, 14, 338, 10, 14, 12, 14, 14, 14, 341, 11, 
	14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 7, 16, 350, 10, 16, 
	12, 16, 14, 16, 353, 11, 16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 19, 3, 19, 
	3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 22, 6, 
	22, 371, 10, 22, 13, 22, 14, 22, 372, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 
	6, 24, 380, 10, 24, 13, 24, 14, 24, 381, 3, 25, 3, 25, 3, 25, 3, 26, 3, 
	26, 3, 26, 3, 27, 5, 27, 391, 10, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 
	3, 28, 3, 28, 6, 28, 400, 10, 28, 13, 28, 14, 28, 401, 3, 29, 3, 29, 3, 
	29, 3, 30, 3, 30, 3, 30, 3, 31, 5, 31, 411, 10, 31, 3, 31, 3, 31, 5, 31, 
	415, 10, 31, 3, 31, 3, 31, 3, 32, 3, 32, 6, 32, 421, 10, 32, 13, 32, 14, 
	32, 422, 3, 32, 5, 32, 426, 10, 32, 5, 32, 428, 10, 32, 3, 33, 5, 33, 431, 
	10, 33, 3, 33, 3, 33, 7, 33, 435, 10, 33, 12, 33, 14, 33, 438, 11, 33, 
	3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 
	36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 459, 
	10, 36, 3, 36, 3, 36, 5, 36, 463, 10, 36, 3, 36, 3, 36, 3, 36, 5, 36, 468, 
	10, 36, 3, 37, 3, 37, 3, 37, 5, 37, 473, 10, 37, 3, 38, 3, 38, 3, 39, 3, 
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 
	5, 39, 489, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 
	41, 5, 41, 499, 10, 41, 3, 42, 3, 42, 6, 42, 503, 10, 42, 13, 42, 14, 42, 
	504, 5, 42, 507, 10, 42, 3, 43, 5, 43, 510, 10, 43, 3, 43, 3, 43, 3, 43, 
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 5, 45, 522, 10, 45, 3, 
	45, 6, 45, 525, 10, 45, 13, 45, 14, 45, 526, 5, 45, 529, 10, 45, 3, 46, 
	3, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 
	48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 
	3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 5, 53, 562, 
	10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 
	3, 55, 3, 56, 3, 56, 5, 56, 576, 10, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 
	57, 6, 57, 583, 10, 57, 13, 57, 14, 57, 584, 3, 58, 3, 58, 3, 59, 3, 59, 
	3, 59, 7, 59, 592, 10, 59, 12, 59, 14, 59, 595, 11, 59, 3, 60, 3, 60, 3, 
	60, 5, 60, 600, 10, 60, 3, 61, 3, 61, 3, 61, 5, 61, 605, 10, 61, 3, 61, 
	3, 61, 6, 61, 609, 10, 61, 13, 61, 14, 61, 610, 3, 61, 3, 61, 5, 61, 615, 
	10, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 6, 63, 623, 10, 63, 13, 
	63, 14, 63, 624, 3, 64, 3, 64, 3, 64, 7, 64, 630, 10, 64, 12, 64, 14, 64, 
	633, 11, 64, 3, 65, 3, 65, 5, 65, 637, 10, 65, 3, 65, 3, 65, 5, 65, 641, 
	10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 649, 10, 66, 3, 
	66, 3, 66, 3, 66, 3, 66, 5, 66, 655, 10, 66, 3, 67, 3, 67, 3, 67, 7, 67, 
	660, 10, 67, 12, 67, 14, 67, 663, 11, 67, 3, 68, 3, 68, 3, 68, 5, 68, 668, 
	10, 68, 3, 69, 3, 69, 7, 69, 672, 10, 69, 12, 69, 14, 69, 675, 11, 69, 
	3, 69, 3, 69, 5, 69, 679, 10, 69, 3, 70, 3, 70, 7, 70, 683, 10, 70, 12, 
	70, 14, 70, 686, 11, 70, 3, 70, 3, 70, 3, 70, 3, 70, 7, 70, 692, 10, 70, 
	12, 70, 14, 70, 695, 11, 70, 5, 70, 697, 10, 70, 3, 71, 3, 71, 5, 71, 701, 
	10, 71, 3, 71, 3, 71, 3, 71, 5, 71, 706, 10, 71, 3, 71, 5, 71, 709, 10, 
	71, 3, 72, 3, 72, 3, 72, 5, 72, 714, 10, 72, 3, 73, 3, 73, 5, 73, 718, 
	10, 73, 3, 73, 5, 73, 721, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 7, 
	74, 728, 10, 74, 12, 74, 14, 74, 731, 11, 74, 3, 74, 3, 74, 5, 74, 735, 
	10, 74, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 7, 76, 742, 10, 76, 12, 76, 
	14, 76, 745, 11, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 6, 76, 752, 10, 
	76, 13, 76, 14, 76, 753, 3, 76, 3, 76, 5, 76, 758, 10, 76, 3, 76, 6, 76, 
	761, 10, 76, 13, 76, 14, 76, 762, 3, 76, 5, 76, 766, 10, 76, 3, 77, 3, 
	77, 5, 77, 770, 10, 77, 3, 77, 3, 77, 3, 77, 5, 77, 775, 10, 77, 3, 77, 
	5, 77, 778, 10, 77, 3, 78, 3, 78, 3, 78, 7, 78, 783, 10, 78, 12, 78, 14, 
	78, 786, 11, 78, 3, 79, 6, 79, 789, 10, 79, 13, 79, 14, 79, 790, 3, 80, 
	3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 802, 10, 
	80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 
	3, 81, 3, 81, 5, 81, 816, 10, 81, 3, 82, 3, 82, 7, 82, 820, 10, 82, 12, 
	82, 14, 82, 823, 11, 82, 3, 82, 5, 82, 826, 10, 82, 3, 82, 3, 82, 3, 83, 
	3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 837, 10, 83, 3, 83, 3, 
	83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 845, 10, 83, 3, 84, 3, 84, 3, 84, 
	3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 
	84, 3, 84, 3, 84, 3, 84, 5, 84, 864, 10, 84, 3, 84, 3, 84, 5, 84, 868, 
	10, 84, 3, 84, 3, 84, 5, 84, 872, 10, 84, 3, 84, 3, 84, 5, 84, 876, 10, 
	84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 
	5, 85, 888, 10, 85, 3, 85, 5, 85, 891, 10, 85, 3, 86, 3, 86, 3, 86, 7, 
	86, 896, 10, 86, 12, 86, 14, 86, 899, 11, 86, 3, 87, 3, 87, 3, 87, 3, 87, 
	5, 87, 905, 10, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 
	89, 5, 89, 915, 10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 7, 91, 922, 
	10, 91, 12, 91, 14, 91, 925, 11, 91, 3, 92, 3, 92, 3, 92, 7, 92, 930, 10, 
	92, 12, 92, 14, 92, 933, 11, 92, 3, 93, 3, 93, 3, 93, 7, 93, 938, 10, 93, 
	12, 93, 14, 93, 941, 11, 93, 3, 94, 3, 94, 3, 94, 7, 94, 946, 10, 94, 12, 
	94, 14, 94, 949, 11, 94, 3, 95, 3, 95, 3, 95, 7, 95, 954, 10, 95, 12, 95, 
	14, 95, 957, 11, 95, 3, 96, 3, 96, 3, 96, 7, 96, 962, 10, 96, 12, 96, 14, 
	96, 965, 11, 96, 3, 97, 3, 97, 3, 97, 7, 97, 970, 10, 97, 12, 97, 14, 97, 
	973, 11, 97, 3, 98, 3, 98, 3, 98, 7, 98, 978, 10, 98, 12, 98, 14, 98, 981, 
	11, 98, 3, 99, 3, 99, 3, 99, 7, 99, 986, 10, 99, 12, 99, 14, 99, 989, 11, 
	99, 3, 100, 3, 100, 3, 100, 7, 100, 994, 10, 100, 12, 100, 14, 100, 997, 
	11, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1005, 
	10, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1021, 10, 102, 
	5, 102, 1023, 10, 102, 3, 103, 3, 103, 3, 104, 3, 104, 3, 104, 3, 104, 
	3, 104, 3, 104, 3, 104, 5, 104, 1034, 10, 104, 3, 104, 3, 104, 3, 104, 
	3, 104, 3, 104, 3, 104, 3, 104, 7, 104, 1043, 10, 104, 12, 104, 14, 104, 
	1046, 11, 104, 3, 105, 3, 105, 3, 105, 7, 105, 1051, 10, 105, 12, 105, 
	14, 105, 1054, 11, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 2, 2, 108, 
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 
	200, 202, 204, 206, 208, 210, 212, 2, 17, 3, 2, 11, 12, 3, 2, 13, 15, 4, 
	2, 12, 12, 16, 16, 3, 2, 30, 33, 3, 2, 48, 53, 3, 2, 65, 69, 3, 2, 71, 
	72, 4, 2, 70, 70, 88, 97, 3, 2, 104, 105, 5, 2, 11, 11, 16, 16, 106, 107, 
	3, 2, 108, 109, 3, 2, 34, 35, 5, 2, 13, 13, 74, 74, 110, 110, 6, 2, 35, 
	35, 74, 74, 103, 103, 114, 115, 4, 2, 118, 118, 120, 123, 2, 1129, 2, 215, 
	3, 2, 2, 2, 4, 233, 3, 2, 2, 2, 6, 250, 3, 2, 2, 2, 8, 252, 3, 2, 2, 2, 
	10, 263, 3, 2, 2, 2, 12, 265, 3, 2, 2, 2, 14, 282, 3, 2, 2, 2, 16, 295, 
	3, 2, 2, 2, 18, 306, 3, 2, 2, 2, 20, 316, 3, 2, 2, 2, 22, 326, 3, 2, 2, 
	2, 24, 330, 3, 2, 2, 2, 26, 334, 3, 2, 2, 2, 28, 342, 3, 2, 2, 2, 30, 346, 
	3, 2, 2, 2, 32, 354, 3, 2, 2, 2, 34, 356, 3, 2, 2, 2, 36, 358, 3, 2, 2, 
	2, 38, 360, 3, 2, 2, 2, 40, 362, 3, 2, 2, 2, 42, 370, 3, 2, 2, 2, 44, 374, 
	3, 2, 2, 2, 46, 379, 3, 2, 2, 2, 48, 383, 3, 2, 2, 2, 50, 386, 3, 2, 2, 
	2, 52, 390, 3, 2, 2, 2, 54, 399, 3, 2, 2, 2, 56, 403, 3, 2, 2, 2, 58, 406, 
	3, 2, 2, 2, 60, 410, 3, 2, 2, 2, 62, 427, 3, 2, 2, 2, 64, 430, 3, 2, 2, 
	2, 66, 441, 3, 2, 2, 2, 68, 443, 3, 2, 2, 2, 70, 467, 3, 2, 2, 2, 72, 472, 
	3, 2, 2, 2, 74, 474, 3, 2, 2, 2, 76, 488, 3, 2, 2, 2, 78, 490, 3, 2, 2, 
	2, 80, 498, 3, 2, 2, 2, 82, 506, 3, 2, 2, 2, 84, 509, 3, 2, 2, 2, 86, 514, 
	3, 2, 2, 2, 88, 528, 3, 2, 2, 2, 90, 530, 3, 2, 2, 2, 92, 535, 3, 2, 2, 
	2, 94, 540, 3, 2, 2, 2, 96, 542, 3, 2, 2, 2, 98, 544, 3, 2, 2, 2, 100, 
	550, 3, 2, 2, 2, 102, 553, 3, 2, 2, 2, 104, 558, 3, 2, 2, 2, 106, 563, 
	3, 2, 2, 2, 108, 569, 3, 2, 2, 2, 110, 573, 3, 2, 2, 2, 112, 582, 3, 2, 
	2, 2, 114, 586, 3, 2, 2, 2, 116, 588, 3, 2, 2, 2, 118, 596, 3, 2, 2, 2, 
	120, 601, 3, 2, 2, 2, 122, 616, 3, 2, 2, 2, 124, 622, 3, 2, 2, 2, 126, 
	626, 3, 2, 2, 2, 128, 640, 3, 2, 2, 2, 130, 642, 3, 2, 2, 2, 132, 656, 
	3, 2, 2, 2, 134, 664, 3, 2, 2, 2, 136, 678, 3, 2, 2, 2, 138, 696, 3, 2, 
	2, 2, 140, 708, 3, 2, 2, 2, 142, 710, 3, 2, 2, 2, 144, 715, 3, 2, 2, 2, 
	146, 734, 3, 2, 2, 2, 148, 736, 3, 2, 2, 2, 150, 765, 3, 2, 2, 2, 152, 
	777, 3, 2, 2, 2, 154, 779, 3, 2, 2, 2, 156, 788, 3, 2, 2, 2, 158, 801, 
	3, 2, 2, 2, 160, 815, 3, 2, 2, 2, 162, 817, 3, 2, 2, 2, 164, 844, 3, 2, 
	2, 2, 166, 875, 3, 2, 2, 2, 168, 890, 3, 2, 2, 2, 170, 892, 3, 2, 2, 2, 
	172, 900, 3, 2, 2, 2, 174, 906, 3, 2, 2, 2, 176, 908, 3, 2, 2, 2, 178, 
	916, 3, 2, 2, 2, 180, 918, 3, 2, 2, 2, 182, 926, 3, 2, 2, 2, 184, 934, 
	3, 2, 2, 2, 186, 942, 3, 2, 2, 2, 188, 950, 3, 2, 2, 2, 190, 958, 3, 2, 
	2, 2, 192, 966, 3, 2, 2, 2, 194, 974, 3, 2, 2, 2, 196, 982, 3, 2, 2, 2, 
	198, 990, 3, 2, 2, 2, 200, 1004, 3, 2, 2, 2, 202, 1022, 3, 2, 2, 2, 204, 
	1024, 3, 2, 2, 2, 206, 1026, 3, 2, 2, 2, 208, 1047, 3, 2, 2, 2, 210, 1055, 
	3, 2, 2, 2, 212, 1057, 3, 2, 2, 2, 214, 216, 5, 4, 3, 2, 215, 214, 3, 2, 
	2, 2, 216, 217, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2, 
	218, 219, 3, 2, 2, 2, 219, 220, 7, 2, 2, 3, 220, 3, 3, 2, 2, 2, 221, 234, 
	7, 125, 2, 2, 222, 234, 7, 126, 2, 2, 223, 234, 5, 6, 4, 2, 224, 234, 5, 
	108, 55, 2, 225, 234, 5, 110, 56, 2, 226, 234, 5, 12, 7, 2, 227, 234, 5, 
	16, 9, 2, 228, 234, 5, 14, 8, 2, 229, 234, 5, 18, 10, 2, 230, 234, 5, 20, 
	11, 2, 231, 234, 5, 22, 12, 2, 232, 234, 5, 24, 13, 2, 233, 221, 3, 2, 
	2, 2, 233, 222, 3, 2, 2, 2, 233, 223, 3, 2, 2, 2, 233, 224, 3, 2, 2, 2, 
	233, 225, 3, 2, 2, 2, 233, 226, 3, 2, 2, 2, 233, 227, 3, 2, 2, 2, 233, 
	228, 3, 2, 2, 2, 233, 229, 3, 2, 2, 2, 233, 230, 3, 2, 2, 2, 233, 231, 
	3, 2, 2, 2, 233, 232, 3, 2, 2, 2, 234, 5, 3, 2, 2, 2, 235, 236, 7, 3, 2, 
	2, 236, 251, 5, 8, 5, 2, 237, 238, 7, 4, 2, 2, 238, 251, 5, 8, 5, 2, 239, 
	240, 7, 5, 2, 2, 240, 251, 5, 10, 6, 2, 241, 242, 7, 6, 2, 2, 242, 251, 
	5, 170, 86, 2, 243, 244, 7, 7, 2, 2, 244, 251, 5, 170, 86, 2, 245, 246, 
	7, 8, 2, 2, 246, 251, 5, 170, 86, 2, 247, 248, 7, 9, 2, 2, 248, 251, 5, 
	170, 86, 2, 249, 251, 7, 10, 2, 2, 250, 235, 3, 2, 2, 2, 250, 237, 3, 2, 
	2, 2, 250, 239, 3, 2, 2, 2, 250, 241, 3, 2, 2, 2, 250, 243, 3, 2, 2, 2, 
	250, 245, 3, 2, 2, 2, 250, 247, 3, 2, 2, 2, 250, 249, 3, 2, 2, 2, 251, 
	7, 3, 2, 2, 2, 252, 257, 9, 2, 2, 2, 253, 255, 7, 117, 2, 2, 254, 256, 
	9, 3, 2, 2, 255, 254, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2, 256, 258, 3, 2, 
	2, 2, 257, 253, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259, 257, 3, 2, 2, 2, 
	259, 260, 3, 2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 262, 9, 4, 2, 2, 262, 
	9, 3, 2, 2, 2, 263, 264, 7, 17, 2, 2, 264, 11, 3, 2, 2, 2, 265, 266, 7, 
	18, 2, 2, 266, 269, 5, 32, 17, 2, 267, 268, 7, 19, 2, 2, 268, 270, 5, 34, 
	18, 2, 269, 267, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 272, 3, 2, 2, 2, 
	271, 273, 5, 28, 15, 2, 272, 271, 3, 2, 2, 2, 272, 273, 3, 2, 2, 2, 273, 
	275, 3, 2, 2, 2, 274, 276, 5, 40, 21, 2, 275, 274, 3, 2, 2, 2, 275, 276, 
	3, 2, 2, 2, 276, 278, 3, 2, 2, 2, 277, 279, 5, 46, 24, 2, 278, 277, 3, 
	2, 2, 2, 278, 279, 3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280, 281, 7, 20, 2, 
	2, 281, 13, 3, 2, 2, 2, 282, 283, 7, 18, 2, 2, 283, 284, 5, 32, 17, 2, 
	284, 285, 7, 21, 2, 2, 285, 286, 5, 36, 19, 2, 286, 288, 7, 22, 2, 2, 287, 
	289, 5, 28, 15, 2, 288, 287, 3, 2, 2, 2, 288, 289, 3, 2, 2, 2, 289, 291, 
	3, 2, 2, 2, 290, 292, 5, 46, 24, 2, 291, 290, 3, 2, 2, 2, 291, 292, 3, 
	2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 294, 7, 20, 2, 2, 294, 15, 3, 2, 2, 
	2, 295, 296, 7, 23, 2, 2, 296, 299, 5, 32, 17, 2, 297, 298, 7, 19, 2, 2, 
	298, 300, 5, 34, 18, 2, 299, 297, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 
	302, 3, 2, 2, 2, 301, 303, 5, 54, 28, 2, 302, 301, 3, 2, 2, 2, 302, 303, 
	3, 2, 2, 2, 303, 304, 3, 2, 2, 2, 304, 305, 7, 20, 2, 2, 305, 17, 3, 2, 
	2, 2, 306, 307, 7, 23, 2, 2, 307, 308, 5, 32, 17, 2, 308, 309, 7, 21, 2, 
	2, 309, 310, 5, 36, 19, 2, 310, 312, 7, 22, 2, 2, 311, 313, 5, 54, 28, 
	2, 312, 311, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 314, 3, 2, 2, 2, 314, 
	315, 7, 20, 2, 2, 315, 19, 3, 2, 2, 2, 316, 317, 7, 24, 2, 2, 317, 319, 
	5, 38, 20, 2, 318, 320, 5, 28, 15, 2, 319, 318, 3, 2, 2, 2, 319, 320, 3, 
	2, 2, 2, 320, 322, 3, 2, 2, 2, 321, 323, 5, 46, 24, 2, 322, 321, 3, 2, 
	2, 2, 322, 323, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324, 325, 7, 20, 2, 2, 
	325, 21, 3, 2, 2, 2, 326, 327, 7, 24, 2, 2, 327, 328, 5, 30, 16, 2, 328, 
	329, 7, 25, 2, 2, 329, 23, 3, 2, 2, 2, 330, 331, 7, 26, 2, 2, 331, 332, 
	5, 26, 14, 2, 332, 333, 7, 25, 2, 2, 333, 25, 3, 2, 2, 2, 334, 339, 5, 
	32, 17, 2, 335, 336, 7, 27, 2, 2, 336, 338, 5, 32, 17, 2, 337, 335, 3, 
	2, 2, 2, 338, 341, 3, 2, 2, 2, 339, 337, 3, 2, 2, 2, 339, 340, 3, 2, 2, 
	2, 340, 27, 3, 2, 2, 2, 341, 339, 3, 2, 2, 2, 342, 343, 7, 11, 2, 2, 343, 
	344, 5, 30, 16, 2, 344, 345, 7, 16, 2, 2, 345, 29, 3, 2, 2, 2, 346, 351, 
	5, 38, 20, 2, 347, 348, 7, 27, 2, 2, 348, 350, 5, 38, 20, 2, 349, 347, 
	3, 2, 2, 2, 350, 353, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351, 352, 3, 2, 
	2, 2, 352, 31, 3, 2, 2, 2, 353, 351, 3, 2, 2, 2, 354, 355, 7, 117, 2, 2, 
	355, 33, 3, 2, 2, 2, 356, 357, 7, 117, 2, 2, 357, 35, 3, 2, 2, 2, 358, 
	359, 7, 117, 2, 2, 359, 37, 3, 2, 2, 2, 360, 361, 7, 117, 2, 2, 361, 39, 
	3, 2, 2, 2, 362, 363, 7, 28, 2, 2, 363, 364, 5, 42, 22, 2, 364, 365, 7, 
	29, 2, 2, 365, 41, 3, 2, 2, 2, 366, 371, 5, 44, 23, 2, 367, 368, 5, 126, 
	64, 2, 368, 369, 5, 40, 21, 2, 369, 371, 3, 2, 2, 2, 370, 366, 3, 2, 2, 
	2, 370, 367, 3, 2, 2, 2, 371, 372, 3, 2, 2, 2, 372, 370, 3, 2, 2, 2, 372, 
	373, 3, 2, 2, 2, 373, 43, 3, 2, 2, 2, 374, 375, 9, 5, 2, 2, 375, 45, 3, 
	2, 2, 2, 376, 380, 5, 110, 56, 2, 377, 380, 5, 48, 25, 2, 378, 380, 5, 
	50, 26, 2, 379, 376, 3, 2, 2, 2, 379, 377, 3, 2, 2, 2, 379, 378, 3, 2, 
	2, 2, 380, 381, 3, 2, 2, 2, 381, 379, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 
	382, 47, 3, 2, 2, 2, 383, 384, 7, 34, 2, 2, 384, 385, 5, 52, 27, 2, 385, 
	49, 3, 2, 2, 2, 386, 387, 7, 35, 2, 2, 387, 388, 5, 52, 27, 2, 388, 51, 
	3, 2, 2, 2, 389, 391, 5, 68, 35, 2, 390, 389, 3, 2, 2, 2, 390, 391, 3, 
	2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 393, 5, 62, 32, 2, 393, 394, 7, 25, 
	2, 2, 394, 53, 3, 2, 2, 2, 395, 400, 5, 108, 55, 2, 396, 400, 5, 110, 56, 
	2, 397, 400, 5, 56, 29, 2, 398, 400, 5, 58, 30, 2, 399, 395, 3, 2, 2, 2, 
	399, 396, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 399, 398, 3, 2, 2, 2, 400, 
	401, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 55, 3, 
	2, 2, 2, 403, 404, 7, 34, 2, 2, 404, 405, 5, 60, 31, 2, 405, 57, 3, 2, 
	2, 2, 406, 407, 7, 35, 2, 2, 407, 408, 5, 60, 31, 2, 408, 59, 3, 2, 2, 
	2, 409, 411, 5, 68, 35, 2, 410, 409, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 
	411, 412, 3, 2, 2, 2, 412, 414, 5, 62, 32, 2, 413, 415, 5, 116, 59, 2, 
	414, 413, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 
	417, 5, 162, 82, 2, 417, 61, 3, 2, 2, 2, 418, 428, 5, 66, 34, 2, 419, 421, 
	5, 64, 33, 2, 420, 419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 420, 3, 
	2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 425, 3, 2, 2, 2, 424, 426, 5, 142, 
	72, 2, 425, 424, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 428, 3, 2, 2, 2, 
	427, 418, 3, 2, 2, 2, 427, 420, 3, 2, 2, 2, 428, 63, 3, 2, 2, 2, 429, 431, 
	5, 66, 34, 2, 430, 429, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 432, 3, 
	2, 2, 2, 432, 436, 7, 19, 2, 2, 433, 435, 5, 68, 35, 2, 434, 433, 3, 2, 
	2, 2, 435, 438, 3, 2, 2, 2, 436, 434, 3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 
	437, 439, 3, 2, 2, 2, 438, 436, 3, 2, 2, 2, 439, 440, 7, 117, 2, 2, 440, 
	65, 3, 2, 2, 2, 441, 442, 7, 117, 2, 2, 442, 67, 3, 2, 2, 2, 443, 444, 
	7, 21, 2, 2, 444, 445, 5, 148, 75, 2, 445, 446, 7, 22, 2, 2, 446, 69, 3, 
	2, 2, 2, 447, 468, 7, 36, 2, 2, 448, 468, 7, 37, 2, 2, 449, 468, 7, 38, 
	2, 2, 450, 468, 7, 39, 2, 2, 451, 468, 7, 40, 2, 2, 452, 468, 7, 41, 2, 
	2, 453, 468, 7, 42, 2, 2, 454, 468, 7, 43, 2, 2, 455, 468, 7, 44, 2, 2, 
	456, 458, 7, 45, 2, 2, 457, 459, 5, 28, 15, 2, 458, 457, 3, 2, 2, 2, 458, 
	459, 3, 2, 2, 2, 459, 468, 3, 2, 2, 2, 460, 462, 5, 32, 17, 2, 461, 463, 
	5, 28, 15, 2, 462, 461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 468, 3, 
	2, 2, 2, 464, 468, 5, 120, 61, 2, 465, 468, 5, 130, 66, 2, 466, 468, 7, 
	117, 2, 2, 467, 447, 3, 2, 2, 2, 467, 448, 3, 2, 2, 2, 467, 449, 3, 2, 
	2, 2, 467, 450, 3, 2, 2, 2, 467, 451, 3, 2, 2, 2, 467, 452, 3, 2, 2, 2, 
	467, 453, 3, 2, 2, 2, 467, 454, 3, 2, 2, 2, 467, 455, 3, 2, 2, 2, 467, 
	456, 3, 2, 2, 2, 467, 460, 3, 2, 2, 2, 467, 464, 3, 2, 2, 2, 467, 465, 
	3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 71, 3, 2, 2, 2, 469, 473, 7, 46, 
	2, 2, 470, 473, 7, 47, 2, 2, 471, 473, 5, 74, 38, 2, 472, 469, 3, 2, 2, 
	2, 472, 470, 3, 2, 2, 2, 472, 471, 3, 2, 2, 2, 473, 73, 3, 2, 2, 2, 474, 
	475, 9, 6, 2, 2, 475, 75, 3, 2, 2, 2, 476, 489, 7, 117, 2, 2, 477, 489, 
	5, 212, 107, 2, 478, 489, 7, 119, 2, 2, 479, 480, 7, 21, 2, 2, 480, 481, 
	5, 170, 86, 2, 481, 482, 7, 22, 2, 2, 482, 489, 3, 2, 2, 2, 483, 489, 7, 
	54, 2, 2, 484, 489, 5, 78, 40, 2, 485, 489, 5, 86, 44, 2, 486, 489, 5, 
	90, 46, 2, 487, 489, 5, 92, 47, 2, 488, 476, 3, 2, 2, 2, 488, 477, 3, 2, 
	2, 2, 488, 478, 3, 2, 2, 2, 488, 479, 3, 2, 2, 2, 488, 483, 3, 2, 2, 2, 
	488, 484, 3, 2, 2, 2, 488, 485, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 488, 
	487, 3, 2, 2, 2, 489, 77, 3, 2, 2, 2, 490, 491, 7, 55, 2, 2, 491, 492, 
	5, 80, 41, 2, 492, 493, 5, 82, 42, 2, 493, 494, 7, 56, 2, 2, 494, 79, 3, 
	2, 2, 2, 495, 499, 5, 170, 86, 2, 496, 499, 5, 32, 17, 2, 497, 499, 7, 
	57, 2, 2, 498, 495, 3, 2, 2, 2, 498, 496, 3, 2, 2, 2, 498, 497, 3, 2, 2, 
	2, 499, 81, 3, 2, 2, 2, 500, 507, 5, 66, 34, 2, 501, 503, 5, 84, 43, 2, 
	502, 501, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 502, 3, 2, 2, 2, 504, 
	505, 3, 2, 2, 2, 505, 507, 3, 2, 2, 2, 506, 500, 3, 2, 2, 2, 506, 502, 
	3, 2, 2, 2, 507, 83, 3, 2, 2, 2, 508, 510, 5, 66, 34, 2, 509, 508, 3, 2, 
	2, 2, 509, 510, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 512, 7, 19, 2, 2, 
	512, 513, 5, 170, 86, 2, 513, 85, 3, 2, 2, 2, 514, 515, 7, 58, 2, 2, 515, 
	516, 7, 21, 2, 2, 516, 517, 5, 88, 45, 2, 517, 518, 7, 22, 2, 2, 518, 87, 
	3, 2, 2, 2, 519, 529, 5, 66, 34, 2, 520, 522, 5, 66, 34, 2, 521, 520, 3, 
	2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 525, 7, 19, 2, 
	2, 524, 521, 3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526, 524, 3, 2, 2, 2, 526, 
	527, 3, 2, 2, 2, 527, 529, 3, 2, 2, 2, 528, 519, 3, 2, 2, 2, 528, 524, 
	3, 2, 2, 2, 529, 89, 3, 2, 2, 2, 530, 531, 7, 24, 2, 2, 531, 532, 7, 21, 
	2, 2, 532, 533, 5, 38, 20, 2, 533, 534, 7, 22, 2, 2, 534, 91, 3, 2, 2, 
	2, 535, 536, 7, 59, 2, 2, 536, 537, 7, 21, 2, 2, 537, 538, 5, 148, 75, 
	2, 538, 539, 7, 22, 2, 2, 539, 93, 3, 2, 2, 2, 540, 541, 5, 136, 69, 2, 
	541, 95, 3, 2, 2, 2, 542, 543, 7, 60, 2, 2, 543, 97, 3, 2, 2, 2, 544, 545, 
	7, 61, 2, 2, 545, 546, 7, 21, 2, 2, 546, 547, 5, 94, 48, 2, 547, 548, 7, 
	22, 2, 2, 548, 549, 5, 158, 80, 2, 549, 99, 3, 2, 2, 2, 550, 551, 7, 62, 
	2, 2, 551, 552, 5, 158, 80, 2, 552, 101, 3, 2, 2, 2, 553, 554, 7, 63, 2, 
	2, 554, 555, 7, 21, 2, 2, 555, 556, 7, 117, 2, 2, 556, 557, 7, 22, 2, 2, 
	557, 103, 3, 2, 2, 2, 558, 559, 5, 96, 49, 2, 559, 561, 5, 98, 50, 2, 560, 
	562, 5, 100, 51, 2, 561, 560, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562, 105, 
	3, 2, 2, 2, 563, 564, 7, 64, 2, 2, 564, 565, 7, 21, 2, 2, 565, 566, 7, 
	117, 2, 2, 566, 567, 7, 22, 2, 2, 567, 568, 5, 158, 80, 2, 568, 107, 3, 
	2, 2, 2, 569, 570, 5, 112, 57, 2, 570, 571, 5, 136, 69, 2, 571, 572, 5, 
	162, 82, 2, 572, 109, 3, 2, 2, 2, 573, 575, 5, 112, 57, 2, 574, 576, 5, 
	116, 59, 2, 575, 574, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 577, 3, 2, 
	2, 2, 577, 578, 7, 25, 2, 2, 578, 111, 3, 2, 2, 2, 579, 583, 5, 114, 58, 
	2, 580, 583, 5, 70, 36, 2, 581, 583, 5, 72, 37, 2, 582, 579, 3, 2, 2, 2, 
	582, 580, 3, 2, 2, 2, 582, 581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 
	582, 3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 113, 3, 2, 2, 2, 586, 587, 
	9, 7, 2, 2, 587, 115, 3, 2, 2, 2, 588, 593, 5, 118, 60, 2, 589, 590, 7, 
	27, 2, 2, 590, 592, 5, 118, 60, 2, 591, 589, 3, 2, 2, 2, 592, 595, 3, 2, 
	2, 2, 593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 117, 3, 2, 2, 2, 
	595, 593, 3, 2, 2, 2, 596, 599, 5, 136, 69, 2, 597, 598, 7, 70, 2, 2, 598, 
	600, 5, 146, 74, 2, 599, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 119, 
	3, 2, 2, 2, 601, 614, 9, 8, 2, 2, 602, 615, 7, 117, 2, 2, 603, 605, 7, 
	117, 2, 2, 604, 603, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 606, 3, 2, 
	2, 2, 606, 608, 7, 28, 2, 2, 607, 609, 5, 122, 62, 2, 608, 607, 3, 2, 2, 
	2, 609, 610, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 
	612, 3, 2, 2, 2, 612, 613, 7, 29, 2, 2, 613, 615, 3, 2, 2, 2, 614, 602, 
	3, 2, 2, 2, 614, 604, 3, 2, 2, 2, 615, 121, 3, 2, 2, 2, 616, 617, 5, 124, 
	63, 2, 617, 618, 5, 126, 64, 2, 618, 619, 7, 25, 2, 2, 619, 123, 3, 2, 
	2, 2, 620, 623, 5, 70, 36, 2, 621, 623, 5, 72, 37, 2, 622, 620, 3, 2, 2, 
	2, 622, 621, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 622, 3, 2, 2, 2, 624, 
	625, 3, 2, 2, 2, 625, 125, 3, 2, 2, 2, 626, 631, 5, 128, 65, 2, 627, 628, 
	7, 27, 2, 2, 628, 630, 5, 128, 65, 2, 629, 627, 3, 2, 2, 2, 630, 633, 3, 
	2, 2, 2, 631, 629, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632, 127, 3, 2, 2, 
	2, 633, 631, 3, 2, 2, 2, 634, 641, 5, 136, 69, 2, 635, 637, 5, 136, 69, 
	2, 636, 635, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 
	639, 7, 19, 2, 2, 639, 641, 5, 212, 107, 2, 640, 634, 3, 2, 2, 2, 640, 
	636, 3, 2, 2, 2, 641, 129, 3, 2, 2, 2, 642, 654, 7, 73, 2, 2, 643, 648, 
	5, 210, 106, 2, 644, 645, 7, 28, 2, 2, 645, 646, 5, 132, 67, 2, 646, 647, 
	7, 29, 2, 2, 647, 649, 3, 2, 2, 2, 648, 644, 3, 2, 2, 2, 648, 649, 3, 2, 
	2, 2, 649, 655, 3, 2, 2, 2, 650, 651, 7, 28, 2, 2, 651, 652, 5, 132, 67, 
	2, 652, 653, 7, 29, 2, 2, 653, 655, 3, 2, 2, 2, 654, 643, 3, 2, 2, 2, 654, 
	650, 3, 2, 2, 2, 655, 131, 3, 2, 2, 2, 656, 661, 5, 134, 68, 2, 657, 658, 
	7, 27, 2, 2, 658, 660, 5, 134, 68, 2, 659, 657, 3, 2, 2, 2, 660, 663, 3, 
	2, 2, 2, 661, 659, 3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662, 133, 3, 2, 2, 
	2, 663, 661, 3, 2, 2, 2, 664, 667, 5, 210, 106, 2, 665, 666, 7, 70, 2, 
	2, 666, 668, 5, 178, 90, 2, 667, 665, 3, 2, 2, 2, 667, 668, 3, 2, 2, 2, 
	668, 135, 3, 2, 2, 2, 669, 673, 7, 74, 2, 2, 670, 672, 5, 72, 37, 2, 671, 
	670, 3, 2, 2, 2, 672, 675, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 673, 674, 
	3, 2, 2, 2, 674, 676, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 679, 5, 136, 
	69, 2, 677, 679, 5, 138, 70, 2, 678, 669, 3, 2, 2, 2, 678, 677, 3, 2, 2, 
	2, 679, 137, 3, 2, 2, 2, 680, 684, 5, 210, 106, 2, 681, 683, 5, 140, 71, 
	2, 682, 681, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2, 684, 682, 3, 2, 2, 2, 684, 
	685, 3, 2, 2, 2, 685, 697, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 687, 688, 
	7, 21, 2, 2, 688, 689, 5, 136, 69, 2, 689, 693, 7, 22, 2, 2, 690, 692, 
	5, 140, 71, 2, 691, 690, 3, 2, 2, 2, 692, 695, 3, 2, 2, 2, 693, 691, 3, 
	2, 2, 2, 693, 694, 3, 2, 2, 2, 694, 697, 3, 2, 2, 2, 695, 693, 3, 2, 2, 
	2, 696, 680, 3, 2, 2, 2, 696, 687, 3, 2, 2, 2, 697, 139, 3, 2, 2, 2, 698, 
	700, 7, 55, 2, 2, 699, 701, 5, 178, 90, 2, 700, 699, 3, 2, 2, 2, 700, 701, 
	3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 709, 7, 56, 2, 2, 703, 705, 7, 21, 
	2, 2, 704, 706, 5, 142, 72, 2, 705, 704, 3, 2, 2, 2, 705, 706, 3, 2, 2, 
	2, 706, 707, 3, 2, 2, 2, 707, 709, 7, 22, 2, 2, 708, 698, 3, 2, 2, 2, 708, 
	703, 3, 2, 2, 2, 709, 141, 3, 2, 2, 2, 710, 713, 5, 154, 78, 2, 711, 712, 
	7, 27, 2, 2, 712, 714, 7, 75, 2, 2, 713, 711, 3, 2, 2, 2, 713, 714, 3, 
	2, 2, 2, 714, 143, 3, 2, 2, 2, 715, 720, 5, 112, 57, 2, 716, 718, 5, 136, 
	69, 2, 717, 716, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 721, 3, 2, 2, 2, 
	719, 721, 5, 150, 76, 2, 720, 717, 3, 2, 2, 2, 720, 719, 3, 2, 2, 2, 721, 
	145, 3, 2, 2, 2, 722, 735, 5, 172, 87, 2, 723, 724, 7, 28, 2, 2, 724, 729, 
	5, 146, 74, 2, 725, 726, 7, 27, 2, 2, 726, 728, 5, 146, 74, 2, 727, 725, 
	3, 2, 2, 2, 728, 731, 3, 2, 2, 2, 729, 727, 3, 2, 2, 2, 729, 730, 3, 2, 
	2, 2, 730, 732, 3, 2, 2, 2, 731, 729, 3, 2, 2, 2, 732, 733, 7, 29, 2, 2, 
	733, 735, 3, 2, 2, 2, 734, 722, 3, 2, 2, 2, 734, 723, 3, 2, 2, 2, 735, 
	147, 3, 2, 2, 2, 736, 737, 5, 124, 63, 2, 737, 738, 5, 150, 76, 2, 738, 
	149, 3, 2, 2, 2, 739, 743, 7, 74, 2, 2, 740, 742, 5, 72, 37, 2, 741, 740, 
	3, 2, 2, 2, 742, 745, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 743, 744, 3, 2, 
	2, 2, 744, 746, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 746, 766, 5, 150, 76, 
	2, 747, 748, 7, 21, 2, 2, 748, 749, 5, 150, 76, 2, 749, 751, 7, 22, 2, 
	2, 750, 752, 5, 152, 77, 2, 751, 750, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 
	753, 751, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 766, 3, 2, 2, 2, 755, 
	757, 7, 55, 2, 2, 756, 758, 5, 178, 90, 2, 757, 756, 3, 2, 2, 2, 757, 758, 
	3, 2, 2, 2, 758, 759, 3, 2, 2, 2, 759, 761, 7, 56, 2, 2, 760, 755, 3, 2, 
	2, 2, 761, 762, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2, 
	763, 766, 3, 2, 2, 2, 764, 766, 3, 2, 2, 2, 765, 739, 3, 2, 2, 2, 765, 
	747, 3, 2, 2, 2, 765, 760, 3, 2, 2, 2, 765, 764, 3, 2, 2, 2, 766, 151, 
	3, 2, 2, 2, 767, 769, 7, 55, 2, 2, 768, 770, 5, 178, 90, 2, 769, 768, 3, 
	2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 778, 7, 56, 2, 
	2, 772, 774, 7, 21, 2, 2, 773, 775, 5, 154, 78, 2, 774, 773, 3, 2, 2, 2, 
	774, 775, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 778, 7, 22, 2, 2, 777, 
	767, 3, 2, 2, 2, 777, 772, 3, 2, 2, 2, 778, 153, 3, 2, 2, 2, 779, 784, 
	5, 144, 73, 2, 780, 781, 7, 27, 2, 2, 781, 783, 5, 144, 73, 2, 782, 780, 
	3, 2, 2, 2, 783, 786, 3, 2, 2, 2, 784, 782, 3, 2, 2, 2, 784, 785, 3, 2, 
	2, 2, 785, 155, 3, 2, 2, 2, 786, 784, 3, 2, 2, 2, 787, 789, 5, 158, 80, 
	2, 788, 787, 3, 2, 2, 2, 789, 790, 3, 2, 2, 2, 790, 788, 3, 2, 2, 2, 790, 
	791, 3, 2, 2, 2, 791, 157, 3, 2, 2, 2, 792, 802, 5, 160, 81, 2, 793, 794, 
	5, 170, 86, 2, 794, 795, 7, 25, 2, 2, 795, 802, 3, 2, 2, 2, 796, 802, 5, 
	162, 82, 2, 797, 802, 5, 164, 83, 2, 798, 802, 5, 166, 84, 2, 799, 802, 
	5, 168, 85, 2, 800, 802, 7, 25, 2, 2, 801, 792, 3, 2, 2, 2, 801, 793, 3, 
	2, 2, 2, 801, 796, 3, 2, 2, 2, 801, 797, 3, 2, 2, 2, 801, 798, 3, 2, 2, 
	2, 801, 799, 3, 2, 2, 2, 801, 800, 3, 2, 2, 2, 802, 159, 3, 2, 2, 2, 803, 
	804, 5, 210, 106, 2, 804, 805, 7, 19, 2, 2, 805, 806, 5, 158, 80, 2, 806, 
	816, 3, 2, 2, 2, 807, 808, 7, 76, 2, 2, 808, 809, 5, 178, 90, 2, 809, 810, 
	7, 19, 2, 2, 810, 811, 5, 158, 80, 2, 811, 816, 3, 2, 2, 2, 812, 813, 7, 
	77, 2, 2, 813, 814, 7, 19, 2, 2, 814, 816, 5, 158, 80, 2, 815, 803, 3, 
	2, 2, 2, 815, 807, 3, 2, 2, 2, 815, 812, 3, 2, 2, 2, 816, 161, 3, 2, 2, 
	2, 817, 821, 7, 28, 2, 2, 818, 820, 5, 110, 56, 2, 819, 818, 3, 2, 2, 2, 
	820, 823, 3, 2, 2, 2, 821, 819, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 
	825, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2, 824, 826, 5, 156, 79, 2, 825, 824, 
	3, 2, 2, 2, 825, 826, 3, 2, 2, 2, 826, 827, 3, 2, 2, 2, 827, 828, 7, 29, 
	2, 2, 828, 163, 3, 2, 2, 2, 829, 830, 7, 78, 2, 2, 830, 831, 7, 21, 2, 
	2, 831, 832, 5, 170, 86, 2, 832, 833, 7, 22, 2, 2, 833, 836, 5, 158, 80, 
	2, 834, 835, 7, 79, 2, 2, 835, 837, 5, 158, 80, 2, 836, 834, 3, 2, 2, 2, 
	836, 837, 3, 2, 2, 2, 837, 845, 3, 2, 2, 2, 838, 839, 7, 80, 2, 2, 839, 
	840, 7, 21, 2, 2, 840, 841, 5, 170, 86, 2, 841, 842, 7, 22, 2, 2, 842, 
	843, 5, 158, 80, 2, 843, 845, 3, 2, 2, 2, 844, 829, 3, 2, 2, 2, 844, 838, 
	3, 2, 2, 2, 845, 165, 3, 2, 2, 2, 846, 847, 7, 81, 2, 2, 847, 848, 7, 21, 
	2, 2, 848, 849, 5, 170, 86, 2, 849, 850, 7, 22, 2, 2, 850, 851, 5, 158, 
	80, 2, 851, 876, 3, 2, 2, 2, 852, 853, 7, 82, 2, 2, 853, 854, 5, 158, 80, 
	2, 854, 855, 7, 81, 2, 2, 855, 856, 7, 21, 2, 2, 856, 857, 5, 170, 86, 
	2, 857, 858, 7, 22, 2, 2, 858, 859, 7, 25, 2, 2, 859, 876, 3, 2, 2, 2, 
	860, 861, 7, 83, 2, 2, 861, 863, 7, 21, 2, 2, 862, 864, 5, 170, 86, 2, 
	863, 862, 3, 2, 2, 2, 863, 864, 3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865, 
	867, 7, 25, 2, 2, 866, 868, 5, 170, 86, 2, 867, 866, 3, 2, 2, 2, 867, 868, 
	3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 871, 7, 25, 2, 2, 870, 872, 5, 170, 
	86, 2, 871, 870, 3, 2, 2, 2, 871, 872, 3, 2, 2, 2, 872, 873, 3, 2, 2, 2, 
	873, 874, 7, 22, 2, 2, 874, 876, 5, 158, 80, 2, 875, 846, 3, 2, 2, 2, 875, 
	852, 3, 2, 2, 2, 875, 860, 3, 2, 2, 2, 876, 167, 3, 2, 2, 2, 877, 878, 
	7, 84, 2, 2, 878, 879, 5, 210, 106, 2, 879, 880, 7, 25, 2, 2, 880, 891, 
	3, 2, 2, 2, 881, 882, 7, 85, 2, 2, 882, 891, 7, 25, 2, 2, 883, 884, 7, 
	86, 2, 2, 884, 891, 7, 25, 2, 2, 885, 887, 7, 87, 2, 2, 886, 888, 5, 170, 
	86, 2, 887, 886, 3, 2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 
	889, 891, 7, 25, 2, 2, 890, 877, 3, 2, 2, 2, 890, 881, 3, 2, 2, 2, 890, 
	883, 3, 2, 2, 2, 890, 885, 3, 2, 2, 2, 891, 169, 3, 2, 2, 2, 892, 897, 
	5, 172, 87, 2, 893, 894, 7, 27, 2, 2, 894, 896, 5, 172, 87, 2, 895, 893, 
	3, 2, 2, 2, 896, 899, 3, 2, 2, 2, 897, 895, 3, 2, 2, 2, 897, 898, 3, 2, 
	2, 2, 898, 171, 3, 2, 2, 2, 899, 897, 3, 2, 2, 2, 900, 904, 5, 176, 89, 
	2, 901, 902, 5, 174, 88, 2, 902, 903, 5, 172, 87, 2, 903, 905, 3, 2, 2, 
	2, 904, 901, 3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 173, 3, 2, 2, 2, 906, 
	907, 9, 9, 2, 2, 907, 175, 3, 2, 2, 2, 908, 914, 5, 180, 91, 2, 909, 910, 
	7, 98, 2, 2, 910, 911, 5, 180, 91, 2, 911, 912, 7, 19, 2, 2, 912, 913, 
	5, 180, 91, 2, 913, 915, 3, 2, 2, 2, 914, 909, 3, 2, 2, 2, 914, 915, 3, 
	2, 2, 2, 915, 177, 3, 2, 2, 2, 916, 917, 5, 176, 89, 2, 917, 179, 3, 2, 
	2, 2, 918, 923, 5, 182, 92, 2, 919, 920, 7, 99, 2, 2, 920, 922, 5, 182, 
	92, 2, 921, 919, 3, 2, 2, 2, 922, 925, 3, 2, 2, 2, 923, 921, 3, 2, 2, 2, 
	923, 924, 3, 2, 2, 2, 924, 181, 3, 2, 2, 2, 925, 923, 3, 2, 2, 2, 926, 
	931, 5, 184, 93, 2, 927, 928, 7, 100, 2, 2, 928, 930, 5, 184, 93, 2, 929, 
	927, 3, 2, 2, 2, 930, 933, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2, 931, 932, 
	3, 2, 2, 2, 932, 183, 3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 934, 939, 5, 186, 
	94, 2, 935, 936, 7, 101, 2, 2, 936, 938, 5, 186, 94, 2, 937, 935, 3, 2, 
	2, 2, 938, 941, 3, 2, 2, 2, 939, 937, 3, 2, 2, 2, 939, 940, 3, 2, 2, 2, 
	940, 185, 3, 2, 2, 2, 941, 939, 3, 2, 2, 2, 942, 947, 5, 188, 95, 2, 943, 
	944, 7, 102, 2, 2, 944, 946, 5, 188, 95, 2, 945, 943, 3, 2, 2, 2, 946, 
	949, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948, 187, 
	3, 2, 2, 2, 949, 947, 3, 2, 2, 2, 950, 955, 5, 190, 96, 2, 951, 952, 7, 
	103, 2, 2, 952, 954, 5, 190, 96, 2, 953, 951, 3, 2, 2, 2, 954, 957, 3, 
	2, 2, 2, 955, 953, 3, 2, 2, 2, 955, 956, 3, 2, 2, 2, 956, 189, 3, 2, 2, 
	2, 957, 955, 3, 2, 2, 2, 958, 963, 5, 192, 97, 2, 959, 960, 9, 10, 2, 2, 
	960, 962, 5, 192, 97, 2, 961, 959, 3, 2, 2, 2, 962, 965, 3, 2, 2, 2, 963, 
	961, 3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 191, 3, 2, 2, 2, 965, 963, 
	3, 2, 2, 2, 966, 971, 5, 194, 98, 2, 967, 968, 9, 11, 2, 2, 968, 970, 5, 
	194, 98, 2, 969, 967, 3, 2, 2, 2, 970, 973, 3, 2, 2, 2, 971, 969, 3, 2, 
	2, 2, 971, 972, 3, 2, 2, 2, 972, 193, 3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 
	974, 979, 5, 196, 99, 2, 975, 976, 9, 12, 2, 2, 976, 978, 5, 196, 99, 2, 
	977, 975, 3, 2, 2, 2, 978, 981, 3, 2, 2, 2, 979, 977, 3, 2, 2, 2, 979, 
	980, 3, 2, 2, 2, 980, 195, 3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 982, 987, 
	5, 198, 100, 2, 983, 984, 9, 13, 2, 2, 984, 986, 5, 198, 100, 2, 985, 983, 
	3, 2, 2, 2, 986, 989, 3, 2, 2, 2, 987, 985, 3, 2, 2, 2, 987, 988, 3, 2, 
	2, 2, 988, 197, 3, 2, 2, 2, 989, 987, 3, 2, 2, 2, 990, 995, 5, 200, 101, 
	2, 991, 992, 9, 14, 2, 2, 992, 994, 5, 200, 101, 2, 993, 991, 3, 2, 2, 
	2, 994, 997, 3, 2, 2, 2, 995, 993, 3, 2, 2, 2, 995, 996, 3, 2, 2, 2, 996, 
	199, 3, 2, 2, 2, 997, 995, 3, 2, 2, 2, 998, 999, 7, 21, 2, 2, 999, 1000, 
	5, 148, 75, 2, 1000, 1001, 7, 22, 2, 2, 1001, 1002, 5, 200, 101, 2, 1002, 
	1005, 3, 2, 2, 2, 1003, 1005, 5, 202, 102, 2, 1004, 998, 3, 2, 2, 2, 1004, 
	1003, 3, 2, 2, 2, 1005, 201, 3, 2, 2, 2, 1006, 1023, 5, 206, 104, 2, 1007, 
	1008, 7, 111, 2, 2, 1008, 1023, 5, 202, 102, 2, 1009, 1010, 7, 112, 2, 
	2, 1010, 1023, 5, 202, 102, 2, 1011, 1012, 5, 204, 103, 2, 1012, 1013, 
	5, 200, 101, 2, 1013, 1023, 3, 2, 2, 2, 1014, 1020, 7, 113, 2, 2, 1015, 
	1016, 7, 21, 2, 2, 1016, 1017, 5, 148, 75, 2, 1017, 1018, 7, 22, 2, 2, 
	1018, 1021, 3, 2, 2, 2, 1019, 1021, 5, 202, 102, 2, 1020, 1015, 3, 2, 2, 
	2, 1020, 1019, 3, 2, 2, 2, 1021, 1023, 3, 2, 2, 2, 1022, 1006, 3, 2, 2, 
	2, 1022, 1007, 3, 2, 2, 2, 1022, 1009, 3, 2, 2, 2, 1022, 1011, 3, 2, 2, 
	2, 1022, 1014, 3, 2, 2, 2, 1023, 203, 3, 2, 2, 2, 1024, 1025, 9, 15, 2, 
	2, 1025, 205, 3, 2, 2, 2, 1026, 1044, 5, 76, 39, 2, 1027, 1028, 7, 55, 
	2, 2, 1028, 1029, 5, 170, 86, 2, 1029, 1030, 7, 56, 2, 2, 1030, 1043, 3, 
	2, 2, 2, 1031, 1033, 7, 21, 2, 2, 1032, 1034, 5, 208, 105, 2, 1033, 1032, 
	3, 2, 2, 2, 1033, 1034, 3, 2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1043, 
	7, 22, 2, 2, 1036, 1037, 7, 15, 2, 2, 1037, 1043, 5, 210, 106, 2, 1038, 
	1039, 7, 116, 2, 2, 1039, 1043, 5, 210, 106, 2, 1040, 1043, 7, 111, 2, 
	2, 1041, 1043, 7, 112, 2, 2, 1042, 1027, 3, 2, 2, 2, 1042, 1031, 3, 2, 
	2, 2, 1042, 1036, 3, 2, 2, 2, 1042, 1038, 3, 2, 2, 2, 1042, 1040, 3, 2, 
	2, 2, 1042, 1041, 3, 2, 2, 2, 1043, 1046, 3, 2, 2, 2, 1044, 1042, 3, 2, 
	2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 207, 3, 2, 2, 2, 1046, 1044, 3, 2, 
	2, 2, 1047, 1052, 5, 172, 87, 2, 1048, 1049, 7, 27, 2, 2, 1049, 1051, 5, 
	172, 87, 2, 1050, 1048, 3, 2, 2, 2, 1051, 1054, 3, 2, 2, 2, 1052, 1050, 
	3, 2, 2, 2, 1052, 1053, 3, 2, 2, 2, 1053, 209, 3, 2, 2, 2, 1054, 1052, 
	3, 2, 2, 2, 1055, 1056, 7, 117, 2, 2, 1056, 211, 3, 2, 2, 2, 1057, 1058, 
	9, 16, 2, 2, 1058, 213, 3, 2, 2, 2, 119, 217, 233, 250, 255, 259, 269, 
	272, 275, 278, 288, 291, 299, 302, 312, 319, 322, 339, 351, 370, 372, 379, 
	381, 390, 399, 401, 410, 414, 422, 425, 427, 430, 436, 458, 462, 467, 472, 
	488, 498, 504, 506, 509, 521, 526, 528, 561, 575, 582, 584, 593, 599, 604, 
	610, 614, 622, 624, 631, 636, 640, 648, 654, 661, 667, 673, 678, 684, 693, 
	696, 700, 705, 708, 713, 717, 720, 729, 734, 743, 753, 757, 762, 765, 769, 
	774, 777, 784, 790, 801, 815, 821, 825, 836, 844, 863, 867, 871, 875, 887, 
	890, 897, 904, 914, 923, 931, 939, 947, 955, 963, 971, 979, 987, 995, 1004, 
	1020, 1022, 1033, 1042, 1044, 1052,
}
var literalNames = []string{
	"", "'#import'", "'#include'", "'#define'", "'#ifdef'", "'#if'", "'#undef'", 
	"'#ifndef'", "'#endif'", "'<'", "'\"'", "'/'", "'\\'", "'.'", "'>'", "'.+'", 
	"'@interface'", "':'", "'@end'", "'('", "')'", "'@implementation'", "'@protocol'", 
	"';'", "'@class'", "','", "'{'", "'}'", "'@private'", "'@protected'", "'@package'", 
	"'@public'", "'+'", "'-'", "'void'", "'char'", "'short'", "'int'", "'long'", 
	"'float'", "'double'", "'signed'", "'unsigned'", "'id'", "'const'", "'volatile'", 
	"'in'", "'out'", "'inout'", "'bycopy'", "'byref'", "'oneway'", "'self'", 
	"'['", "']'", "'super'", "'@selector'", "'@encode'", "'@trystatement'", 
	"'@catch'", "'@finally'", "'@throw'", "'@synchronized'", "'auto'", "'register'", 
	"'static'", "'extern'", "'typedef'", "'='", "'struct'", "'union'", "'enum'", 
	"'*'", "'...'", "'case'", "'default'", "'if'", "'else'", "'switch'", "'while'", 
	"'do'", "'for'", "'goto'", "'continue'", "'break'", "'return'", "'*='", 
	"'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='", 
	"'?'", "'||'", "'&&'", "'|'", "'^'", "'&'", "'!='", "'=='", "'<='", "'>='", 
	"'<<'", "'>>'", "'%'", "'++'", "'--'", "'sizeof'", "'~'", "'!'", "'->'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "IDENTIFIER", "CHARACTER_LITERAL", "STRING_LITERAL", 
	"HEX_LITERAL", "DECIMAL_LITERAL", "OCTAL_LITERAL", "FLOATING_POINT_LITERAL", 
	"WS", "COMMENT", "LINE_COMMENT",
}

var ruleNames = []string{
	"translation_unit", "external_declaration", "preprocessor_declaration", 
	"file_specification", "macro_specification", "class_interface", "category_interface", 
	"class_implementation", "category_implementation", "protocol_declaration", 
	"protocol_declaration_list", "class_declaration_list", "class_list", "protocol_reference_list", 
	"protocol_list", "class_name", "superclass_name", "category_name", "protocol_name", 
	"instance_variables", "instance_variable_declaration", "visibility_specification", 
	"interface_declaration_list", "class_method_declaration", "instance_method_declaration", 
	"method_declaration", "implementation_definition_list", "class_method_definition", 
	"instance_method_definition", "method_definition", "method_selector", "keyword_declarator", 
	"selector", "method_type", "type_specifier", "type_qualifier", "protocol_qualifier", 
	"primary_expression", "message_expression", "receiver", "message_selector", 
	"keyword_argument", "selector_expression", "selector_name", "protocol_expression", 
	"encode_expression", "exception_declarator", "try_statement", "catch_statement", 
	"finally_statement", "throw_statement", "try_block", "synchronized_statement", 
	"function_definition", "declaration", "declaration_specifiers", "storage_class_specifier", 
	"init_declarator_list", "init_declarator", "struct_or_union_specifier", 
	"struct_declaration", "specifier_qualifier_list", "struct_declarator_list", 
	"struct_declarator", "enum_specifier", "enumerator_list", "enumerator", 
	"declarator", "direct_declarator", "declarator_suffix", "parameter_list", 
	"parameter_declaration", "initializer", "type_name", "abstract_declarator", 
	"abstract_declarator_suffix", "parameter_declaration_list", "statement_list", 
	"statement", "labeled_statement", "compound_statement", "selection_statement", 
	"iteration_statement", "jump_statement", "expression", "assignment_expression", 
	"assignment_operator", "conditional_expression", "constant_expression", 
	"logical_or_expression", "logical_and_expression", "inclusive_or_expression", 
	"exclusive_or_expression", "and_expression", "equality_expression", "relational_expression", 
	"shift_expression", "additive_expression", "multiplicative_expression", 
	"cast_expression", "unary_expression", "unary_operator", "postfix_expression", 
	"argument_expression_list", "identifier", "constant",
}
type ObjectiveCParser struct {
	*antlr.BaseParser
}

// NewObjectiveCParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ObjectiveCParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewObjectiveCParser(input antlr.TokenStream) *ObjectiveCParser {
	this := new(ObjectiveCParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ObjectiveC.g4"

	return this
}


// ObjectiveCParser tokens.
const (
	ObjectiveCParserEOF = antlr.TokenEOF
	ObjectiveCParserT__0 = 1
	ObjectiveCParserT__1 = 2
	ObjectiveCParserT__2 = 3
	ObjectiveCParserT__3 = 4
	ObjectiveCParserT__4 = 5
	ObjectiveCParserT__5 = 6
	ObjectiveCParserT__6 = 7
	ObjectiveCParserT__7 = 8
	ObjectiveCParserT__8 = 9
	ObjectiveCParserT__9 = 10
	ObjectiveCParserT__10 = 11
	ObjectiveCParserT__11 = 12
	ObjectiveCParserT__12 = 13
	ObjectiveCParserT__13 = 14
	ObjectiveCParserT__14 = 15
	ObjectiveCParserT__15 = 16
	ObjectiveCParserT__16 = 17
	ObjectiveCParserT__17 = 18
	ObjectiveCParserT__18 = 19
	ObjectiveCParserT__19 = 20
	ObjectiveCParserT__20 = 21
	ObjectiveCParserT__21 = 22
	ObjectiveCParserT__22 = 23
	ObjectiveCParserT__23 = 24
	ObjectiveCParserT__24 = 25
	ObjectiveCParserT__25 = 26
	ObjectiveCParserT__26 = 27
	ObjectiveCParserT__27 = 28
	ObjectiveCParserT__28 = 29
	ObjectiveCParserT__29 = 30
	ObjectiveCParserT__30 = 31
	ObjectiveCParserT__31 = 32
	ObjectiveCParserT__32 = 33
	ObjectiveCParserT__33 = 34
	ObjectiveCParserT__34 = 35
	ObjectiveCParserT__35 = 36
	ObjectiveCParserT__36 = 37
	ObjectiveCParserT__37 = 38
	ObjectiveCParserT__38 = 39
	ObjectiveCParserT__39 = 40
	ObjectiveCParserT__40 = 41
	ObjectiveCParserT__41 = 42
	ObjectiveCParserT__42 = 43
	ObjectiveCParserT__43 = 44
	ObjectiveCParserT__44 = 45
	ObjectiveCParserT__45 = 46
	ObjectiveCParserT__46 = 47
	ObjectiveCParserT__47 = 48
	ObjectiveCParserT__48 = 49
	ObjectiveCParserT__49 = 50
	ObjectiveCParserT__50 = 51
	ObjectiveCParserT__51 = 52
	ObjectiveCParserT__52 = 53
	ObjectiveCParserT__53 = 54
	ObjectiveCParserT__54 = 55
	ObjectiveCParserT__55 = 56
	ObjectiveCParserT__56 = 57
	ObjectiveCParserT__57 = 58
	ObjectiveCParserT__58 = 59
	ObjectiveCParserT__59 = 60
	ObjectiveCParserT__60 = 61
	ObjectiveCParserT__61 = 62
	ObjectiveCParserT__62 = 63
	ObjectiveCParserT__63 = 64
	ObjectiveCParserT__64 = 65
	ObjectiveCParserT__65 = 66
	ObjectiveCParserT__66 = 67
	ObjectiveCParserT__67 = 68
	ObjectiveCParserT__68 = 69
	ObjectiveCParserT__69 = 70
	ObjectiveCParserT__70 = 71
	ObjectiveCParserT__71 = 72
	ObjectiveCParserT__72 = 73
	ObjectiveCParserT__73 = 74
	ObjectiveCParserT__74 = 75
	ObjectiveCParserT__75 = 76
	ObjectiveCParserT__76 = 77
	ObjectiveCParserT__77 = 78
	ObjectiveCParserT__78 = 79
	ObjectiveCParserT__79 = 80
	ObjectiveCParserT__80 = 81
	ObjectiveCParserT__81 = 82
	ObjectiveCParserT__82 = 83
	ObjectiveCParserT__83 = 84
	ObjectiveCParserT__84 = 85
	ObjectiveCParserT__85 = 86
	ObjectiveCParserT__86 = 87
	ObjectiveCParserT__87 = 88
	ObjectiveCParserT__88 = 89
	ObjectiveCParserT__89 = 90
	ObjectiveCParserT__90 = 91
	ObjectiveCParserT__91 = 92
	ObjectiveCParserT__92 = 93
	ObjectiveCParserT__93 = 94
	ObjectiveCParserT__94 = 95
	ObjectiveCParserT__95 = 96
	ObjectiveCParserT__96 = 97
	ObjectiveCParserT__97 = 98
	ObjectiveCParserT__98 = 99
	ObjectiveCParserT__99 = 100
	ObjectiveCParserT__100 = 101
	ObjectiveCParserT__101 = 102
	ObjectiveCParserT__102 = 103
	ObjectiveCParserT__103 = 104
	ObjectiveCParserT__104 = 105
	ObjectiveCParserT__105 = 106
	ObjectiveCParserT__106 = 107
	ObjectiveCParserT__107 = 108
	ObjectiveCParserT__108 = 109
	ObjectiveCParserT__109 = 110
	ObjectiveCParserT__110 = 111
	ObjectiveCParserT__111 = 112
	ObjectiveCParserT__112 = 113
	ObjectiveCParserT__113 = 114
	ObjectiveCParserIDENTIFIER = 115
	ObjectiveCParserCHARACTER_LITERAL = 116
	ObjectiveCParserSTRING_LITERAL = 117
	ObjectiveCParserHEX_LITERAL = 118
	ObjectiveCParserDECIMAL_LITERAL = 119
	ObjectiveCParserOCTAL_LITERAL = 120
	ObjectiveCParserFLOATING_POINT_LITERAL = 121
	ObjectiveCParserWS = 122
	ObjectiveCParserCOMMENT = 123
	ObjectiveCParserLINE_COMMENT = 124
)

// ObjectiveCParser rules.
const (
	ObjectiveCParserRULE_translation_unit = 0
	ObjectiveCParserRULE_external_declaration = 1
	ObjectiveCParserRULE_preprocessor_declaration = 2
	ObjectiveCParserRULE_file_specification = 3
	ObjectiveCParserRULE_macro_specification = 4
	ObjectiveCParserRULE_class_interface = 5
	ObjectiveCParserRULE_category_interface = 6
	ObjectiveCParserRULE_class_implementation = 7
	ObjectiveCParserRULE_category_implementation = 8
	ObjectiveCParserRULE_protocol_declaration = 9
	ObjectiveCParserRULE_protocol_declaration_list = 10
	ObjectiveCParserRULE_class_declaration_list = 11
	ObjectiveCParserRULE_class_list = 12
	ObjectiveCParserRULE_protocol_reference_list = 13
	ObjectiveCParserRULE_protocol_list = 14
	ObjectiveCParserRULE_class_name = 15
	ObjectiveCParserRULE_superclass_name = 16
	ObjectiveCParserRULE_category_name = 17
	ObjectiveCParserRULE_protocol_name = 18
	ObjectiveCParserRULE_instance_variables = 19
	ObjectiveCParserRULE_instance_variable_declaration = 20
	ObjectiveCParserRULE_visibility_specification = 21
	ObjectiveCParserRULE_interface_declaration_list = 22
	ObjectiveCParserRULE_class_method_declaration = 23
	ObjectiveCParserRULE_instance_method_declaration = 24
	ObjectiveCParserRULE_method_declaration = 25
	ObjectiveCParserRULE_implementation_definition_list = 26
	ObjectiveCParserRULE_class_method_definition = 27
	ObjectiveCParserRULE_instance_method_definition = 28
	ObjectiveCParserRULE_method_definition = 29
	ObjectiveCParserRULE_method_selector = 30
	ObjectiveCParserRULE_keyword_declarator = 31
	ObjectiveCParserRULE_selector = 32
	ObjectiveCParserRULE_method_type = 33
	ObjectiveCParserRULE_type_specifier = 34
	ObjectiveCParserRULE_type_qualifier = 35
	ObjectiveCParserRULE_protocol_qualifier = 36
	ObjectiveCParserRULE_primary_expression = 37
	ObjectiveCParserRULE_message_expression = 38
	ObjectiveCParserRULE_receiver = 39
	ObjectiveCParserRULE_message_selector = 40
	ObjectiveCParserRULE_keyword_argument = 41
	ObjectiveCParserRULE_selector_expression = 42
	ObjectiveCParserRULE_selector_name = 43
	ObjectiveCParserRULE_protocol_expression = 44
	ObjectiveCParserRULE_encode_expression = 45
	ObjectiveCParserRULE_exception_declarator = 46
	ObjectiveCParserRULE_try_statement = 47
	ObjectiveCParserRULE_catch_statement = 48
	ObjectiveCParserRULE_finally_statement = 49
	ObjectiveCParserRULE_throw_statement = 50
	ObjectiveCParserRULE_try_block = 51
	ObjectiveCParserRULE_synchronized_statement = 52
	ObjectiveCParserRULE_function_definition = 53
	ObjectiveCParserRULE_declaration = 54
	ObjectiveCParserRULE_declaration_specifiers = 55
	ObjectiveCParserRULE_storage_class_specifier = 56
	ObjectiveCParserRULE_init_declarator_list = 57
	ObjectiveCParserRULE_init_declarator = 58
	ObjectiveCParserRULE_struct_or_union_specifier = 59
	ObjectiveCParserRULE_struct_declaration = 60
	ObjectiveCParserRULE_specifier_qualifier_list = 61
	ObjectiveCParserRULE_struct_declarator_list = 62
	ObjectiveCParserRULE_struct_declarator = 63
	ObjectiveCParserRULE_enum_specifier = 64
	ObjectiveCParserRULE_enumerator_list = 65
	ObjectiveCParserRULE_enumerator = 66
	ObjectiveCParserRULE_declarator = 67
	ObjectiveCParserRULE_direct_declarator = 68
	ObjectiveCParserRULE_declarator_suffix = 69
	ObjectiveCParserRULE_parameter_list = 70
	ObjectiveCParserRULE_parameter_declaration = 71
	ObjectiveCParserRULE_initializer = 72
	ObjectiveCParserRULE_type_name = 73
	ObjectiveCParserRULE_abstract_declarator = 74
	ObjectiveCParserRULE_abstract_declarator_suffix = 75
	ObjectiveCParserRULE_parameter_declaration_list = 76
	ObjectiveCParserRULE_statement_list = 77
	ObjectiveCParserRULE_statement = 78
	ObjectiveCParserRULE_labeled_statement = 79
	ObjectiveCParserRULE_compound_statement = 80
	ObjectiveCParserRULE_selection_statement = 81
	ObjectiveCParserRULE_iteration_statement = 82
	ObjectiveCParserRULE_jump_statement = 83
	ObjectiveCParserRULE_expression = 84
	ObjectiveCParserRULE_assignment_expression = 85
	ObjectiveCParserRULE_assignment_operator = 86
	ObjectiveCParserRULE_conditional_expression = 87
	ObjectiveCParserRULE_constant_expression = 88
	ObjectiveCParserRULE_logical_or_expression = 89
	ObjectiveCParserRULE_logical_and_expression = 90
	ObjectiveCParserRULE_inclusive_or_expression = 91
	ObjectiveCParserRULE_exclusive_or_expression = 92
	ObjectiveCParserRULE_and_expression = 93
	ObjectiveCParserRULE_equality_expression = 94
	ObjectiveCParserRULE_relational_expression = 95
	ObjectiveCParserRULE_shift_expression = 96
	ObjectiveCParserRULE_additive_expression = 97
	ObjectiveCParserRULE_multiplicative_expression = 98
	ObjectiveCParserRULE_cast_expression = 99
	ObjectiveCParserRULE_unary_expression = 100
	ObjectiveCParserRULE_unary_operator = 101
	ObjectiveCParserRULE_postfix_expression = 102
	ObjectiveCParserRULE_argument_expression_list = 103
	ObjectiveCParserRULE_identifier = 104
	ObjectiveCParserRULE_constant = 105
)

// ITranslation_unitContext is an interface to support dynamic dispatch.
type ITranslation_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslation_unitContext differentiates from other interfaces.
	IsTranslation_unitContext()
}

type Translation_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslation_unitContext() *Translation_unitContext {
	var p = new(Translation_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_translation_unit
	return p
}

func (*Translation_unitContext) IsTranslation_unitContext() {}

func NewTranslation_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Translation_unitContext {
	var p = new(Translation_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_translation_unit

	return p
}

func (s *Translation_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Translation_unitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserEOF, 0)
}

func (s *Translation_unitContext) AllExternal_declaration() []IExternal_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExternal_declarationContext)(nil)).Elem())
	var tst = make([]IExternal_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExternal_declarationContext)
		}
	}

	return tst
}

func (s *Translation_unitContext) External_declaration(i int) IExternal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternal_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExternal_declarationContext)
}

func (s *Translation_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Translation_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Translation_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterTranslation_unit(s)
	}
}

func (s *Translation_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitTranslation_unit(s)
	}
}




func (p *ObjectiveCParser) Translation_unit() (localctx ITranslation_unitContext) {
	localctx = NewTranslation_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ObjectiveCParserRULE_translation_unit)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__0) | (1 << ObjectiveCParserT__1) | (1 << ObjectiveCParserT__2) | (1 << ObjectiveCParserT__3) | (1 << ObjectiveCParserT__4) | (1 << ObjectiveCParserT__5) | (1 << ObjectiveCParserT__6) | (1 << ObjectiveCParserT__7) | (1 << ObjectiveCParserT__15) | (1 << ObjectiveCParserT__20) | (1 << ObjectiveCParserT__21) | (1 << ObjectiveCParserT__23))) != 0) || ((((_la - 34)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 34))) & ((1 << (ObjectiveCParserT__33 - 34)) | (1 << (ObjectiveCParserT__34 - 34)) | (1 << (ObjectiveCParserT__35 - 34)) | (1 << (ObjectiveCParserT__36 - 34)) | (1 << (ObjectiveCParserT__37 - 34)) | (1 << (ObjectiveCParserT__38 - 34)) | (1 << (ObjectiveCParserT__39 - 34)) | (1 << (ObjectiveCParserT__40 - 34)) | (1 << (ObjectiveCParserT__41 - 34)) | (1 << (ObjectiveCParserT__42 - 34)) | (1 << (ObjectiveCParserT__43 - 34)) | (1 << (ObjectiveCParserT__44 - 34)) | (1 << (ObjectiveCParserT__45 - 34)) | (1 << (ObjectiveCParserT__46 - 34)) | (1 << (ObjectiveCParserT__47 - 34)) | (1 << (ObjectiveCParserT__48 - 34)) | (1 << (ObjectiveCParserT__49 - 34)) | (1 << (ObjectiveCParserT__50 - 34)) | (1 << (ObjectiveCParserT__62 - 34)) | (1 << (ObjectiveCParserT__63 - 34)) | (1 << (ObjectiveCParserT__64 - 34)))) != 0) || ((((_la - 66)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 66))) & ((1 << (ObjectiveCParserT__65 - 66)) | (1 << (ObjectiveCParserT__66 - 66)) | (1 << (ObjectiveCParserT__68 - 66)) | (1 << (ObjectiveCParserT__69 - 66)) | (1 << (ObjectiveCParserT__70 - 66)))) != 0) || ((((_la - 115)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 115))) & ((1 << (ObjectiveCParserIDENTIFIER - 115)) | (1 << (ObjectiveCParserCOMMENT - 115)) | (1 << (ObjectiveCParserLINE_COMMENT - 115)))) != 0) {
		{
			p.SetState(212)
			p.External_declaration()
		}


		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(217)
		p.Match(ObjectiveCParserEOF)
	}



	return localctx
}


// IExternal_declarationContext is an interface to support dynamic dispatch.
type IExternal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternal_declarationContext differentiates from other interfaces.
	IsExternal_declarationContext()
}

type External_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_declarationContext() *External_declarationContext {
	var p = new(External_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_external_declaration
	return p
}

func (*External_declarationContext) IsExternal_declarationContext() {}

func NewExternal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_declarationContext {
	var p = new(External_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_external_declaration

	return p
}

func (s *External_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *External_declarationContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCOMMENT, 0)
}

func (s *External_declarationContext) LINE_COMMENT() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserLINE_COMMENT, 0)
}

func (s *External_declarationContext) Preprocessor_declaration() IPreprocessor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreprocessor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreprocessor_declarationContext)
}

func (s *External_declarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *External_declarationContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *External_declarationContext) Class_interface() IClass_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_interfaceContext)
}

func (s *External_declarationContext) Class_implementation() IClass_implementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_implementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_implementationContext)
}

func (s *External_declarationContext) Category_interface() ICategory_interfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_interfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_interfaceContext)
}

func (s *External_declarationContext) Category_implementation() ICategory_implementationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_implementationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_implementationContext)
}

func (s *External_declarationContext) Protocol_declaration() IProtocol_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_declarationContext)
}

func (s *External_declarationContext) Protocol_declaration_list() IProtocol_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_declaration_listContext)
}

func (s *External_declarationContext) Class_declaration_list() IClass_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_declaration_listContext)
}

func (s *External_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *External_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterExternal_declaration(s)
	}
}

func (s *External_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitExternal_declaration(s)
	}
}




func (p *ObjectiveCParser) External_declaration() (localctx IExternal_declarationContext) {
	localctx = NewExternal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ObjectiveCParserRULE_external_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(219)
			p.Match(ObjectiveCParserCOMMENT)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(220)
			p.Match(ObjectiveCParserLINE_COMMENT)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(221)
			p.Preprocessor_declaration()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(222)
			p.Function_definition()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(223)
			p.Declaration()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(224)
			p.Class_interface()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(225)
			p.Class_implementation()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(226)
			p.Category_interface()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(227)
			p.Category_implementation()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(228)
			p.Protocol_declaration()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(229)
			p.Protocol_declaration_list()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(230)
			p.Class_declaration_list()
		}

	}


	return localctx
}


// IPreprocessor_declarationContext is an interface to support dynamic dispatch.
type IPreprocessor_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreprocessor_declarationContext differentiates from other interfaces.
	IsPreprocessor_declarationContext()
}

type Preprocessor_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreprocessor_declarationContext() *Preprocessor_declarationContext {
	var p = new(Preprocessor_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_preprocessor_declaration
	return p
}

func (*Preprocessor_declarationContext) IsPreprocessor_declarationContext() {}

func NewPreprocessor_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preprocessor_declarationContext {
	var p = new(Preprocessor_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_preprocessor_declaration

	return p
}

func (s *Preprocessor_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Preprocessor_declarationContext) File_specification() IFile_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_specificationContext)
}

func (s *Preprocessor_declarationContext) Macro_specification() IMacro_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMacro_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMacro_specificationContext)
}

func (s *Preprocessor_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Preprocessor_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preprocessor_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Preprocessor_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterPreprocessor_declaration(s)
	}
}

func (s *Preprocessor_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitPreprocessor_declaration(s)
	}
}




func (p *ObjectiveCParser) Preprocessor_declaration() (localctx IPreprocessor_declarationContext) {
	localctx = NewPreprocessor_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ObjectiveCParserRULE_preprocessor_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(248)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(233)
			p.Match(ObjectiveCParserT__0)
		}
		{
			p.SetState(234)
			p.File_specification()
		}


	case ObjectiveCParserT__1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(235)
			p.Match(ObjectiveCParserT__1)
		}
		{
			p.SetState(236)
			p.File_specification()
		}


	case ObjectiveCParserT__2:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(237)
			p.Match(ObjectiveCParserT__2)
		}
		{
			p.SetState(238)
			p.Macro_specification()
		}


	case ObjectiveCParserT__3:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(239)
			p.Match(ObjectiveCParserT__3)
		}
		{
			p.SetState(240)
			p.Expression()
		}


	case ObjectiveCParserT__4:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(241)
			p.Match(ObjectiveCParserT__4)
		}
		{
			p.SetState(242)
			p.Expression()
		}


	case ObjectiveCParserT__5:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(243)
			p.Match(ObjectiveCParserT__5)
		}
		{
			p.SetState(244)
			p.Expression()
		}


	case ObjectiveCParserT__6:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(245)
			p.Match(ObjectiveCParserT__6)
		}
		{
			p.SetState(246)
			p.Expression()
		}


	case ObjectiveCParserT__7:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(247)
			p.Match(ObjectiveCParserT__7)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFile_specificationContext is an interface to support dynamic dispatch.
type IFile_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_specificationContext differentiates from other interfaces.
	IsFile_specificationContext()
}

type File_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_specificationContext() *File_specificationContext {
	var p = new(File_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_file_specification
	return p
}

func (*File_specificationContext) IsFile_specificationContext() {}

func NewFile_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_specificationContext {
	var p = new(File_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_file_specification

	return p
}

func (s *File_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *File_specificationContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ObjectiveCParserIDENTIFIER)
}

func (s *File_specificationContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, i)
}

func (s *File_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *File_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterFile_specification(s)
	}
}

func (s *File_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitFile_specification(s)
	}
}




func (p *ObjectiveCParser) File_specification() (localctx IFile_specificationContext) {
	localctx = NewFile_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ObjectiveCParserRULE_file_specification)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserT__8 || _la == ObjectiveCParserT__9) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(251)
			p.Match(ObjectiveCParserIDENTIFIER)
		}
		p.SetState(253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__10) | (1 << ObjectiveCParserT__11) | (1 << ObjectiveCParserT__12))) != 0) {
			{
				p.SetState(252)
				_la = p.GetTokenStream().LA(1)

				if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__10) | (1 << ObjectiveCParserT__11) | (1 << ObjectiveCParserT__12))) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


		p.SetState(257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(259)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserT__9 || _la == ObjectiveCParserT__13) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IMacro_specificationContext is an interface to support dynamic dispatch.
type IMacro_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMacro_specificationContext differentiates from other interfaces.
	IsMacro_specificationContext()
}

type Macro_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacro_specificationContext() *Macro_specificationContext {
	var p = new(Macro_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_macro_specification
	return p
}

func (*Macro_specificationContext) IsMacro_specificationContext() {}

func NewMacro_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Macro_specificationContext {
	var p = new(Macro_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_macro_specification

	return p
}

func (s *Macro_specificationContext) GetParser() antlr.Parser { return s.parser }
func (s *Macro_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Macro_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Macro_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMacro_specification(s)
	}
}

func (s *Macro_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMacro_specification(s)
	}
}




func (p *ObjectiveCParser) Macro_specification() (localctx IMacro_specificationContext) {
	localctx = NewMacro_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ObjectiveCParserRULE_macro_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ObjectiveCParserT__14)
	}



	return localctx
}


// IClass_interfaceContext is an interface to support dynamic dispatch.
type IClass_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_interfaceContext differentiates from other interfaces.
	IsClass_interfaceContext()
}

type Class_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_interfaceContext() *Class_interfaceContext {
	var p = new(Class_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_interface
	return p
}

func (*Class_interfaceContext) IsClass_interfaceContext() {}

func NewClass_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_interfaceContext {
	var p = new(Class_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_interface

	return p
}

func (s *Class_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_interfaceContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_interfaceContext) Superclass_name() ISuperclass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclass_nameContext)
}

func (s *Class_interfaceContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Class_interfaceContext) Instance_variables() IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Class_interfaceContext) Interface_declaration_list() IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Class_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_interface(s)
	}
}

func (s *Class_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_interface(s)
	}
}




func (p *ObjectiveCParser) Class_interface() (localctx IClass_interfaceContext) {
	localctx = NewClass_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ObjectiveCParserRULE_class_interface)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(263)
		p.Match(ObjectiveCParserT__15)
	}

	{
		p.SetState(264)
		p.Class_name()
	}
	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__16 {
		{
			p.SetState(265)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(266)
			p.Superclass_name()
		}

	}
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__8 {
		{
			p.SetState(269)
			p.Protocol_reference_list()
		}

	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__25 {
		{
			p.SetState(272)
			p.Instance_variables()
		}

	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(275)
			p.Interface_declaration_list()
		}

	}

	{
		p.SetState(278)
		p.Match(ObjectiveCParserT__17)
	}



	return localctx
}


// ICategory_interfaceContext is an interface to support dynamic dispatch.
type ICategory_interfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_interfaceContext differentiates from other interfaces.
	IsCategory_interfaceContext()
}

type Category_interfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_interfaceContext() *Category_interfaceContext {
	var p = new(Category_interfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_category_interface
	return p
}

func (*Category_interfaceContext) IsCategory_interfaceContext() {}

func NewCategory_interfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_interfaceContext {
	var p = new(Category_interfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_category_interface

	return p
}

func (s *Category_interfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_interfaceContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Category_interfaceContext) Category_name() ICategory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_nameContext)
}

func (s *Category_interfaceContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Category_interfaceContext) Interface_declaration_list() IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Category_interfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_interfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_interfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCategory_interface(s)
	}
}

func (s *Category_interfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCategory_interface(s)
	}
}




func (p *ObjectiveCParser) Category_interface() (localctx ICategory_interfaceContext) {
	localctx = NewCategory_interfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ObjectiveCParserRULE_category_interface)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(ObjectiveCParserT__15)
	}

	{
		p.SetState(281)
		p.Class_name()
	}
	{
		p.SetState(282)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(283)
		p.Category_name()
	}
	{
		p.SetState(284)
		p.Match(ObjectiveCParserT__19)
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__8 {
		{
			p.SetState(285)
			p.Protocol_reference_list()
		}

	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(288)
			p.Interface_declaration_list()
		}

	}

	{
		p.SetState(291)
		p.Match(ObjectiveCParserT__17)
	}



	return localctx
}


// IClass_implementationContext is an interface to support dynamic dispatch.
type IClass_implementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_implementationContext differentiates from other interfaces.
	IsClass_implementationContext()
}

type Class_implementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_implementationContext() *Class_implementationContext {
	var p = new(Class_implementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_implementation
	return p
}

func (*Class_implementationContext) IsClass_implementationContext() {}

func NewClass_implementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_implementationContext {
	var p = new(Class_implementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_implementation

	return p
}

func (s *Class_implementationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_implementationContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_implementationContext) Superclass_name() ISuperclass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperclass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperclass_nameContext)
}

func (s *Class_implementationContext) Implementation_definition_list() IImplementation_definition_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_definition_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_definition_listContext)
}

func (s *Class_implementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_implementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_implementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_implementation(s)
	}
}

func (s *Class_implementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_implementation(s)
	}
}




func (p *ObjectiveCParser) Class_implementation() (localctx IClass_implementationContext) {
	localctx = NewClass_implementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ObjectiveCParserRULE_class_implementation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Match(ObjectiveCParserT__20)
	}

	{
		p.SetState(294)
		p.Class_name()
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__16 {
		{
			p.SetState(295)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(296)
			p.Superclass_name()
		}

	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(299)
			p.Implementation_definition_list()
		}

	}

	{
		p.SetState(302)
		p.Match(ObjectiveCParserT__17)
	}



	return localctx
}


// ICategory_implementationContext is an interface to support dynamic dispatch.
type ICategory_implementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_implementationContext differentiates from other interfaces.
	IsCategory_implementationContext()
}

type Category_implementationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_implementationContext() *Category_implementationContext {
	var p = new(Category_implementationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_category_implementation
	return p
}

func (*Category_implementationContext) IsCategory_implementationContext() {}

func NewCategory_implementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_implementationContext {
	var p = new(Category_implementationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_category_implementation

	return p
}

func (s *Category_implementationContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_implementationContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Category_implementationContext) Category_name() ICategory_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICategory_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICategory_nameContext)
}

func (s *Category_implementationContext) Implementation_definition_list() IImplementation_definition_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementation_definition_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementation_definition_listContext)
}

func (s *Category_implementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_implementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_implementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCategory_implementation(s)
	}
}

func (s *Category_implementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCategory_implementation(s)
	}
}




func (p *ObjectiveCParser) Category_implementation() (localctx ICategory_implementationContext) {
	localctx = NewCategory_implementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ObjectiveCParserRULE_category_implementation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(304)
		p.Match(ObjectiveCParserT__20)
	}

	{
		p.SetState(305)
		p.Class_name()
	}
	{
		p.SetState(306)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(307)
		p.Category_name()
	}
	{
		p.SetState(308)
		p.Match(ObjectiveCParserT__19)
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(309)
			p.Implementation_definition_list()
		}

	}

	{
		p.SetState(312)
		p.Match(ObjectiveCParserT__17)
	}



	return localctx
}


// IProtocol_declarationContext is an interface to support dynamic dispatch.
type IProtocol_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_declarationContext differentiates from other interfaces.
	IsProtocol_declarationContext()
}

type Protocol_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_declarationContext() *Protocol_declarationContext {
	var p = new(Protocol_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_declaration
	return p
}

func (*Protocol_declarationContext) IsProtocol_declarationContext() {}

func NewProtocol_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_declarationContext {
	var p = new(Protocol_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_declaration

	return p
}

func (s *Protocol_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_declarationContext) Protocol_name() IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_declarationContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Protocol_declarationContext) Interface_declaration_list() IInterface_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declaration_listContext)
}

func (s *Protocol_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_declaration(s)
	}
}

func (s *Protocol_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_declaration(s)
	}
}




func (p *ObjectiveCParser) Protocol_declaration() (localctx IProtocol_declarationContext) {
	localctx = NewProtocol_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ObjectiveCParserRULE_protocol_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(ObjectiveCParserT__21)
	}

	{
		p.SetState(315)
		p.Protocol_name()
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__8 {
		{
			p.SetState(316)
			p.Protocol_reference_list()
		}

	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(319)
			p.Interface_declaration_list()
		}

	}

	{
		p.SetState(322)
		p.Match(ObjectiveCParserT__17)
	}



	return localctx
}


// IProtocol_declaration_listContext is an interface to support dynamic dispatch.
type IProtocol_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_declaration_listContext differentiates from other interfaces.
	IsProtocol_declaration_listContext()
}

type Protocol_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_declaration_listContext() *Protocol_declaration_listContext {
	var p = new(Protocol_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_declaration_list
	return p
}

func (*Protocol_declaration_listContext) IsProtocol_declaration_listContext() {}

func NewProtocol_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_declaration_listContext {
	var p = new(Protocol_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_declaration_list

	return p
}

func (s *Protocol_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_declaration_listContext) Protocol_list() IProtocol_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_listContext)
}

func (s *Protocol_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_declaration_list(s)
	}
}

func (s *Protocol_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_declaration_list(s)
	}
}




func (p *ObjectiveCParser) Protocol_declaration_list() (localctx IProtocol_declaration_listContext) {
	localctx = NewProtocol_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ObjectiveCParserRULE_protocol_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(ObjectiveCParserT__21)
	}
	{
		p.SetState(325)
		p.Protocol_list()
	}
	{
		p.SetState(326)
		p.Match(ObjectiveCParserT__22)
	}




	return localctx
}


// IClass_declaration_listContext is an interface to support dynamic dispatch.
type IClass_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_declaration_listContext differentiates from other interfaces.
	IsClass_declaration_listContext()
}

type Class_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_declaration_listContext() *Class_declaration_listContext {
	var p = new(Class_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_declaration_list
	return p
}

func (*Class_declaration_listContext) IsClass_declaration_listContext() {}

func NewClass_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_declaration_listContext {
	var p = new(Class_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_declaration_list

	return p
}

func (s *Class_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_declaration_listContext) Class_list() IClass_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_listContext)
}

func (s *Class_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_declaration_list(s)
	}
}

func (s *Class_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_declaration_list(s)
	}
}




func (p *ObjectiveCParser) Class_declaration_list() (localctx IClass_declaration_listContext) {
	localctx = NewClass_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ObjectiveCParserRULE_class_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(ObjectiveCParserT__23)
	}
	{
		p.SetState(329)
		p.Class_list()
	}
	{
		p.SetState(330)
		p.Match(ObjectiveCParserT__22)
	}




	return localctx
}


// IClass_listContext is an interface to support dynamic dispatch.
type IClass_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_listContext differentiates from other interfaces.
	IsClass_listContext()
}

type Class_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_listContext() *Class_listContext {
	var p = new(Class_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_list
	return p
}

func (*Class_listContext) IsClass_listContext() {}

func NewClass_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_listContext {
	var p = new(Class_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_list

	return p
}

func (s *Class_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_listContext) AllClass_name() []IClass_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_nameContext)(nil)).Elem())
	var tst = make([]IClass_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_nameContext)
		}
	}

	return tst
}

func (s *Class_listContext) Class_name(i int) IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_list(s)
	}
}

func (s *Class_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_list(s)
	}
}




func (p *ObjectiveCParser) Class_list() (localctx IClass_listContext) {
	localctx = NewClass_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ObjectiveCParserRULE_class_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(332)
		p.Class_name()
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(333)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(334)
			p.Class_name()
		}


		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IProtocol_reference_listContext is an interface to support dynamic dispatch.
type IProtocol_reference_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_reference_listContext differentiates from other interfaces.
	IsProtocol_reference_listContext()
}

type Protocol_reference_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_reference_listContext() *Protocol_reference_listContext {
	var p = new(Protocol_reference_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_reference_list
	return p
}

func (*Protocol_reference_listContext) IsProtocol_reference_listContext() {}

func NewProtocol_reference_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_reference_listContext {
	var p = new(Protocol_reference_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_reference_list

	return p
}

func (s *Protocol_reference_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_reference_listContext) Protocol_list() IProtocol_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_listContext)
}

func (s *Protocol_reference_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_reference_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_reference_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_reference_list(s)
	}
}

func (s *Protocol_reference_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_reference_list(s)
	}
}




func (p *ObjectiveCParser) Protocol_reference_list() (localctx IProtocol_reference_listContext) {
	localctx = NewProtocol_reference_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ObjectiveCParserRULE_protocol_reference_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(ObjectiveCParserT__8)
	}
	{
		p.SetState(341)
		p.Protocol_list()
	}
	{
		p.SetState(342)
		p.Match(ObjectiveCParserT__13)
	}




	return localctx
}


// IProtocol_listContext is an interface to support dynamic dispatch.
type IProtocol_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_listContext differentiates from other interfaces.
	IsProtocol_listContext()
}

type Protocol_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_listContext() *Protocol_listContext {
	var p = new(Protocol_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_list
	return p
}

func (*Protocol_listContext) IsProtocol_listContext() {}

func NewProtocol_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_listContext {
	var p = new(Protocol_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_list

	return p
}

func (s *Protocol_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_listContext) AllProtocol_name() []IProtocol_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem())
	var tst = make([]IProtocol_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProtocol_nameContext)
		}
	}

	return tst
}

func (s *Protocol_listContext) Protocol_name(i int) IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_list(s)
	}
}

func (s *Protocol_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_list(s)
	}
}




func (p *ObjectiveCParser) Protocol_list() (localctx IProtocol_listContext) {
	localctx = NewProtocol_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ObjectiveCParserRULE_protocol_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Protocol_name()
	}
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(345)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(346)
			p.Protocol_name()
		}


		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IClass_nameContext is an interface to support dynamic dispatch.
type IClass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_nameContext differentiates from other interfaces.
	IsClass_nameContext()
}

type Class_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_nameContext() *Class_nameContext {
	var p = new(Class_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_name
	return p
}

func (*Class_nameContext) IsClass_nameContext() {}

func NewClass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_nameContext {
	var p = new(Class_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_name

	return p
}

func (s *Class_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Class_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_name(s)
	}
}

func (s *Class_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_name(s)
	}
}




func (p *ObjectiveCParser) Class_name() (localctx IClass_nameContext) {
	localctx = NewClass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ObjectiveCParserRULE_class_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// ISuperclass_nameContext is an interface to support dynamic dispatch.
type ISuperclass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperclass_nameContext differentiates from other interfaces.
	IsSuperclass_nameContext()
}

type Superclass_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperclass_nameContext() *Superclass_nameContext {
	var p = new(Superclass_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_superclass_name
	return p
}

func (*Superclass_nameContext) IsSuperclass_nameContext() {}

func NewSuperclass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Superclass_nameContext {
	var p = new(Superclass_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_superclass_name

	return p
}

func (s *Superclass_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Superclass_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Superclass_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Superclass_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Superclass_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSuperclass_name(s)
	}
}

func (s *Superclass_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSuperclass_name(s)
	}
}




func (p *ObjectiveCParser) Superclass_name() (localctx ISuperclass_nameContext) {
	localctx = NewSuperclass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ObjectiveCParserRULE_superclass_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// ICategory_nameContext is an interface to support dynamic dispatch.
type ICategory_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCategory_nameContext differentiates from other interfaces.
	IsCategory_nameContext()
}

type Category_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCategory_nameContext() *Category_nameContext {
	var p = new(Category_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_category_name
	return p
}

func (*Category_nameContext) IsCategory_nameContext() {}

func NewCategory_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Category_nameContext {
	var p = new(Category_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_category_name

	return p
}

func (s *Category_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Category_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Category_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Category_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Category_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCategory_name(s)
	}
}

func (s *Category_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCategory_name(s)
	}
}




func (p *ObjectiveCParser) Category_name() (localctx ICategory_nameContext) {
	localctx = NewCategory_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ObjectiveCParserRULE_category_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// IProtocol_nameContext is an interface to support dynamic dispatch.
type IProtocol_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_nameContext differentiates from other interfaces.
	IsProtocol_nameContext()
}

type Protocol_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_nameContext() *Protocol_nameContext {
	var p = new(Protocol_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_name
	return p
}

func (*Protocol_nameContext) IsProtocol_nameContext() {}

func NewProtocol_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_nameContext {
	var p = new(Protocol_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_name

	return p
}

func (s *Protocol_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Protocol_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_name(s)
	}
}

func (s *Protocol_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_name(s)
	}
}




func (p *ObjectiveCParser) Protocol_name() (localctx IProtocol_nameContext) {
	localctx = NewProtocol_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ObjectiveCParserRULE_protocol_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// IInstance_variablesContext is an interface to support dynamic dispatch.
type IInstance_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_variablesContext differentiates from other interfaces.
	IsInstance_variablesContext()
}

type Instance_variablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_variablesContext() *Instance_variablesContext {
	var p = new(Instance_variablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instance_variables
	return p
}

func (*Instance_variablesContext) IsInstance_variablesContext() {}

func NewInstance_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_variablesContext {
	var p = new(Instance_variablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instance_variables

	return p
}

func (s *Instance_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_variablesContext) Instance_variable_declaration() IInstance_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_variable_declarationContext)
}

func (s *Instance_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInstance_variables(s)
	}
}

func (s *Instance_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInstance_variables(s)
	}
}




func (p *ObjectiveCParser) Instance_variables() (localctx IInstance_variablesContext) {
	localctx = NewInstance_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ObjectiveCParserRULE_instance_variables)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(ObjectiveCParserT__25)
	}
	{
		p.SetState(361)
		p.Instance_variable_declaration()
	}
	{
		p.SetState(362)
		p.Match(ObjectiveCParserT__26)
	}



	return localctx
}


// IInstance_variable_declarationContext is an interface to support dynamic dispatch.
type IInstance_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_variable_declarationContext differentiates from other interfaces.
	IsInstance_variable_declarationContext()
}

type Instance_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_variable_declarationContext() *Instance_variable_declarationContext {
	var p = new(Instance_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instance_variable_declaration
	return p
}

func (*Instance_variable_declarationContext) IsInstance_variable_declarationContext() {}

func NewInstance_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_variable_declarationContext {
	var p = new(Instance_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instance_variable_declaration

	return p
}

func (s *Instance_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_variable_declarationContext) AllVisibility_specification() []IVisibility_specificationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVisibility_specificationContext)(nil)).Elem())
	var tst = make([]IVisibility_specificationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVisibility_specificationContext)
		}
	}

	return tst
}

func (s *Instance_variable_declarationContext) Visibility_specification(i int) IVisibility_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibility_specificationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVisibility_specificationContext)
}

func (s *Instance_variable_declarationContext) AllStruct_declarator_list() []IStruct_declarator_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declarator_listContext)(nil)).Elem())
	var tst = make([]IStruct_declarator_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declarator_listContext)
		}
	}

	return tst
}

func (s *Instance_variable_declarationContext) Struct_declarator_list(i int) IStruct_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarator_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarator_listContext)
}

func (s *Instance_variable_declarationContext) AllInstance_variables() []IInstance_variablesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem())
	var tst = make([]IInstance_variablesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_variablesContext)
		}
	}

	return tst
}

func (s *Instance_variable_declarationContext) Instance_variables(i int) IInstance_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_variablesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_variablesContext)
}

func (s *Instance_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInstance_variable_declaration(s)
	}
}

func (s *Instance_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInstance_variable_declaration(s)
	}
}




func (p *ObjectiveCParser) Instance_variable_declaration() (localctx IInstance_variable_declarationContext) {
	localctx = NewInstance_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ObjectiveCParserRULE_instance_variable_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__16) | (1 << ObjectiveCParserT__18) | (1 << ObjectiveCParserT__27) | (1 << ObjectiveCParserT__28) | (1 << ObjectiveCParserT__29) | (1 << ObjectiveCParserT__30))) != 0) || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserIDENTIFIER {
		p.SetState(368)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserT__27, ObjectiveCParserT__28, ObjectiveCParserT__29, ObjectiveCParserT__30:
			{
				p.SetState(364)
				p.Visibility_specification()
			}


		case ObjectiveCParserT__16, ObjectiveCParserT__18, ObjectiveCParserT__71, ObjectiveCParserIDENTIFIER:
			{
				p.SetState(365)
				p.Struct_declarator_list()
			}
			{
				p.SetState(366)
				p.Instance_variables()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IVisibility_specificationContext is an interface to support dynamic dispatch.
type IVisibility_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibility_specificationContext differentiates from other interfaces.
	IsVisibility_specificationContext()
}

type Visibility_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibility_specificationContext() *Visibility_specificationContext {
	var p = new(Visibility_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_visibility_specification
	return p
}

func (*Visibility_specificationContext) IsVisibility_specificationContext() {}

func NewVisibility_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Visibility_specificationContext {
	var p = new(Visibility_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_visibility_specification

	return p
}

func (s *Visibility_specificationContext) GetParser() antlr.Parser { return s.parser }
func (s *Visibility_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Visibility_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Visibility_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterVisibility_specification(s)
	}
}

func (s *Visibility_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitVisibility_specification(s)
	}
}




func (p *ObjectiveCParser) Visibility_specification() (localctx IVisibility_specificationContext) {
	localctx = NewVisibility_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ObjectiveCParserRULE_visibility_specification)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__27) | (1 << ObjectiveCParserT__28) | (1 << ObjectiveCParserT__29) | (1 << ObjectiveCParserT__30))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IInterface_declaration_listContext is an interface to support dynamic dispatch.
type IInterface_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declaration_listContext differentiates from other interfaces.
	IsInterface_declaration_listContext()
}

type Interface_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declaration_listContext() *Interface_declaration_listContext {
	var p = new(Interface_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_interface_declaration_list
	return p
}

func (*Interface_declaration_listContext) IsInterface_declaration_listContext() {}

func NewInterface_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declaration_listContext {
	var p = new(Interface_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_interface_declaration_list

	return p
}

func (s *Interface_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declaration_listContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Interface_declaration_listContext) AllClass_method_declaration() []IClass_method_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_method_declarationContext)(nil)).Elem())
	var tst = make([]IClass_method_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_method_declarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Class_method_declaration(i int) IClass_method_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_method_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_method_declarationContext)
}

func (s *Interface_declaration_listContext) AllInstance_method_declaration() []IInstance_method_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_method_declarationContext)(nil)).Elem())
	var tst = make([]IInstance_method_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_method_declarationContext)
		}
	}

	return tst
}

func (s *Interface_declaration_listContext) Instance_method_declaration(i int) IInstance_method_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_method_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_method_declarationContext)
}

func (s *Interface_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Interface_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInterface_declaration_list(s)
	}
}

func (s *Interface_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInterface_declaration_list(s)
	}
}




func (p *ObjectiveCParser) Interface_declaration_list() (localctx IInterface_declaration_listContext) {
	localctx = NewInterface_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ObjectiveCParserRULE_interface_declaration_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		p.SetState(377)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserT__33, ObjectiveCParserT__34, ObjectiveCParserT__35, ObjectiveCParserT__36, ObjectiveCParserT__37, ObjectiveCParserT__38, ObjectiveCParserT__39, ObjectiveCParserT__40, ObjectiveCParserT__41, ObjectiveCParserT__42, ObjectiveCParserT__43, ObjectiveCParserT__44, ObjectiveCParserT__45, ObjectiveCParserT__46, ObjectiveCParserT__47, ObjectiveCParserT__48, ObjectiveCParserT__49, ObjectiveCParserT__50, ObjectiveCParserT__62, ObjectiveCParserT__63, ObjectiveCParserT__64, ObjectiveCParserT__65, ObjectiveCParserT__66, ObjectiveCParserT__68, ObjectiveCParserT__69, ObjectiveCParserT__70, ObjectiveCParserIDENTIFIER:
			{
				p.SetState(374)
				p.Declaration()
			}


		case ObjectiveCParserT__31:
			{
				p.SetState(375)
				p.Class_method_declaration()
			}


		case ObjectiveCParserT__32:
			{
				p.SetState(376)
				p.Instance_method_declaration()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IClass_method_declarationContext is an interface to support dynamic dispatch.
type IClass_method_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_method_declarationContext differentiates from other interfaces.
	IsClass_method_declarationContext()
}

type Class_method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_method_declarationContext() *Class_method_declarationContext {
	var p = new(Class_method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_method_declaration
	return p
}

func (*Class_method_declarationContext) IsClass_method_declarationContext() {}

func NewClass_method_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_method_declarationContext {
	var p = new(Class_method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_method_declaration

	return p
}

func (s *Class_method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_method_declarationContext) Method_declaration() IMethod_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_declarationContext)
}

func (s *Class_method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_method_declaration(s)
	}
}

func (s *Class_method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_method_declaration(s)
	}
}




func (p *ObjectiveCParser) Class_method_declaration() (localctx IClass_method_declarationContext) {
	localctx = NewClass_method_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ObjectiveCParserRULE_class_method_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(ObjectiveCParserT__31)
	}
	{
		p.SetState(382)
		p.Method_declaration()
	}




	return localctx
}


// IInstance_method_declarationContext is an interface to support dynamic dispatch.
type IInstance_method_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_method_declarationContext differentiates from other interfaces.
	IsInstance_method_declarationContext()
}

type Instance_method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_method_declarationContext() *Instance_method_declarationContext {
	var p = new(Instance_method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instance_method_declaration
	return p
}

func (*Instance_method_declarationContext) IsInstance_method_declarationContext() {}

func NewInstance_method_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_method_declarationContext {
	var p = new(Instance_method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instance_method_declaration

	return p
}

func (s *Instance_method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_method_declarationContext) Method_declaration() IMethod_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_declarationContext)
}

func (s *Instance_method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInstance_method_declaration(s)
	}
}

func (s *Instance_method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInstance_method_declaration(s)
	}
}




func (p *ObjectiveCParser) Instance_method_declaration() (localctx IInstance_method_declarationContext) {
	localctx = NewInstance_method_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ObjectiveCParserRULE_instance_method_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(ObjectiveCParserT__32)
	}
	{
		p.SetState(385)
		p.Method_declaration()
	}




	return localctx
}


// IMethod_declarationContext is an interface to support dynamic dispatch.
type IMethod_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_declarationContext differentiates from other interfaces.
	IsMethod_declarationContext()
}

type Method_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_declarationContext() *Method_declarationContext {
	var p = new(Method_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_method_declaration
	return p
}

func (*Method_declarationContext) IsMethod_declarationContext() {}

func NewMethod_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_declarationContext {
	var p = new(Method_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_method_declaration

	return p
}

func (s *Method_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_declarationContext) Method_selector() IMethod_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_selectorContext)
}

func (s *Method_declarationContext) Method_type() IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Method_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMethod_declaration(s)
	}
}

func (s *Method_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMethod_declaration(s)
	}
}




func (p *ObjectiveCParser) Method_declaration() (localctx IMethod_declarationContext) {
	localctx = NewMethod_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ObjectiveCParserRULE_method_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__18 {
		{
			p.SetState(387)
			p.Method_type()
		}

	}
	{
		p.SetState(390)
		p.Method_selector()
	}
	{
		p.SetState(391)
		p.Match(ObjectiveCParserT__22)
	}



	return localctx
}


// IImplementation_definition_listContext is an interface to support dynamic dispatch.
type IImplementation_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementation_definition_listContext differentiates from other interfaces.
	IsImplementation_definition_listContext()
}

type Implementation_definition_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementation_definition_listContext() *Implementation_definition_listContext {
	var p = new(Implementation_definition_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_implementation_definition_list
	return p
}

func (*Implementation_definition_listContext) IsImplementation_definition_listContext() {}

func NewImplementation_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Implementation_definition_listContext {
	var p = new(Implementation_definition_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_implementation_definition_list

	return p
}

func (s *Implementation_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Implementation_definition_listContext) AllFunction_definition() []IFunction_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem())
	var tst = make([]IFunction_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Function_definition(i int) IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *Implementation_definition_listContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Implementation_definition_listContext) AllClass_method_definition() []IClass_method_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_method_definitionContext)(nil)).Elem())
	var tst = make([]IClass_method_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_method_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Class_method_definition(i int) IClass_method_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_method_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_method_definitionContext)
}

func (s *Implementation_definition_listContext) AllInstance_method_definition() []IInstance_method_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_method_definitionContext)(nil)).Elem())
	var tst = make([]IInstance_method_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_method_definitionContext)
		}
	}

	return tst
}

func (s *Implementation_definition_listContext) Instance_method_definition(i int) IInstance_method_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_method_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_method_definitionContext)
}

func (s *Implementation_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Implementation_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Implementation_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterImplementation_definition_list(s)
	}
}

func (s *Implementation_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitImplementation_definition_list(s)
	}
}




func (p *ObjectiveCParser) Implementation_definition_list() (localctx IImplementation_definition_listContext) {
	localctx = NewImplementation_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ObjectiveCParserRULE_implementation_definition_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (ObjectiveCParserT__31 - 32)) | (1 << (ObjectiveCParserT__32 - 32)) | (1 << (ObjectiveCParserT__33 - 32)) | (1 << (ObjectiveCParserT__34 - 32)) | (1 << (ObjectiveCParserT__35 - 32)) | (1 << (ObjectiveCParserT__36 - 32)) | (1 << (ObjectiveCParserT__37 - 32)) | (1 << (ObjectiveCParserT__38 - 32)) | (1 << (ObjectiveCParserT__39 - 32)) | (1 << (ObjectiveCParserT__40 - 32)) | (1 << (ObjectiveCParserT__41 - 32)) | (1 << (ObjectiveCParserT__42 - 32)) | (1 << (ObjectiveCParserT__43 - 32)) | (1 << (ObjectiveCParserT__44 - 32)) | (1 << (ObjectiveCParserT__45 - 32)) | (1 << (ObjectiveCParserT__46 - 32)) | (1 << (ObjectiveCParserT__47 - 32)) | (1 << (ObjectiveCParserT__48 - 32)) | (1 << (ObjectiveCParserT__49 - 32)) | (1 << (ObjectiveCParserT__50 - 32)) | (1 << (ObjectiveCParserT__62 - 32)))) != 0) || ((((_la - 64)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 64))) & ((1 << (ObjectiveCParserT__63 - 64)) | (1 << (ObjectiveCParserT__64 - 64)) | (1 << (ObjectiveCParserT__65 - 64)) | (1 << (ObjectiveCParserT__66 - 64)) | (1 << (ObjectiveCParserT__68 - 64)) | (1 << (ObjectiveCParserT__69 - 64)) | (1 << (ObjectiveCParserT__70 - 64)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(393)
				p.Function_definition()
			}


		case 2:
			{
				p.SetState(394)
				p.Declaration()
			}


		case 3:
			{
				p.SetState(395)
				p.Class_method_definition()
			}


		case 4:
			{
				p.SetState(396)
				p.Instance_method_definition()
			}

		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IClass_method_definitionContext is an interface to support dynamic dispatch.
type IClass_method_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_method_definitionContext differentiates from other interfaces.
	IsClass_method_definitionContext()
}

type Class_method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_method_definitionContext() *Class_method_definitionContext {
	var p = new(Class_method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_class_method_definition
	return p
}

func (*Class_method_definitionContext) IsClass_method_definitionContext() {}

func NewClass_method_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_method_definitionContext {
	var p = new(Class_method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_class_method_definition

	return p
}

func (s *Class_method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_method_definitionContext) Method_definition() IMethod_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_definitionContext)
}

func (s *Class_method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Class_method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterClass_method_definition(s)
	}
}

func (s *Class_method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitClass_method_definition(s)
	}
}




func (p *ObjectiveCParser) Class_method_definition() (localctx IClass_method_definitionContext) {
	localctx = NewClass_method_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ObjectiveCParserRULE_class_method_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Match(ObjectiveCParserT__31)
	}
	{
		p.SetState(402)
		p.Method_definition()
	}




	return localctx
}


// IInstance_method_definitionContext is an interface to support dynamic dispatch.
type IInstance_method_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_method_definitionContext differentiates from other interfaces.
	IsInstance_method_definitionContext()
}

type Instance_method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_method_definitionContext() *Instance_method_definitionContext {
	var p = new(Instance_method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_instance_method_definition
	return p
}

func (*Instance_method_definitionContext) IsInstance_method_definitionContext() {}

func NewInstance_method_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_method_definitionContext {
	var p = new(Instance_method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_instance_method_definition

	return p
}

func (s *Instance_method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_method_definitionContext) Method_definition() IMethod_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_definitionContext)
}

func (s *Instance_method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Instance_method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInstance_method_definition(s)
	}
}

func (s *Instance_method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInstance_method_definition(s)
	}
}




func (p *ObjectiveCParser) Instance_method_definition() (localctx IInstance_method_definitionContext) {
	localctx = NewInstance_method_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ObjectiveCParserRULE_instance_method_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(ObjectiveCParserT__32)
	}
	{
		p.SetState(405)
		p.Method_definition()
	}




	return localctx
}


// IMethod_definitionContext is an interface to support dynamic dispatch.
type IMethod_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_definitionContext differentiates from other interfaces.
	IsMethod_definitionContext()
}

type Method_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_definitionContext() *Method_definitionContext {
	var p = new(Method_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_method_definition
	return p
}

func (*Method_definitionContext) IsMethod_definitionContext() {}

func NewMethod_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_definitionContext {
	var p = new(Method_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_method_definition

	return p
}

func (s *Method_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_definitionContext) Method_selector() IMethod_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_selectorContext)
}

func (s *Method_definitionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Method_definitionContext) Method_type() IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Method_definitionContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Method_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMethod_definition(s)
	}
}

func (s *Method_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMethod_definition(s)
	}
}




func (p *ObjectiveCParser) Method_definition() (localctx IMethod_definitionContext) {
	localctx = NewMethod_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ObjectiveCParserRULE_method_definition)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__18 {
		{
			p.SetState(407)
			p.Method_type()
		}

	}
	{
		p.SetState(410)
		p.Method_selector()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__18 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(411)
			p.Init_declarator_list()
		}

	}
	{
		p.SetState(414)
		p.Compound_statement()
	}



	return localctx
}


// IMethod_selectorContext is an interface to support dynamic dispatch.
type IMethod_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_selectorContext differentiates from other interfaces.
	IsMethod_selectorContext()
}

type Method_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_selectorContext() *Method_selectorContext {
	var p = new(Method_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_method_selector
	return p
}

func (*Method_selectorContext) IsMethod_selectorContext() {}

func NewMethod_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_selectorContext {
	var p = new(Method_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_method_selector

	return p
}

func (s *Method_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_selectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Method_selectorContext) AllKeyword_declarator() []IKeyword_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyword_declaratorContext)(nil)).Elem())
	var tst = make([]IKeyword_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyword_declaratorContext)
		}
	}

	return tst
}

func (s *Method_selectorContext) Keyword_declarator(i int) IKeyword_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyword_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyword_declaratorContext)
}

func (s *Method_selectorContext) Parameter_list() IParameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_listContext)
}

func (s *Method_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMethod_selector(s)
	}
}

func (s *Method_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMethod_selector(s)
	}
}




func (p *ObjectiveCParser) Method_selector() (localctx IMethod_selectorContext) {
	localctx = NewMethod_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ObjectiveCParserRULE_method_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(416)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(417)
						p.Keyword_declarator()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(420)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(422)
				p.Parameter_list()
			}


		}


	}


	return localctx
}


// IKeyword_declaratorContext is an interface to support dynamic dispatch.
type IKeyword_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyword_declaratorContext differentiates from other interfaces.
	IsKeyword_declaratorContext()
}

type Keyword_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_declaratorContext() *Keyword_declaratorContext {
	var p = new(Keyword_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_keyword_declarator
	return p
}

func (*Keyword_declaratorContext) IsKeyword_declaratorContext() {}

func NewKeyword_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_declaratorContext {
	var p = new(Keyword_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_keyword_declarator

	return p
}

func (s *Keyword_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_declaratorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Keyword_declaratorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Keyword_declaratorContext) AllMethod_type() []IMethod_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem())
	var tst = make([]IMethod_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_typeContext)
		}
	}

	return tst
}

func (s *Keyword_declaratorContext) Method_type(i int) IMethod_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_typeContext)
}

func (s *Keyword_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterKeyword_declarator(s)
	}
}

func (s *Keyword_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitKeyword_declarator(s)
	}
}




func (p *ObjectiveCParser) Keyword_declarator() (localctx IKeyword_declaratorContext) {
	localctx = NewKeyword_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ObjectiveCParserRULE_keyword_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(427)
			p.Selector()
		}

	}
	{
		p.SetState(430)
		p.Match(ObjectiveCParserT__16)
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__18 {
		{
			p.SetState(431)
			p.Method_type()
		}


		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(437)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selector
	return p
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSelector(s)
	}
}

func (s *SelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSelector(s)
	}
}




func (p *ObjectiveCParser) Selector() (localctx ISelectorContext) {
	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ObjectiveCParserRULE_selector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// IMethod_typeContext is an interface to support dynamic dispatch.
type IMethod_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_typeContext differentiates from other interfaces.
	IsMethod_typeContext()
}

type Method_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_typeContext() *Method_typeContext {
	var p = new(Method_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_method_type
	return p
}

func (*Method_typeContext) IsMethod_typeContext() {}

func NewMethod_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_typeContext {
	var p = new(Method_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_method_type

	return p
}

func (s *Method_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_typeContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Method_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Method_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMethod_type(s)
	}
}

func (s *Method_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMethod_type(s)
	}
}




func (p *ObjectiveCParser) Method_type() (localctx IMethod_typeContext) {
	localctx = NewMethod_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ObjectiveCParserRULE_method_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(442)
		p.Type_name()
	}
	{
		p.SetState(443)
		p.Match(ObjectiveCParserT__19)
	}



	return localctx
}


// IType_specifierContext is an interface to support dynamic dispatch.
type IType_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifierContext differentiates from other interfaces.
	IsType_specifierContext()
}

type Type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifierContext() *Type_specifierContext {
	var p = new(Type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_type_specifier
	return p
}

func (*Type_specifierContext) IsType_specifierContext() {}

func NewType_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifierContext {
	var p = new(Type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_type_specifier

	return p
}

func (s *Type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifierContext) Protocol_reference_list() IProtocol_reference_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_reference_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_reference_listContext)
}

func (s *Type_specifierContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Type_specifierContext) Struct_or_union_specifier() IStruct_or_union_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_or_union_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_or_union_specifierContext)
}

func (s *Type_specifierContext) Enum_specifier() IEnum_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_specifierContext)
}

func (s *Type_specifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterType_specifier(s)
	}
}

func (s *Type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitType_specifier(s)
	}
}




func (p *ObjectiveCParser) Type_specifier() (localctx IType_specifierContext) {
	localctx = NewType_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ObjectiveCParserRULE_type_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.Match(ObjectiveCParserT__33)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.Match(ObjectiveCParserT__34)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(447)
			p.Match(ObjectiveCParserT__35)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(448)
			p.Match(ObjectiveCParserT__36)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(449)
			p.Match(ObjectiveCParserT__37)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(450)
			p.Match(ObjectiveCParserT__38)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(451)
			p.Match(ObjectiveCParserT__39)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(452)
			p.Match(ObjectiveCParserT__40)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(453)
			p.Match(ObjectiveCParserT__41)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(454)
			p.Match(ObjectiveCParserT__42)
		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjectiveCParserT__8 {
			{
				p.SetState(455)
				p.Protocol_reference_list()
			}

		}



	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(458)
			p.Class_name()
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjectiveCParserT__8 {
			{
				p.SetState(459)
				p.Protocol_reference_list()
			}

		}



	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(462)
			p.Struct_or_union_specifier()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(463)
			p.Enum_specifier()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(464)
			p.Match(ObjectiveCParserIDENTIFIER)
		}

	}


	return localctx
}


// IType_qualifierContext is an interface to support dynamic dispatch.
type IType_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_qualifierContext differentiates from other interfaces.
	IsType_qualifierContext()
}

type Type_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_qualifierContext() *Type_qualifierContext {
	var p = new(Type_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_type_qualifier
	return p
}

func (*Type_qualifierContext) IsType_qualifierContext() {}

func NewType_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_qualifierContext {
	var p = new(Type_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_type_qualifier

	return p
}

func (s *Type_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_qualifierContext) Protocol_qualifier() IProtocol_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_qualifierContext)
}

func (s *Type_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterType_qualifier(s)
	}
}

func (s *Type_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitType_qualifier(s)
	}
}




func (p *ObjectiveCParser) Type_qualifier() (localctx IType_qualifierContext) {
	localctx = NewType_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ObjectiveCParserRULE_type_qualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__43:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(467)
			p.Match(ObjectiveCParserT__43)
		}


	case ObjectiveCParserT__44:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(468)
			p.Match(ObjectiveCParserT__44)
		}


	case ObjectiveCParserT__45, ObjectiveCParserT__46, ObjectiveCParserT__47, ObjectiveCParserT__48, ObjectiveCParserT__49, ObjectiveCParserT__50:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.Protocol_qualifier()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IProtocol_qualifierContext is an interface to support dynamic dispatch.
type IProtocol_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_qualifierContext differentiates from other interfaces.
	IsProtocol_qualifierContext()
}

type Protocol_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_qualifierContext() *Protocol_qualifierContext {
	var p = new(Protocol_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_qualifier
	return p
}

func (*Protocol_qualifierContext) IsProtocol_qualifierContext() {}

func NewProtocol_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_qualifierContext {
	var p = new(Protocol_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_qualifier

	return p
}

func (s *Protocol_qualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *Protocol_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_qualifier(s)
	}
}

func (s *Protocol_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_qualifier(s)
	}
}




func (p *ObjectiveCParser) Protocol_qualifier() (localctx IProtocol_qualifierContext) {
	localctx = NewProtocol_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ObjectiveCParserRULE_protocol_qualifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 46)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 46))) & ((1 << (ObjectiveCParserT__45 - 46)) | (1 << (ObjectiveCParserT__46 - 46)) | (1 << (ObjectiveCParserT__47 - 46)) | (1 << (ObjectiveCParserT__48 - 46)) | (1 << (ObjectiveCParserT__49 - 46)) | (1 << (ObjectiveCParserT__50 - 46)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IPrimary_expressionContext is an interface to support dynamic dispatch.
type IPrimary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_expressionContext differentiates from other interfaces.
	IsPrimary_expressionContext()
}

type Primary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_expressionContext() *Primary_expressionContext {
	var p = new(Primary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_primary_expression
	return p
}

func (*Primary_expressionContext) IsPrimary_expressionContext() {}

func NewPrimary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_expressionContext {
	var p = new(Primary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_primary_expression

	return p
}

func (s *Primary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_expressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Primary_expressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Primary_expressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserSTRING_LITERAL, 0)
}

func (s *Primary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Primary_expressionContext) Message_expression() IMessage_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessage_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessage_expressionContext)
}

func (s *Primary_expressionContext) Selector_expression() ISelector_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelector_expressionContext)
}

func (s *Primary_expressionContext) Protocol_expression() IProtocol_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_expressionContext)
}

func (s *Primary_expressionContext) Encode_expression() IEncode_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncode_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncode_expressionContext)
}

func (s *Primary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Primary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterPrimary_expression(s)
	}
}

func (s *Primary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitPrimary_expression(s)
	}
}




func (p *ObjectiveCParser) Primary_expression() (localctx IPrimary_expressionContext) {
	localctx = NewPrimary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ObjectiveCParserRULE_primary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(486)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Match(ObjectiveCParserIDENTIFIER)
		}


	case ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(475)
			p.Constant()
		}


	case ObjectiveCParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(476)
			p.Match(ObjectiveCParserSTRING_LITERAL)
		}


	case ObjectiveCParserT__18:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(477)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(478)
			p.Expression()
		}
		{
			p.SetState(479)
			p.Match(ObjectiveCParserT__19)
		}



	case ObjectiveCParserT__51:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(481)
			p.Match(ObjectiveCParserT__51)
		}


	case ObjectiveCParserT__52:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(482)
			p.Message_expression()
		}


	case ObjectiveCParserT__55:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(483)
			p.Selector_expression()
		}


	case ObjectiveCParserT__21:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(484)
			p.Protocol_expression()
		}


	case ObjectiveCParserT__56:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(485)
			p.Encode_expression()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IMessage_expressionContext is an interface to support dynamic dispatch.
type IMessage_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessage_expressionContext differentiates from other interfaces.
	IsMessage_expressionContext()
}

type Message_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessage_expressionContext() *Message_expressionContext {
	var p = new(Message_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_message_expression
	return p
}

func (*Message_expressionContext) IsMessage_expressionContext() {}

func NewMessage_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Message_expressionContext {
	var p = new(Message_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_message_expression

	return p
}

func (s *Message_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Message_expressionContext) Receiver() IReceiverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiverContext)
}

func (s *Message_expressionContext) Message_selector() IMessage_selectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessage_selectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMessage_selectorContext)
}

func (s *Message_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Message_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Message_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMessage_expression(s)
	}
}

func (s *Message_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMessage_expression(s)
	}
}




func (p *ObjectiveCParser) Message_expression() (localctx IMessage_expressionContext) {
	localctx = NewMessage_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ObjectiveCParserRULE_message_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Match(ObjectiveCParserT__52)
	}
	{
		p.SetState(489)
		p.Receiver()
	}
	{
		p.SetState(490)
		p.Message_selector()
	}
	{
		p.SetState(491)
		p.Match(ObjectiveCParserT__53)
	}




	return localctx
}


// IReceiverContext is an interface to support dynamic dispatch.
type IReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverContext differentiates from other interfaces.
	IsReceiverContext()
}

type ReceiverContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverContext() *ReceiverContext {
	var p = new(ReceiverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_receiver
	return p
}

func (*ReceiverContext) IsReceiverContext() {}

func NewReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverContext {
	var p = new(ReceiverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_receiver

	return p
}

func (s *ReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReceiverContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *ReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterReceiver(s)
	}
}

func (s *ReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitReceiver(s)
	}
}




func (p *ObjectiveCParser) Receiver() (localctx IReceiverContext) {
	localctx = NewReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ObjectiveCParserRULE_receiver)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)
			p.Expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(494)
			p.Class_name()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(495)
			p.Match(ObjectiveCParserT__54)
		}

	}


	return localctx
}


// IMessage_selectorContext is an interface to support dynamic dispatch.
type IMessage_selectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessage_selectorContext differentiates from other interfaces.
	IsMessage_selectorContext()
}

type Message_selectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessage_selectorContext() *Message_selectorContext {
	var p = new(Message_selectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_message_selector
	return p
}

func (*Message_selectorContext) IsMessage_selectorContext() {}

func NewMessage_selectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Message_selectorContext {
	var p = new(Message_selectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_message_selector

	return p
}

func (s *Message_selectorContext) GetParser() antlr.Parser { return s.parser }

func (s *Message_selectorContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Message_selectorContext) AllKeyword_argument() []IKeyword_argumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyword_argumentContext)(nil)).Elem())
	var tst = make([]IKeyword_argumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyword_argumentContext)
		}
	}

	return tst
}

func (s *Message_selectorContext) Keyword_argument(i int) IKeyword_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyword_argumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyword_argumentContext)
}

func (s *Message_selectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Message_selectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Message_selectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMessage_selector(s)
	}
}

func (s *Message_selectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMessage_selector(s)
	}
}




func (p *ObjectiveCParser) Message_selector() (localctx IMessage_selectorContext) {
	localctx = NewMessage_selectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ObjectiveCParserRULE_message_selector)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(498)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjectiveCParserT__16 || _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(499)
				p.Keyword_argument()
			}


			p.SetState(502)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}


	return localctx
}


// IKeyword_argumentContext is an interface to support dynamic dispatch.
type IKeyword_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyword_argumentContext differentiates from other interfaces.
	IsKeyword_argumentContext()
}

type Keyword_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_argumentContext() *Keyword_argumentContext {
	var p = new(Keyword_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_keyword_argument
	return p
}

func (*Keyword_argumentContext) IsKeyword_argumentContext() {}

func NewKeyword_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_argumentContext {
	var p = new(Keyword_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_keyword_argument

	return p
}

func (s *Keyword_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_argumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Keyword_argumentContext) Selector() ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Keyword_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Keyword_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterKeyword_argument(s)
	}
}

func (s *Keyword_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitKeyword_argument(s)
	}
}




func (p *ObjectiveCParser) Keyword_argument() (localctx IKeyword_argumentContext) {
	localctx = NewKeyword_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ObjectiveCParserRULE_keyword_argument)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(506)
			p.Selector()
		}

	}
	{
		p.SetState(509)
		p.Match(ObjectiveCParserT__16)
	}
	{
		p.SetState(510)
		p.Expression()
	}



	return localctx
}


// ISelector_expressionContext is an interface to support dynamic dispatch.
type ISelector_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_expressionContext differentiates from other interfaces.
	IsSelector_expressionContext()
}

type Selector_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_expressionContext() *Selector_expressionContext {
	var p = new(Selector_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selector_expression
	return p
}

func (*Selector_expressionContext) IsSelector_expressionContext() {}

func NewSelector_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_expressionContext {
	var p = new(Selector_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selector_expression

	return p
}

func (s *Selector_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_expressionContext) Selector_name() ISelector_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelector_nameContext)
}

func (s *Selector_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selector_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSelector_expression(s)
	}
}

func (s *Selector_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSelector_expression(s)
	}
}




func (p *ObjectiveCParser) Selector_expression() (localctx ISelector_expressionContext) {
	localctx = NewSelector_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ObjectiveCParserRULE_selector_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(ObjectiveCParserT__55)
	}
	{
		p.SetState(513)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(514)
		p.Selector_name()
	}
	{
		p.SetState(515)
		p.Match(ObjectiveCParserT__19)
	}



	return localctx
}


// ISelector_nameContext is an interface to support dynamic dispatch.
type ISelector_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_nameContext differentiates from other interfaces.
	IsSelector_nameContext()
}

type Selector_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_nameContext() *Selector_nameContext {
	var p = new(Selector_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selector_name
	return p
}

func (*Selector_nameContext) IsSelector_nameContext() {}

func NewSelector_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_nameContext {
	var p = new(Selector_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selector_name

	return p
}

func (s *Selector_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_nameContext) AllSelector() []ISelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectorContext)(nil)).Elem())
	var tst = make([]ISelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectorContext)
		}
	}

	return tst
}

func (s *Selector_nameContext) Selector(i int) ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *Selector_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selector_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSelector_name(s)
	}
}

func (s *Selector_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSelector_name(s)
	}
}




func (p *ObjectiveCParser) Selector_name() (localctx ISelector_nameContext) {
	localctx = NewSelector_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ObjectiveCParserRULE_selector_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(517)
			p.Selector()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjectiveCParserT__16 || _la == ObjectiveCParserIDENTIFIER {
			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == ObjectiveCParserIDENTIFIER {
				{
					p.SetState(518)
					p.Selector()
				}

			}
			{
				p.SetState(521)
				p.Match(ObjectiveCParserT__16)
			}


			p.SetState(524)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}


	return localctx
}


// IProtocol_expressionContext is an interface to support dynamic dispatch.
type IProtocol_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProtocol_expressionContext differentiates from other interfaces.
	IsProtocol_expressionContext()
}

type Protocol_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProtocol_expressionContext() *Protocol_expressionContext {
	var p = new(Protocol_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_protocol_expression
	return p
}

func (*Protocol_expressionContext) IsProtocol_expressionContext() {}

func NewProtocol_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Protocol_expressionContext {
	var p = new(Protocol_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_protocol_expression

	return p
}

func (s *Protocol_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Protocol_expressionContext) Protocol_name() IProtocol_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProtocol_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProtocol_nameContext)
}

func (s *Protocol_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Protocol_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Protocol_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterProtocol_expression(s)
	}
}

func (s *Protocol_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitProtocol_expression(s)
	}
}




func (p *ObjectiveCParser) Protocol_expression() (localctx IProtocol_expressionContext) {
	localctx = NewProtocol_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ObjectiveCParserRULE_protocol_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(ObjectiveCParserT__21)
	}
	{
		p.SetState(529)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(530)
		p.Protocol_name()
	}
	{
		p.SetState(531)
		p.Match(ObjectiveCParserT__19)
	}



	return localctx
}


// IEncode_expressionContext is an interface to support dynamic dispatch.
type IEncode_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncode_expressionContext differentiates from other interfaces.
	IsEncode_expressionContext()
}

type Encode_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncode_expressionContext() *Encode_expressionContext {
	var p = new(Encode_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_encode_expression
	return p
}

func (*Encode_expressionContext) IsEncode_expressionContext() {}

func NewEncode_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encode_expressionContext {
	var p = new(Encode_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_encode_expression

	return p
}

func (s *Encode_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Encode_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Encode_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encode_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Encode_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterEncode_expression(s)
	}
}

func (s *Encode_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitEncode_expression(s)
	}
}




func (p *ObjectiveCParser) Encode_expression() (localctx IEncode_expressionContext) {
	localctx = NewEncode_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ObjectiveCParserRULE_encode_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(ObjectiveCParserT__56)
	}
	{
		p.SetState(534)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(535)
		p.Type_name()
	}
	{
		p.SetState(536)
		p.Match(ObjectiveCParserT__19)
	}



	return localctx
}


// IException_declaratorContext is an interface to support dynamic dispatch.
type IException_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_declaratorContext differentiates from other interfaces.
	IsException_declaratorContext()
}

type Exception_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_declaratorContext() *Exception_declaratorContext {
	var p = new(Exception_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_exception_declarator
	return p
}

func (*Exception_declaratorContext) IsException_declaratorContext() {}

func NewException_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_declaratorContext {
	var p = new(Exception_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_exception_declarator

	return p
}

func (s *Exception_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Exception_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exception_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterException_declarator(s)
	}
}

func (s *Exception_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitException_declarator(s)
	}
}




func (p *ObjectiveCParser) Exception_declarator() (localctx IException_declaratorContext) {
	localctx = NewException_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ObjectiveCParserRULE_exception_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.Declarator()
	}



	return localctx
}


// ITry_statementContext is an interface to support dynamic dispatch.
type ITry_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_statementContext differentiates from other interfaces.
	IsTry_statementContext()
}

type Try_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_statementContext() *Try_statementContext {
	var p = new(Try_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_try_statement
	return p
}

func (*Try_statementContext) IsTry_statementContext() {}

func NewTry_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_statementContext {
	var p = new(Try_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_try_statement

	return p
}

func (s *Try_statementContext) GetParser() antlr.Parser { return s.parser }
func (s *Try_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterTry_statement(s)
	}
}

func (s *Try_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitTry_statement(s)
	}
}




func (p *ObjectiveCParser) Try_statement() (localctx ITry_statementContext) {
	localctx = NewTry_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ObjectiveCParserRULE_try_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Match(ObjectiveCParserT__57)
	}



	return localctx
}


// ICatch_statementContext is an interface to support dynamic dispatch.
type ICatch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatch_statementContext differentiates from other interfaces.
	IsCatch_statementContext()
}

type Catch_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatch_statementContext() *Catch_statementContext {
	var p = new(Catch_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_catch_statement
	return p
}

func (*Catch_statementContext) IsCatch_statementContext() {}

func NewCatch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Catch_statementContext {
	var p = new(Catch_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_catch_statement

	return p
}

func (s *Catch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Catch_statementContext) Exception_declarator() IException_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declaratorContext)
}

func (s *Catch_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Catch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Catch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Catch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCatch_statement(s)
	}
}

func (s *Catch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCatch_statement(s)
	}
}




func (p *ObjectiveCParser) Catch_statement() (localctx ICatch_statementContext) {
	localctx = NewCatch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ObjectiveCParserRULE_catch_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(ObjectiveCParserT__58)
	}
	{
		p.SetState(543)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(544)
		p.Exception_declarator()
	}
	{
		p.SetState(545)
		p.Match(ObjectiveCParserT__19)
	}
	{
		p.SetState(546)
		p.Statement()
	}



	return localctx
}


// IFinally_statementContext is an interface to support dynamic dispatch.
type IFinally_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinally_statementContext differentiates from other interfaces.
	IsFinally_statementContext()
}

type Finally_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_statementContext() *Finally_statementContext {
	var p = new(Finally_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_finally_statement
	return p
}

func (*Finally_statementContext) IsFinally_statementContext() {}

func NewFinally_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_statementContext {
	var p = new(Finally_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_finally_statement

	return p
}

func (s *Finally_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Finally_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Finally_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Finally_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterFinally_statement(s)
	}
}

func (s *Finally_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitFinally_statement(s)
	}
}




func (p *ObjectiveCParser) Finally_statement() (localctx IFinally_statementContext) {
	localctx = NewFinally_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ObjectiveCParserRULE_finally_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Match(ObjectiveCParserT__59)
	}
	{
		p.SetState(549)
		p.Statement()
	}



	return localctx
}


// IThrow_statementContext is an interface to support dynamic dispatch.
type IThrow_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_statementContext differentiates from other interfaces.
	IsThrow_statementContext()
}

type Throw_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_statementContext() *Throw_statementContext {
	var p = new(Throw_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_throw_statement
	return p
}

func (*Throw_statementContext) IsThrow_statementContext() {}

func NewThrow_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_statementContext {
	var p = new(Throw_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_throw_statement

	return p
}

func (s *Throw_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_statementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Throw_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Throw_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterThrow_statement(s)
	}
}

func (s *Throw_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitThrow_statement(s)
	}
}




func (p *ObjectiveCParser) Throw_statement() (localctx IThrow_statementContext) {
	localctx = NewThrow_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ObjectiveCParserRULE_throw_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(ObjectiveCParserT__60)
	}
	{
		p.SetState(552)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(553)
		p.Match(ObjectiveCParserIDENTIFIER)
	}
	{
		p.SetState(554)
		p.Match(ObjectiveCParserT__19)
	}



	return localctx
}


// ITry_blockContext is an interface to support dynamic dispatch.
type ITry_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_blockContext differentiates from other interfaces.
	IsTry_blockContext()
}

type Try_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_blockContext() *Try_blockContext {
	var p = new(Try_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_try_block
	return p
}

func (*Try_blockContext) IsTry_blockContext() {}

func NewTry_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_blockContext {
	var p = new(Try_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_try_block

	return p
}

func (s *Try_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_blockContext) Try_statement() ITry_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_statementContext)
}

func (s *Try_blockContext) Catch_statement() ICatch_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatch_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatch_statementContext)
}

func (s *Try_blockContext) Finally_statement() IFinally_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinally_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinally_statementContext)
}

func (s *Try_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterTry_block(s)
	}
}

func (s *Try_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitTry_block(s)
	}
}




func (p *ObjectiveCParser) Try_block() (localctx ITry_blockContext) {
	localctx = NewTry_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ObjectiveCParserRULE_try_block)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Try_statement()
	}
	{
		p.SetState(557)
		p.Catch_statement()
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__59 {
		{
			p.SetState(558)
			p.Finally_statement()
		}

	}



	return localctx
}


// ISynchronized_statementContext is an interface to support dynamic dispatch.
type ISynchronized_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSynchronized_statementContext differentiates from other interfaces.
	IsSynchronized_statementContext()
}

type Synchronized_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynchronized_statementContext() *Synchronized_statementContext {
	var p = new(Synchronized_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_synchronized_statement
	return p
}

func (*Synchronized_statementContext) IsSynchronized_statementContext() {}

func NewSynchronized_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Synchronized_statementContext {
	var p = new(Synchronized_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_synchronized_statement

	return p
}

func (s *Synchronized_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Synchronized_statementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Synchronized_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Synchronized_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Synchronized_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Synchronized_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSynchronized_statement(s)
	}
}

func (s *Synchronized_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSynchronized_statement(s)
	}
}




func (p *ObjectiveCParser) Synchronized_statement() (localctx ISynchronized_statementContext) {
	localctx = NewSynchronized_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ObjectiveCParserRULE_synchronized_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		p.Match(ObjectiveCParserT__61)
	}
	{
		p.SetState(562)
		p.Match(ObjectiveCParserT__18)
	}
	{
		p.SetState(563)
		p.Match(ObjectiveCParserIDENTIFIER)
	}
	{
		p.SetState(564)
		p.Match(ObjectiveCParserT__19)
	}
	{
		p.SetState(565)
		p.Statement()
	}



	return localctx
}


// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *Function_definitionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Function_definitionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}




func (p *ObjectiveCParser) Function_definition() (localctx IFunction_definitionContext) {
	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ObjectiveCParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.Declaration_specifiers()
	}
	{
		p.SetState(568)
		p.Declarator()
	}
	{
		p.SetState(569)
		p.Compound_statement()
	}



	return localctx
}


// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *DeclarationContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitDeclaration(s)
	}
}




func (p *ObjectiveCParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ObjectiveCParserRULE_declaration)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(571)
		p.Declaration_specifiers()
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__18 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserIDENTIFIER {
		{
			p.SetState(572)
			p.Init_declarator_list()
		}

	}
	{
		p.SetState(575)
		p.Match(ObjectiveCParserT__22)
	}



	return localctx
}


// IDeclaration_specifiersContext is an interface to support dynamic dispatch.
type IDeclaration_specifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_specifiersContext differentiates from other interfaces.
	IsDeclaration_specifiersContext()
}

type Declaration_specifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_specifiersContext() *Declaration_specifiersContext {
	var p = new(Declaration_specifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declaration_specifiers
	return p
}

func (*Declaration_specifiersContext) IsDeclaration_specifiersContext() {}

func NewDeclaration_specifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_specifiersContext {
	var p = new(Declaration_specifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declaration_specifiers

	return p
}

func (s *Declaration_specifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_specifiersContext) AllStorage_class_specifier() []IStorage_class_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStorage_class_specifierContext)(nil)).Elem())
	var tst = make([]IStorage_class_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStorage_class_specifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Storage_class_specifier(i int) IStorage_class_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStorage_class_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStorage_class_specifierContext)
}

func (s *Declaration_specifiersContext) AllType_specifier() []IType_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specifierContext)(nil)).Elem())
	var tst = make([]IType_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Type_specifier(i int) IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Declaration_specifiersContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *Declaration_specifiersContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *Declaration_specifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_specifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declaration_specifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterDeclaration_specifiers(s)
	}
}

func (s *Declaration_specifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitDeclaration_specifiers(s)
	}
}




func (p *ObjectiveCParser) Declaration_specifiers() (localctx IDeclaration_specifiersContext) {
	localctx = NewDeclaration_specifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ObjectiveCParserRULE_declaration_specifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(580)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjectiveCParserT__62, ObjectiveCParserT__63, ObjectiveCParserT__64, ObjectiveCParserT__65, ObjectiveCParserT__66:
					{
						p.SetState(577)
						p.Storage_class_specifier()
					}


				case ObjectiveCParserT__33, ObjectiveCParserT__34, ObjectiveCParserT__35, ObjectiveCParserT__36, ObjectiveCParserT__37, ObjectiveCParserT__38, ObjectiveCParserT__39, ObjectiveCParserT__40, ObjectiveCParserT__41, ObjectiveCParserT__42, ObjectiveCParserT__68, ObjectiveCParserT__69, ObjectiveCParserT__70, ObjectiveCParserIDENTIFIER:
					{
						p.SetState(578)
						p.Type_specifier()
					}


				case ObjectiveCParserT__43, ObjectiveCParserT__44, ObjectiveCParserT__45, ObjectiveCParserT__46, ObjectiveCParserT__47, ObjectiveCParserT__48, ObjectiveCParserT__49, ObjectiveCParserT__50:
					{
						p.SetState(579)
						p.Type_qualifier()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}



	return localctx
}


// IStorage_class_specifierContext is an interface to support dynamic dispatch.
type IStorage_class_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStorage_class_specifierContext differentiates from other interfaces.
	IsStorage_class_specifierContext()
}

type Storage_class_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorage_class_specifierContext() *Storage_class_specifierContext {
	var p = new(Storage_class_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_storage_class_specifier
	return p
}

func (*Storage_class_specifierContext) IsStorage_class_specifierContext() {}

func NewStorage_class_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Storage_class_specifierContext {
	var p = new(Storage_class_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_storage_class_specifier

	return p
}

func (s *Storage_class_specifierContext) GetParser() antlr.Parser { return s.parser }
func (s *Storage_class_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Storage_class_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Storage_class_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStorage_class_specifier(s)
	}
}

func (s *Storage_class_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStorage_class_specifier(s)
	}
}




func (p *ObjectiveCParser) Storage_class_specifier() (localctx IStorage_class_specifierContext) {
	localctx = NewStorage_class_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ObjectiveCParserRULE_storage_class_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 63)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 63))) & ((1 << (ObjectiveCParserT__62 - 63)) | (1 << (ObjectiveCParserT__63 - 63)) | (1 << (ObjectiveCParserT__64 - 63)) | (1 << (ObjectiveCParserT__65 - 63)) | (1 << (ObjectiveCParserT__66 - 63)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IInit_declarator_listContext is an interface to support dynamic dispatch.
type IInit_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declarator_listContext differentiates from other interfaces.
	IsInit_declarator_listContext()
}

type Init_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declarator_listContext() *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_init_declarator_list
	return p
}

func (*Init_declarator_listContext) IsInit_declarator_listContext() {}

func NewInit_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_init_declarator_list

	return p
}

func (s *Init_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declarator_listContext) AllInit_declarator() []IInit_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem())
	var tst = make([]IInit_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInit_declaratorContext)
		}
	}

	return tst
}

func (s *Init_declarator_listContext) Init_declarator(i int) IInit_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInit_declaratorContext)
}

func (s *Init_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Init_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInit_declarator_list(s)
	}
}

func (s *Init_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInit_declarator_list(s)
	}
}




func (p *ObjectiveCParser) Init_declarator_list() (localctx IInit_declarator_listContext) {
	localctx = NewInit_declarator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ObjectiveCParserRULE_init_declarator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Init_declarator()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(587)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(588)
			p.Init_declarator()
		}


		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IInit_declaratorContext is an interface to support dynamic dispatch.
type IInit_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declaratorContext differentiates from other interfaces.
	IsInit_declaratorContext()
}

type Init_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declaratorContext() *Init_declaratorContext {
	var p = new(Init_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_init_declarator
	return p
}

func (*Init_declaratorContext) IsInit_declaratorContext() {}

func NewInit_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declaratorContext {
	var p = new(Init_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_init_declarator

	return p
}

func (s *Init_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Init_declaratorContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *Init_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Init_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInit_declarator(s)
	}
}

func (s *Init_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInit_declarator(s)
	}
}




func (p *ObjectiveCParser) Init_declarator() (localctx IInit_declaratorContext) {
	localctx = NewInit_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ObjectiveCParserRULE_init_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.Declarator()
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__67 {
		{
			p.SetState(595)
			p.Match(ObjectiveCParserT__67)
		}
		{
			p.SetState(596)
			p.Initializer()
		}

	}



	return localctx
}


// IStruct_or_union_specifierContext is an interface to support dynamic dispatch.
type IStruct_or_union_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_or_union_specifierContext differentiates from other interfaces.
	IsStruct_or_union_specifierContext()
}

type Struct_or_union_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_or_union_specifierContext() *Struct_or_union_specifierContext {
	var p = new(Struct_or_union_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_struct_or_union_specifier
	return p
}

func (*Struct_or_union_specifierContext) IsStruct_or_union_specifierContext() {}

func NewStruct_or_union_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_or_union_specifierContext {
	var p = new(Struct_or_union_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_struct_or_union_specifier

	return p
}

func (s *Struct_or_union_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_or_union_specifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *Struct_or_union_specifierContext) AllStruct_declaration() []IStruct_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem())
	var tst = make([]IStruct_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declarationContext)
		}
	}

	return tst
}

func (s *Struct_or_union_specifierContext) Struct_declaration(i int) IStruct_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarationContext)
}

func (s *Struct_or_union_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_or_union_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_or_union_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStruct_or_union_specifier(s)
	}
}

func (s *Struct_or_union_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStruct_or_union_specifier(s)
	}
}




func (p *ObjectiveCParser) Struct_or_union_specifier() (localctx IStruct_or_union_specifierContext) {
	localctx = NewStruct_or_union_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ObjectiveCParserRULE_struct_or_union_specifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserT__68 || _la == ObjectiveCParserT__69) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(600)
			p.Match(ObjectiveCParserIDENTIFIER)
		}


	case 2:
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(601)
				p.Match(ObjectiveCParserIDENTIFIER)
			}

		}
		{
			p.SetState(604)
			p.Match(ObjectiveCParserT__25)
		}
		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((((_la - 34)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 34))) & ((1 << (ObjectiveCParserT__33 - 34)) | (1 << (ObjectiveCParserT__34 - 34)) | (1 << (ObjectiveCParserT__35 - 34)) | (1 << (ObjectiveCParserT__36 - 34)) | (1 << (ObjectiveCParserT__37 - 34)) | (1 << (ObjectiveCParserT__38 - 34)) | (1 << (ObjectiveCParserT__39 - 34)) | (1 << (ObjectiveCParserT__40 - 34)) | (1 << (ObjectiveCParserT__41 - 34)) | (1 << (ObjectiveCParserT__42 - 34)) | (1 << (ObjectiveCParserT__43 - 34)) | (1 << (ObjectiveCParserT__44 - 34)) | (1 << (ObjectiveCParserT__45 - 34)) | (1 << (ObjectiveCParserT__46 - 34)) | (1 << (ObjectiveCParserT__47 - 34)) | (1 << (ObjectiveCParserT__48 - 34)) | (1 << (ObjectiveCParserT__49 - 34)) | (1 << (ObjectiveCParserT__50 - 34)))) != 0) || ((((_la - 69)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 69))) & ((1 << (ObjectiveCParserT__68 - 69)) | (1 << (ObjectiveCParserT__69 - 69)) | (1 << (ObjectiveCParserT__70 - 69)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(605)
				p.Struct_declaration()
			}


			p.SetState(608)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(610)
			p.Match(ObjectiveCParserT__26)
		}

	}



	return localctx
}


// IStruct_declarationContext is an interface to support dynamic dispatch.
type IStruct_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declarationContext differentiates from other interfaces.
	IsStruct_declarationContext()
}

type Struct_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declarationContext() *Struct_declarationContext {
	var p = new(Struct_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_struct_declaration
	return p
}

func (*Struct_declarationContext) IsStruct_declarationContext() {}

func NewStruct_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declarationContext {
	var p = new(Struct_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_struct_declaration

	return p
}

func (s *Struct_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declarationContext) Specifier_qualifier_list() ISpecifier_qualifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifier_qualifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifier_qualifier_listContext)
}

func (s *Struct_declarationContext) Struct_declarator_list() IStruct_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_declarator_listContext)
}

func (s *Struct_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStruct_declaration(s)
	}
}

func (s *Struct_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStruct_declaration(s)
	}
}




func (p *ObjectiveCParser) Struct_declaration() (localctx IStruct_declarationContext) {
	localctx = NewStruct_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ObjectiveCParserRULE_struct_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Specifier_qualifier_list()
	}
	{
		p.SetState(615)
		p.Struct_declarator_list()
	}
	{
		p.SetState(616)
		p.Match(ObjectiveCParserT__22)
	}



	return localctx
}


// ISpecifier_qualifier_listContext is an interface to support dynamic dispatch.
type ISpecifier_qualifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecifier_qualifier_listContext differentiates from other interfaces.
	IsSpecifier_qualifier_listContext()
}

type Specifier_qualifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifier_qualifier_listContext() *Specifier_qualifier_listContext {
	var p = new(Specifier_qualifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_specifier_qualifier_list
	return p
}

func (*Specifier_qualifier_listContext) IsSpecifier_qualifier_listContext() {}

func NewSpecifier_qualifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specifier_qualifier_listContext {
	var p = new(Specifier_qualifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_specifier_qualifier_list

	return p
}

func (s *Specifier_qualifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Specifier_qualifier_listContext) AllType_specifier() []IType_specifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specifierContext)(nil)).Elem())
	var tst = make([]IType_specifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specifierContext)
		}
	}

	return tst
}

func (s *Specifier_qualifier_listContext) Type_specifier(i int) IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Specifier_qualifier_listContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *Specifier_qualifier_listContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *Specifier_qualifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specifier_qualifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Specifier_qualifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSpecifier_qualifier_list(s)
	}
}

func (s *Specifier_qualifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSpecifier_qualifier_list(s)
	}
}




func (p *ObjectiveCParser) Specifier_qualifier_list() (localctx ISpecifier_qualifier_listContext) {
	localctx = NewSpecifier_qualifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ObjectiveCParserRULE_specifier_qualifier_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(620)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case ObjectiveCParserT__33, ObjectiveCParserT__34, ObjectiveCParserT__35, ObjectiveCParserT__36, ObjectiveCParserT__37, ObjectiveCParserT__38, ObjectiveCParserT__39, ObjectiveCParserT__40, ObjectiveCParserT__41, ObjectiveCParserT__42, ObjectiveCParserT__68, ObjectiveCParserT__69, ObjectiveCParserT__70, ObjectiveCParserIDENTIFIER:
					{
						p.SetState(618)
						p.Type_specifier()
					}


				case ObjectiveCParserT__43, ObjectiveCParserT__44, ObjectiveCParserT__45, ObjectiveCParserT__46, ObjectiveCParserT__47, ObjectiveCParserT__48, ObjectiveCParserT__49, ObjectiveCParserT__50:
					{
						p.SetState(619)
						p.Type_qualifier()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}



	return localctx
}


// IStruct_declarator_listContext is an interface to support dynamic dispatch.
type IStruct_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declarator_listContext differentiates from other interfaces.
	IsStruct_declarator_listContext()
}

type Struct_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declarator_listContext() *Struct_declarator_listContext {
	var p = new(Struct_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_struct_declarator_list
	return p
}

func (*Struct_declarator_listContext) IsStruct_declarator_listContext() {}

func NewStruct_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declarator_listContext {
	var p = new(Struct_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_struct_declarator_list

	return p
}

func (s *Struct_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declarator_listContext) AllStruct_declarator() []IStruct_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_declaratorContext)(nil)).Elem())
	var tst = make([]IStruct_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_declaratorContext)
		}
	}

	return tst
}

func (s *Struct_declarator_listContext) Struct_declarator(i int) IStruct_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_declaratorContext)
}

func (s *Struct_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStruct_declarator_list(s)
	}
}

func (s *Struct_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStruct_declarator_list(s)
	}
}




func (p *ObjectiveCParser) Struct_declarator_list() (localctx IStruct_declarator_listContext) {
	localctx = NewStruct_declarator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ObjectiveCParserRULE_struct_declarator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.Struct_declarator()
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(625)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(626)
			p.Struct_declarator()
		}


		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IStruct_declaratorContext is an interface to support dynamic dispatch.
type IStruct_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_declaratorContext differentiates from other interfaces.
	IsStruct_declaratorContext()
}

type Struct_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_declaratorContext() *Struct_declaratorContext {
	var p = new(Struct_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_struct_declarator
	return p
}

func (*Struct_declaratorContext) IsStruct_declaratorContext() {}

func NewStruct_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_declaratorContext {
	var p = new(Struct_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_struct_declarator

	return p
}

func (s *Struct_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Struct_declaratorContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Struct_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Struct_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStruct_declarator(s)
	}
}

func (s *Struct_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStruct_declarator(s)
	}
}




func (p *ObjectiveCParser) Struct_declarator() (localctx IStruct_declaratorContext) {
	localctx = NewStruct_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ObjectiveCParserRULE_struct_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			p.Declarator()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == ObjectiveCParserT__18 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(633)
				p.Declarator()
			}

		}
		{
			p.SetState(636)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(637)
			p.Constant()
		}

	}


	return localctx
}


// IEnum_specifierContext is an interface to support dynamic dispatch.
type IEnum_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_specifierContext differentiates from other interfaces.
	IsEnum_specifierContext()
}

type Enum_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_specifierContext() *Enum_specifierContext {
	var p = new(Enum_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enum_specifier
	return p
}

func (*Enum_specifierContext) IsEnum_specifierContext() {}

func NewEnum_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_specifierContext {
	var p = new(Enum_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enum_specifier

	return p
}

func (s *Enum_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_specifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enum_specifierContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enum_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Enum_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterEnum_specifier(s)
	}
}

func (s *Enum_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitEnum_specifier(s)
	}
}




func (p *ObjectiveCParser) Enum_specifier() (localctx IEnum_specifierContext) {
	localctx = NewEnum_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ObjectiveCParserRULE_enum_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(ObjectiveCParserT__70)
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIDENTIFIER:
		{
			p.SetState(641)
			p.Identifier()
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(642)
				p.Match(ObjectiveCParserT__25)
			}
			{
				p.SetState(643)
				p.Enumerator_list()
			}
			{
				p.SetState(644)
				p.Match(ObjectiveCParserT__26)
			}


		}


	case ObjectiveCParserT__25:
		{
			p.SetState(648)
			p.Match(ObjectiveCParserT__25)
		}
		{
			p.SetState(649)
			p.Enumerator_list()
		}
		{
			p.SetState(650)
			p.Match(ObjectiveCParserT__26)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IEnumerator_listContext is an interface to support dynamic dispatch.
type IEnumerator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_listContext differentiates from other interfaces.
	IsEnumerator_listContext()
}

type Enumerator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_listContext() *Enumerator_listContext {
	var p = new(Enumerator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumerator_list
	return p
}

func (*Enumerator_listContext) IsEnumerator_listContext() {}

func NewEnumerator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_listContext {
	var p = new(Enumerator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumerator_list

	return p
}

func (s *Enumerator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_listContext) AllEnumerator() []IEnumeratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem())
	var tst = make([]IEnumeratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeratorContext)
		}
	}

	return tst
}

func (s *Enumerator_listContext) Enumerator(i int) IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enumerator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Enumerator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterEnumerator_list(s)
	}
}

func (s *Enumerator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitEnumerator_list(s)
	}
}




func (p *ObjectiveCParser) Enumerator_list() (localctx IEnumerator_listContext) {
	localctx = NewEnumerator_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ObjectiveCParserRULE_enumerator_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Enumerator()
	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(655)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(656)
			p.Enumerator()
		}


		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumeratorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitEnumerator(s)
	}
}




func (p *ObjectiveCParser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ObjectiveCParserRULE_enumerator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Identifier()
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__67 {
		{
			p.SetState(663)
			p.Match(ObjectiveCParserT__67)
		}
		{
			p.SetState(664)
			p.Constant_expression()
		}

	}



	return localctx
}


// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DeclaratorContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *DeclaratorContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *DeclaratorContext) Direct_declarator() IDirect_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirect_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirect_declaratorContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitDeclarator(s)
	}
}




func (p *ObjectiveCParser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ObjectiveCParserRULE_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(676)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__71:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.Match(ObjectiveCParserT__71)
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ((((_la - 44)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 44))) & ((1 << (ObjectiveCParserT__43 - 44)) | (1 << (ObjectiveCParserT__44 - 44)) | (1 << (ObjectiveCParserT__45 - 44)) | (1 << (ObjectiveCParserT__46 - 44)) | (1 << (ObjectiveCParserT__47 - 44)) | (1 << (ObjectiveCParserT__48 - 44)) | (1 << (ObjectiveCParserT__49 - 44)) | (1 << (ObjectiveCParserT__50 - 44)))) != 0) {
			{
				p.SetState(668)
				p.Type_qualifier()
			}


			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(674)
			p.Declarator()
		}


	case ObjectiveCParserT__18, ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(675)
			p.Direct_declarator()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IDirect_declaratorContext is an interface to support dynamic dispatch.
type IDirect_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirect_declaratorContext differentiates from other interfaces.
	IsDirect_declaratorContext()
}

type Direct_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirect_declaratorContext() *Direct_declaratorContext {
	var p = new(Direct_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_direct_declarator
	return p
}

func (*Direct_declaratorContext) IsDirect_declaratorContext() {}

func NewDirect_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Direct_declaratorContext {
	var p = new(Direct_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_direct_declarator

	return p
}

func (s *Direct_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Direct_declaratorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Direct_declaratorContext) AllDeclarator_suffix() []IDeclarator_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarator_suffixContext)(nil)).Elem())
	var tst = make([]IDeclarator_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarator_suffixContext)
		}
	}

	return tst
}

func (s *Direct_declaratorContext) Declarator_suffix(i int) IDeclarator_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarator_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarator_suffixContext)
}

func (s *Direct_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Direct_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Direct_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Direct_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterDirect_declarator(s)
	}
}

func (s *Direct_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitDirect_declarator(s)
	}
}




func (p *ObjectiveCParser) Direct_declarator() (localctx IDirect_declaratorContext) {
	localctx = NewDirect_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ObjectiveCParserRULE_direct_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(678)
			p.Identifier()
		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(679)
					p.Declarator_suffix()
				}


			}
			p.SetState(684)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
		}


	case ObjectiveCParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(685)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(686)
			p.Declarator()
		}
		{
			p.SetState(687)
			p.Match(ObjectiveCParserT__19)
		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(688)
					p.Declarator_suffix()
				}


			}
			p.SetState(693)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IDeclarator_suffixContext is an interface to support dynamic dispatch.
type IDeclarator_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarator_suffixContext differentiates from other interfaces.
	IsDeclarator_suffixContext()
}

type Declarator_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarator_suffixContext() *Declarator_suffixContext {
	var p = new(Declarator_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_declarator_suffix
	return p
}

func (*Declarator_suffixContext) IsDeclarator_suffixContext() {}

func NewDeclarator_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declarator_suffixContext {
	var p = new(Declarator_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_declarator_suffix

	return p
}

func (s *Declarator_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Declarator_suffixContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Declarator_suffixContext) Parameter_list() IParameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_listContext)
}

func (s *Declarator_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declarator_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declarator_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterDeclarator_suffix(s)
	}
}

func (s *Declarator_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitDeclarator_suffix(s)
	}
}




func (p *ObjectiveCParser) Declarator_suffix() (localctx IDeclarator_suffixContext) {
	localctx = NewDeclarator_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ObjectiveCParserRULE_declarator_suffix)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__52:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(696)
			p.Match(ObjectiveCParserT__52)
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(697)
				p.Constant_expression()
			}

		}
		{
			p.SetState(700)
			p.Match(ObjectiveCParserT__53)
		}


	case ObjectiveCParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(701)
			p.Match(ObjectiveCParserT__18)
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 34)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 34))) & ((1 << (ObjectiveCParserT__33 - 34)) | (1 << (ObjectiveCParserT__34 - 34)) | (1 << (ObjectiveCParserT__35 - 34)) | (1 << (ObjectiveCParserT__36 - 34)) | (1 << (ObjectiveCParserT__37 - 34)) | (1 << (ObjectiveCParserT__38 - 34)) | (1 << (ObjectiveCParserT__39 - 34)) | (1 << (ObjectiveCParserT__40 - 34)) | (1 << (ObjectiveCParserT__41 - 34)) | (1 << (ObjectiveCParserT__42 - 34)) | (1 << (ObjectiveCParserT__43 - 34)) | (1 << (ObjectiveCParserT__44 - 34)) | (1 << (ObjectiveCParserT__45 - 34)) | (1 << (ObjectiveCParserT__46 - 34)) | (1 << (ObjectiveCParserT__47 - 34)) | (1 << (ObjectiveCParserT__48 - 34)) | (1 << (ObjectiveCParserT__49 - 34)) | (1 << (ObjectiveCParserT__50 - 34)) | (1 << (ObjectiveCParserT__62 - 34)) | (1 << (ObjectiveCParserT__63 - 34)) | (1 << (ObjectiveCParserT__64 - 34)))) != 0) || ((((_la - 66)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 66))) & ((1 << (ObjectiveCParserT__65 - 66)) | (1 << (ObjectiveCParserT__66 - 66)) | (1 << (ObjectiveCParserT__68 - 66)) | (1 << (ObjectiveCParserT__69 - 66)) | (1 << (ObjectiveCParserT__70 - 66)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(702)
				p.Parameter_list()
			}

		}
		{
			p.SetState(705)
			p.Match(ObjectiveCParserT__19)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IParameter_listContext is an interface to support dynamic dispatch.
type IParameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_listContext differentiates from other interfaces.
	IsParameter_listContext()
}

type Parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_listContext() *Parameter_listContext {
	var p = new(Parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameter_list
	return p
}

func (*Parameter_listContext) IsParameter_listContext() {}

func NewParameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_listContext {
	var p = new(Parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameter_list

	return p
}

func (s *Parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_listContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterParameter_list(s)
	}
}

func (s *Parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitParameter_list(s)
	}
}




func (p *ObjectiveCParser) Parameter_list() (localctx IParameter_listContext) {
	localctx = NewParameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ObjectiveCParserRULE_parameter_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Parameter_declaration_list()
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__24 {
		{
			p.SetState(709)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(710)
			p.Match(ObjectiveCParserT__72)
		}

	}



	return localctx
}


// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Declaration_specifiers() IDeclaration_specifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_specifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_specifiersContext)
}

func (s *Parameter_declarationContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Parameter_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}




func (p *ObjectiveCParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ObjectiveCParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Declaration_specifiers()
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.SetState(715)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(714)
				p.Declarator()
			}


		}


	case 2:
		{
			p.SetState(717)
			p.Abstract_declarator()
		}

	}



	return localctx
}


// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *InitializerContext) AllInitializer() []IInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializerContext)(nil)).Elem())
	var tst = make([]IInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializerContext)
		}
	}

	return tst
}

func (s *InitializerContext) Initializer(i int) IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInitializer(s)
	}
}




func (p *ObjectiveCParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ObjectiveCParserRULE_initializer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__18, ObjectiveCParserT__21, ObjectiveCParserT__32, ObjectiveCParserT__51, ObjectiveCParserT__52, ObjectiveCParserT__55, ObjectiveCParserT__56, ObjectiveCParserT__71, ObjectiveCParserT__100, ObjectiveCParserT__108, ObjectiveCParserT__109, ObjectiveCParserT__110, ObjectiveCParserT__111, ObjectiveCParserT__112, ObjectiveCParserIDENTIFIER, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserSTRING_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.Assignment_expression()
		}


	case ObjectiveCParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Match(ObjectiveCParserT__25)
		}
		{
			p.SetState(722)
			p.Initializer()
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == ObjectiveCParserT__24 {
			{
				p.SetState(723)
				p.Match(ObjectiveCParserT__24)
			}
			{
				p.SetState(724)
				p.Initializer()
			}


			p.SetState(729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(730)
			p.Match(ObjectiveCParserT__26)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_type_name
	return p
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Specifier_qualifier_list() ISpecifier_qualifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecifier_qualifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecifier_qualifier_listContext)
}

func (s *Type_nameContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitType_name(s)
	}
}




func (p *ObjectiveCParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ObjectiveCParserRULE_type_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Specifier_qualifier_list()
	}
	{
		p.SetState(735)
		p.Abstract_declarator()
	}



	return localctx
}


// IAbstract_declaratorContext is an interface to support dynamic dispatch.
type IAbstract_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_declaratorContext differentiates from other interfaces.
	IsAbstract_declaratorContext()
}

type Abstract_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_declaratorContext() *Abstract_declaratorContext {
	var p = new(Abstract_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_abstract_declarator
	return p
}

func (*Abstract_declaratorContext) IsAbstract_declaratorContext() {}

func NewAbstract_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_declaratorContext {
	var p = new(Abstract_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_abstract_declarator

	return p
}

func (s *Abstract_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_declaratorContext) Abstract_declarator() IAbstract_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declaratorContext)
}

func (s *Abstract_declaratorContext) AllType_qualifier() []IType_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem())
	var tst = make([]IType_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_qualifierContext)
		}
	}

	return tst
}

func (s *Abstract_declaratorContext) Type_qualifier(i int) IType_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_qualifierContext)
}

func (s *Abstract_declaratorContext) AllAbstract_declarator_suffix() []IAbstract_declarator_suffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAbstract_declarator_suffixContext)(nil)).Elem())
	var tst = make([]IAbstract_declarator_suffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAbstract_declarator_suffixContext)
		}
	}

	return tst
}

func (s *Abstract_declaratorContext) Abstract_declarator_suffix(i int) IAbstract_declarator_suffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_declarator_suffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAbstract_declarator_suffixContext)
}

func (s *Abstract_declaratorContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Abstract_declaratorContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Abstract_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Abstract_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAbstract_declarator(s)
	}
}

func (s *Abstract_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAbstract_declarator(s)
	}
}




func (p *ObjectiveCParser) Abstract_declarator() (localctx IAbstract_declaratorContext) {
	localctx = NewAbstract_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ObjectiveCParserRULE_abstract_declarator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(737)
			p.Match(ObjectiveCParserT__71)
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ((((_la - 44)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 44))) & ((1 << (ObjectiveCParserT__43 - 44)) | (1 << (ObjectiveCParserT__44 - 44)) | (1 << (ObjectiveCParserT__45 - 44)) | (1 << (ObjectiveCParserT__46 - 44)) | (1 << (ObjectiveCParserT__47 - 44)) | (1 << (ObjectiveCParserT__48 - 44)) | (1 << (ObjectiveCParserT__49 - 44)) | (1 << (ObjectiveCParserT__50 - 44)))) != 0) {
			{
				p.SetState(738)
				p.Type_qualifier()
			}


			p.SetState(743)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(744)
			p.Abstract_declarator()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(746)
			p.Abstract_declarator()
		}
		{
			p.SetState(747)
			p.Match(ObjectiveCParserT__19)
		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(748)
						p.Abstract_declarator_suffix()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == ObjectiveCParserT__52 {
			{
				p.SetState(753)
				p.Match(ObjectiveCParserT__52)
			}
			p.SetState(755)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
				{
					p.SetState(754)
					p.Constant_expression()
				}

			}
			{
				p.SetState(757)
				p.Match(ObjectiveCParserT__53)
			}


			p.SetState(760)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)

	}


	return localctx
}


// IAbstract_declarator_suffixContext is an interface to support dynamic dispatch.
type IAbstract_declarator_suffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_declarator_suffixContext differentiates from other interfaces.
	IsAbstract_declarator_suffixContext()
}

type Abstract_declarator_suffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_declarator_suffixContext() *Abstract_declarator_suffixContext {
	var p = new(Abstract_declarator_suffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_abstract_declarator_suffix
	return p
}

func (*Abstract_declarator_suffixContext) IsAbstract_declarator_suffixContext() {}

func NewAbstract_declarator_suffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_declarator_suffixContext {
	var p = new(Abstract_declarator_suffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_abstract_declarator_suffix

	return p
}

func (s *Abstract_declarator_suffixContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_declarator_suffixContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Abstract_declarator_suffixContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Abstract_declarator_suffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_declarator_suffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Abstract_declarator_suffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAbstract_declarator_suffix(s)
	}
}

func (s *Abstract_declarator_suffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAbstract_declarator_suffix(s)
	}
}




func (p *ObjectiveCParser) Abstract_declarator_suffix() (localctx IAbstract_declarator_suffixContext) {
	localctx = NewAbstract_declarator_suffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ObjectiveCParserRULE_abstract_declarator_suffix)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(775)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__52:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(765)
			p.Match(ObjectiveCParserT__52)
		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(766)
				p.Constant_expression()
			}

		}
		{
			p.SetState(769)
			p.Match(ObjectiveCParserT__53)
		}


	case ObjectiveCParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(770)
			p.Match(ObjectiveCParserT__18)
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 34)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 34))) & ((1 << (ObjectiveCParserT__33 - 34)) | (1 << (ObjectiveCParserT__34 - 34)) | (1 << (ObjectiveCParserT__35 - 34)) | (1 << (ObjectiveCParserT__36 - 34)) | (1 << (ObjectiveCParserT__37 - 34)) | (1 << (ObjectiveCParserT__38 - 34)) | (1 << (ObjectiveCParserT__39 - 34)) | (1 << (ObjectiveCParserT__40 - 34)) | (1 << (ObjectiveCParserT__41 - 34)) | (1 << (ObjectiveCParserT__42 - 34)) | (1 << (ObjectiveCParserT__43 - 34)) | (1 << (ObjectiveCParserT__44 - 34)) | (1 << (ObjectiveCParserT__45 - 34)) | (1 << (ObjectiveCParserT__46 - 34)) | (1 << (ObjectiveCParserT__47 - 34)) | (1 << (ObjectiveCParserT__48 - 34)) | (1 << (ObjectiveCParserT__49 - 34)) | (1 << (ObjectiveCParserT__50 - 34)) | (1 << (ObjectiveCParserT__62 - 34)) | (1 << (ObjectiveCParserT__63 - 34)) | (1 << (ObjectiveCParserT__64 - 34)))) != 0) || ((((_la - 66)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 66))) & ((1 << (ObjectiveCParserT__65 - 66)) | (1 << (ObjectiveCParserT__66 - 66)) | (1 << (ObjectiveCParserT__68 - 66)) | (1 << (ObjectiveCParserT__69 - 66)) | (1 << (ObjectiveCParserT__70 - 66)))) != 0) || _la == ObjectiveCParserIDENTIFIER {
			{
				p.SetState(771)
				p.Parameter_declaration_list()
			}

		}
		{
			p.SetState(774)
			p.Match(ObjectiveCParserT__19)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IParameter_declaration_listContext is an interface to support dynamic dispatch.
type IParameter_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_listContext differentiates from other interfaces.
	IsParameter_declaration_listContext()
}

type Parameter_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_listContext() *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_parameter_declaration_list
	return p
}

func (*Parameter_declaration_listContext) IsParameter_declaration_listContext() {}

func NewParameter_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_parameter_declaration_list

	return p
}

func (s *Parameter_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_listContext) AllParameter_declaration() []IParameter_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem())
	var tst = make([]IParameter_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_declarationContext)
		}
	}

	return tst
}

func (s *Parameter_declaration_listContext) Parameter_declaration(i int) IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Parameter_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterParameter_declaration_list(s)
	}
}

func (s *Parameter_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitParameter_declaration_list(s)
	}
}




func (p *ObjectiveCParser) Parameter_declaration_list() (localctx IParameter_declaration_listContext) {
	localctx = NewParameter_declaration_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ObjectiveCParserRULE_parameter_declaration_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Parameter_declaration()
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(778)
				p.Match(ObjectiveCParserT__24)
			}
			{
				p.SetState(779)
				p.Parameter_declaration()
			}


		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}



	return localctx
}


// IStatement_listContext is an interface to support dynamic dispatch.
type IStatement_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_listContext differentiates from other interfaces.
	IsStatement_listContext()
}

type Statement_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_listContext() *Statement_listContext {
	var p = new(Statement_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_statement_list
	return p
}

func (*Statement_listContext) IsStatement_listContext() {}

func NewStatement_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_listContext {
	var p = new(Statement_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_statement_list

	return p
}

func (s *Statement_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_listContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Statement_listContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Statement_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStatement_list(s)
	}
}

func (s *Statement_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStatement_list(s)
	}
}




func (p *ObjectiveCParser) Statement_list() (localctx IStatement_listContext) {
	localctx = NewStatement_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ObjectiveCParserRULE_statement_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__18) | (1 << ObjectiveCParserT__21) | (1 << ObjectiveCParserT__22) | (1 << ObjectiveCParserT__25))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (ObjectiveCParserT__32 - 33)) | (1 << (ObjectiveCParserT__51 - 33)) | (1 << (ObjectiveCParserT__52 - 33)) | (1 << (ObjectiveCParserT__55 - 33)) | (1 << (ObjectiveCParserT__56 - 33)))) != 0) || ((((_la - 72)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 72))) & ((1 << (ObjectiveCParserT__71 - 72)) | (1 << (ObjectiveCParserT__73 - 72)) | (1 << (ObjectiveCParserT__74 - 72)) | (1 << (ObjectiveCParserT__75 - 72)) | (1 << (ObjectiveCParserT__77 - 72)) | (1 << (ObjectiveCParserT__78 - 72)) | (1 << (ObjectiveCParserT__79 - 72)) | (1 << (ObjectiveCParserT__80 - 72)) | (1 << (ObjectiveCParserT__81 - 72)) | (1 << (ObjectiveCParserT__82 - 72)) | (1 << (ObjectiveCParserT__83 - 72)) | (1 << (ObjectiveCParserT__84 - 72)) | (1 << (ObjectiveCParserT__100 - 72)))) != 0) || ((((_la - 109)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 109))) & ((1 << (ObjectiveCParserT__108 - 109)) | (1 << (ObjectiveCParserT__109 - 109)) | (1 << (ObjectiveCParserT__110 - 109)) | (1 << (ObjectiveCParserT__111 - 109)) | (1 << (ObjectiveCParserT__112 - 109)) | (1 << (ObjectiveCParserIDENTIFIER - 109)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 109)) | (1 << (ObjectiveCParserSTRING_LITERAL - 109)) | (1 << (ObjectiveCParserHEX_LITERAL - 109)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 109)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 109)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 109)))) != 0) {
		{
			p.SetState(785)
			p.Statement()
		}


		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Labeled_statement() ILabeled_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeled_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeled_statementContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *StatementContext) Selection_statement() ISelection_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelection_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelection_statementContext)
}

func (s *StatementContext) Iteration_statement() IIteration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_statementContext)
}

func (s *StatementContext) Jump_statement() IJump_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_statementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitStatement(s)
	}
}




func (p *ObjectiveCParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ObjectiveCParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(790)
			p.Labeled_statement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Expression()
		}
		{
			p.SetState(792)
			p.Match(ObjectiveCParserT__22)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(794)
			p.Compound_statement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(795)
			p.Selection_statement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(796)
			p.Iteration_statement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(797)
			p.Jump_statement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(798)
			p.Match(ObjectiveCParserT__22)
		}

	}


	return localctx
}


// ILabeled_statementContext is an interface to support dynamic dispatch.
type ILabeled_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeled_statementContext differentiates from other interfaces.
	IsLabeled_statementContext()
}

type Labeled_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeled_statementContext() *Labeled_statementContext {
	var p = new(Labeled_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_labeled_statement
	return p
}

func (*Labeled_statementContext) IsLabeled_statementContext() {}

func NewLabeled_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Labeled_statementContext {
	var p = new(Labeled_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_labeled_statement

	return p
}

func (s *Labeled_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Labeled_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Labeled_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Labeled_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Labeled_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Labeled_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Labeled_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterLabeled_statement(s)
	}
}

func (s *Labeled_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitLabeled_statement(s)
	}
}




func (p *ObjectiveCParser) Labeled_statement() (localctx ILabeled_statementContext) {
	localctx = NewLabeled_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ObjectiveCParserRULE_labeled_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(813)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(801)
			p.Identifier()
		}
		{
			p.SetState(802)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(803)
			p.Statement()
		}


	case ObjectiveCParserT__73:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(805)
			p.Match(ObjectiveCParserT__73)
		}
		{
			p.SetState(806)
			p.Constant_expression()
		}
		{
			p.SetState(807)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(808)
			p.Statement()
		}


	case ObjectiveCParserT__74:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(810)
			p.Match(ObjectiveCParserT__74)
		}
		{
			p.SetState(811)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(812)
			p.Statement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ICompound_statementContext is an interface to support dynamic dispatch.
type ICompound_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_statementContext differentiates from other interfaces.
	IsCompound_statementContext()
}

type Compound_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_statementContext() *Compound_statementContext {
	var p = new(Compound_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_compound_statement
	return p
}

func (*Compound_statementContext) IsCompound_statementContext() {}

func NewCompound_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_statementContext {
	var p = new(Compound_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_compound_statement

	return p
}

func (s *Compound_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_statementContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *Compound_statementContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Compound_statementContext) Statement_list() IStatement_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_listContext)
}

func (s *Compound_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCompound_statement(s)
	}
}

func (s *Compound_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCompound_statement(s)
	}
}




func (p *ObjectiveCParser) Compound_statement() (localctx ICompound_statementContext) {
	localctx = NewCompound_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ObjectiveCParserRULE_compound_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Match(ObjectiveCParserT__25)
	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(816)
				p.Declaration()
			}


		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << ObjectiveCParserT__18) | (1 << ObjectiveCParserT__21) | (1 << ObjectiveCParserT__22) | (1 << ObjectiveCParserT__25))) != 0) || ((((_la - 33)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 33))) & ((1 << (ObjectiveCParserT__32 - 33)) | (1 << (ObjectiveCParserT__51 - 33)) | (1 << (ObjectiveCParserT__52 - 33)) | (1 << (ObjectiveCParserT__55 - 33)) | (1 << (ObjectiveCParserT__56 - 33)))) != 0) || ((((_la - 72)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 72))) & ((1 << (ObjectiveCParserT__71 - 72)) | (1 << (ObjectiveCParserT__73 - 72)) | (1 << (ObjectiveCParserT__74 - 72)) | (1 << (ObjectiveCParserT__75 - 72)) | (1 << (ObjectiveCParserT__77 - 72)) | (1 << (ObjectiveCParserT__78 - 72)) | (1 << (ObjectiveCParserT__79 - 72)) | (1 << (ObjectiveCParserT__80 - 72)) | (1 << (ObjectiveCParserT__81 - 72)) | (1 << (ObjectiveCParserT__82 - 72)) | (1 << (ObjectiveCParserT__83 - 72)) | (1 << (ObjectiveCParserT__84 - 72)) | (1 << (ObjectiveCParserT__100 - 72)))) != 0) || ((((_la - 109)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 109))) & ((1 << (ObjectiveCParserT__108 - 109)) | (1 << (ObjectiveCParserT__109 - 109)) | (1 << (ObjectiveCParserT__110 - 109)) | (1 << (ObjectiveCParserT__111 - 109)) | (1 << (ObjectiveCParserT__112 - 109)) | (1 << (ObjectiveCParserIDENTIFIER - 109)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 109)) | (1 << (ObjectiveCParserSTRING_LITERAL - 109)) | (1 << (ObjectiveCParserHEX_LITERAL - 109)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 109)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 109)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 109)))) != 0) {
		{
			p.SetState(822)
			p.Statement_list()
		}

	}
	{
		p.SetState(825)
		p.Match(ObjectiveCParserT__26)
	}



	return localctx
}


// ISelection_statementContext is an interface to support dynamic dispatch.
type ISelection_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelection_statementContext differentiates from other interfaces.
	IsSelection_statementContext()
}

type Selection_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelection_statementContext() *Selection_statementContext {
	var p = new(Selection_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_selection_statement
	return p
}

func (*Selection_statementContext) IsSelection_statementContext() {}

func NewSelection_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selection_statementContext {
	var p = new(Selection_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_selection_statement

	return p
}

func (s *Selection_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Selection_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Selection_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Selection_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Selection_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selection_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Selection_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterSelection_statement(s)
	}
}

func (s *Selection_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitSelection_statement(s)
	}
}




func (p *ObjectiveCParser) Selection_statement() (localctx ISelection_statementContext) {
	localctx = NewSelection_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ObjectiveCParserRULE_selection_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(842)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__75:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(827)
			p.Match(ObjectiveCParserT__75)
		}
		{
			p.SetState(828)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(829)
			p.Expression()
		}
		{
			p.SetState(830)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(831)
			p.Statement()
		}
		p.SetState(834)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(832)
				p.Match(ObjectiveCParserT__76)
			}
			{
				p.SetState(833)
				p.Statement()
			}


		}


	case ObjectiveCParserT__77:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.Match(ObjectiveCParserT__77)
		}
		{
			p.SetState(837)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(838)
			p.Expression()
		}
		{
			p.SetState(839)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(840)
			p.Statement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IIteration_statementContext is an interface to support dynamic dispatch.
type IIteration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_statementContext differentiates from other interfaces.
	IsIteration_statementContext()
}

type Iteration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_statementContext() *Iteration_statementContext {
	var p = new(Iteration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_iteration_statement
	return p
}

func (*Iteration_statementContext) IsIteration_statementContext() {}

func NewIteration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_statementContext {
	var p = new(Iteration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_iteration_statement

	return p
}

func (s *Iteration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Iteration_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Iteration_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Iteration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Iteration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterIteration_statement(s)
	}
}

func (s *Iteration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitIteration_statement(s)
	}
}




func (p *ObjectiveCParser) Iteration_statement() (localctx IIteration_statementContext) {
	localctx = NewIteration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ObjectiveCParserRULE_iteration_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(873)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__78:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(844)
			p.Match(ObjectiveCParserT__78)
		}
		{
			p.SetState(845)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(846)
			p.Expression()
		}
		{
			p.SetState(847)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(848)
			p.Statement()
		}


	case ObjectiveCParserT__79:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Match(ObjectiveCParserT__79)
		}
		{
			p.SetState(851)
			p.Statement()
		}
		{
			p.SetState(852)
			p.Match(ObjectiveCParserT__78)
		}
		{
			p.SetState(853)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(854)
			p.Expression()
		}
		{
			p.SetState(855)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(856)
			p.Match(ObjectiveCParserT__22)
		}


	case ObjectiveCParserT__80:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(858)
			p.Match(ObjectiveCParserT__80)
		}
		{
			p.SetState(859)
			p.Match(ObjectiveCParserT__18)
		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(860)
				p.Expression()
			}

		}
		{
			p.SetState(863)
			p.Match(ObjectiveCParserT__22)
		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(864)
				p.Expression()
			}

		}
		{
			p.SetState(867)
			p.Match(ObjectiveCParserT__22)
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(868)
				p.Expression()
			}

		}
		{
			p.SetState(871)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(872)
			p.Statement()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IJump_statementContext is an interface to support dynamic dispatch.
type IJump_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_statementContext differentiates from other interfaces.
	IsJump_statementContext()
}

type Jump_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_statementContext() *Jump_statementContext {
	var p = new(Jump_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_jump_statement
	return p
}

func (*Jump_statementContext) IsJump_statementContext() {}

func NewJump_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_statementContext {
	var p = new(Jump_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_jump_statement

	return p
}

func (s *Jump_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Jump_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Jump_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Jump_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterJump_statement(s)
	}
}

func (s *Jump_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitJump_statement(s)
	}
}




func (p *ObjectiveCParser) Jump_statement() (localctx IJump_statementContext) {
	localctx = NewJump_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ObjectiveCParserRULE_jump_statement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(888)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__81:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(875)
			p.Match(ObjectiveCParserT__81)
		}
		{
			p.SetState(876)
			p.Identifier()
		}
		{
			p.SetState(877)
			p.Match(ObjectiveCParserT__22)
		}


	case ObjectiveCParserT__82:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(879)
			p.Match(ObjectiveCParserT__82)
		}
		{
			p.SetState(880)
			p.Match(ObjectiveCParserT__22)
		}


	case ObjectiveCParserT__83:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(881)
			p.Match(ObjectiveCParserT__83)
		}
		{
			p.SetState(882)
			p.Match(ObjectiveCParserT__22)
		}


	case ObjectiveCParserT__84:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(883)
			p.Match(ObjectiveCParserT__84)
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
			{
				p.SetState(884)
				p.Expression()
			}

		}
		{
			p.SetState(887)
			p.Match(ObjectiveCParserT__22)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllAssignment_expression() []IAssignment_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem())
	var tst = make([]IAssignment_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignment_expressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Assignment_expression(i int) IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitExpression(s)
	}
}




func (p *ObjectiveCParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ObjectiveCParserRULE_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Assignment_expression()
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(891)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(892)
			p.Assignment_expression()
		}


		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssignment_expressionContext is an interface to support dynamic dispatch.
type IAssignment_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_expressionContext differentiates from other interfaces.
	IsAssignment_expressionContext()
}

type Assignment_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_expressionContext() *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_assignment_expression
	return p
}

func (*Assignment_expressionContext) IsAssignment_expressionContext() {}

func NewAssignment_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_assignment_expression

	return p
}

func (s *Assignment_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Assignment_expressionContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Assignment_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Assignment_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAssignment_expression(s)
	}
}

func (s *Assignment_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAssignment_expression(s)
	}
}




func (p *ObjectiveCParser) Assignment_expression() (localctx IAssignment_expressionContext) {
	localctx = NewAssignment_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ObjectiveCParserRULE_assignment_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Conditional_expression()
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (ObjectiveCParserT__67 - 68)) | (1 << (ObjectiveCParserT__85 - 68)) | (1 << (ObjectiveCParserT__86 - 68)) | (1 << (ObjectiveCParserT__87 - 68)) | (1 << (ObjectiveCParserT__88 - 68)) | (1 << (ObjectiveCParserT__89 - 68)) | (1 << (ObjectiveCParserT__90 - 68)) | (1 << (ObjectiveCParserT__91 - 68)) | (1 << (ObjectiveCParserT__92 - 68)) | (1 << (ObjectiveCParserT__93 - 68)) | (1 << (ObjectiveCParserT__94 - 68)))) != 0) {
		{
			p.SetState(899)
			p.Assignment_operator()
		}
		{
			p.SetState(900)
			p.Assignment_expression()
		}

	}



	return localctx
}


// IAssignment_operatorContext is an interface to support dynamic dispatch.
type IAssignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_operatorContext differentiates from other interfaces.
	IsAssignment_operatorContext()
}

type Assignment_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_operatorContext() *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_assignment_operator
	return p
}

func (*Assignment_operatorContext) IsAssignment_operatorContext() {}

func NewAssignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_assignment_operator

	return p
}

func (s *Assignment_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAssignment_operator(s)
	}
}




func (p *ObjectiveCParser) Assignment_operator() (localctx IAssignment_operatorContext) {
	localctx = NewAssignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ObjectiveCParserRULE_assignment_operator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (ObjectiveCParserT__67 - 68)) | (1 << (ObjectiveCParserT__85 - 68)) | (1 << (ObjectiveCParserT__86 - 68)) | (1 << (ObjectiveCParserT__87 - 68)) | (1 << (ObjectiveCParserT__88 - 68)) | (1 << (ObjectiveCParserT__89 - 68)) | (1 << (ObjectiveCParserT__90 - 68)) | (1 << (ObjectiveCParserT__91 - 68)) | (1 << (ObjectiveCParserT__92 - 68)) | (1 << (ObjectiveCParserT__93 - 68)) | (1 << (ObjectiveCParserT__94 - 68)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) AllLogical_or_expression() []ILogical_or_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem())
	var tst = make([]ILogical_or_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_or_expressionContext)
		}
	}

	return tst
}

func (s *Conditional_expressionContext) Logical_or_expression(i int) ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}




func (p *ObjectiveCParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ObjectiveCParserRULE_conditional_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.Logical_or_expression()
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == ObjectiveCParserT__95 {
		{
			p.SetState(907)
			p.Match(ObjectiveCParserT__95)
		}
		{
			p.SetState(908)
			p.Logical_or_expression()
		}
		{
			p.SetState(909)
			p.Match(ObjectiveCParserT__16)
		}
		{
			p.SetState(910)
			p.Logical_or_expression()
		}

	}



	return localctx
}


// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}




func (p *ObjectiveCParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ObjectiveCParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Conditional_expression()
	}



	return localctx
}


// ILogical_or_expressionContext is an interface to support dynamic dispatch.
type ILogical_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_or_expressionContext differentiates from other interfaces.
	IsLogical_or_expressionContext()
}

type Logical_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_or_expressionContext() *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_logical_or_expression
	return p
}

func (*Logical_or_expressionContext) IsLogical_or_expressionContext() {}

func NewLogical_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_logical_or_expression

	return p
}

func (s *Logical_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_or_expressionContext) AllLogical_and_expression() []ILogical_and_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem())
	var tst = make([]ILogical_and_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_and_expressionContext)
		}
	}

	return tst
}

func (s *Logical_or_expressionContext) Logical_and_expression(i int) ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Logical_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterLogical_or_expression(s)
	}
}

func (s *Logical_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitLogical_or_expression(s)
	}
}




func (p *ObjectiveCParser) Logical_or_expression() (localctx ILogical_or_expressionContext) {
	localctx = NewLogical_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ObjectiveCParserRULE_logical_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.Logical_and_expression()
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__96 {
		{
			p.SetState(917)
			p.Match(ObjectiveCParserT__96)
		}
		{
			p.SetState(918)
			p.Logical_and_expression()
		}


		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ILogical_and_expressionContext is an interface to support dynamic dispatch.
type ILogical_and_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_and_expressionContext differentiates from other interfaces.
	IsLogical_and_expressionContext()
}

type Logical_and_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_and_expressionContext() *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_logical_and_expression
	return p
}

func (*Logical_and_expressionContext) IsLogical_and_expressionContext() {}

func NewLogical_and_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_logical_and_expression

	return p
}

func (s *Logical_and_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_and_expressionContext) AllInclusive_or_expression() []IInclusive_or_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInclusive_or_expressionContext)(nil)).Elem())
	var tst = make([]IInclusive_or_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInclusive_or_expressionContext)
		}
	}

	return tst
}

func (s *Logical_and_expressionContext) Inclusive_or_expression(i int) IInclusive_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusive_or_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInclusive_or_expressionContext)
}

func (s *Logical_and_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_and_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Logical_and_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterLogical_and_expression(s)
	}
}

func (s *Logical_and_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitLogical_and_expression(s)
	}
}




func (p *ObjectiveCParser) Logical_and_expression() (localctx ILogical_and_expressionContext) {
	localctx = NewLogical_and_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ObjectiveCParserRULE_logical_and_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Inclusive_or_expression()
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__97 {
		{
			p.SetState(925)
			p.Match(ObjectiveCParserT__97)
		}
		{
			p.SetState(926)
			p.Inclusive_or_expression()
		}


		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IInclusive_or_expressionContext is an interface to support dynamic dispatch.
type IInclusive_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclusive_or_expressionContext differentiates from other interfaces.
	IsInclusive_or_expressionContext()
}

type Inclusive_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusive_or_expressionContext() *Inclusive_or_expressionContext {
	var p = new(Inclusive_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_inclusive_or_expression
	return p
}

func (*Inclusive_or_expressionContext) IsInclusive_or_expressionContext() {}

func NewInclusive_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inclusive_or_expressionContext {
	var p = new(Inclusive_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_inclusive_or_expression

	return p
}

func (s *Inclusive_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inclusive_or_expressionContext) AllExclusive_or_expression() []IExclusive_or_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExclusive_or_expressionContext)(nil)).Elem())
	var tst = make([]IExclusive_or_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExclusive_or_expressionContext)
		}
	}

	return tst
}

func (s *Inclusive_or_expressionContext) Exclusive_or_expression(i int) IExclusive_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusive_or_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExclusive_or_expressionContext)
}

func (s *Inclusive_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inclusive_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Inclusive_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterInclusive_or_expression(s)
	}
}

func (s *Inclusive_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitInclusive_or_expression(s)
	}
}




func (p *ObjectiveCParser) Inclusive_or_expression() (localctx IInclusive_or_expressionContext) {
	localctx = NewInclusive_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ObjectiveCParserRULE_inclusive_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(932)
		p.Exclusive_or_expression()
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__98 {
		{
			p.SetState(933)
			p.Match(ObjectiveCParserT__98)
		}
		{
			p.SetState(934)
			p.Exclusive_or_expression()
		}


		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IExclusive_or_expressionContext is an interface to support dynamic dispatch.
type IExclusive_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusive_or_expressionContext differentiates from other interfaces.
	IsExclusive_or_expressionContext()
}

type Exclusive_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusive_or_expressionContext() *Exclusive_or_expressionContext {
	var p = new(Exclusive_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_exclusive_or_expression
	return p
}

func (*Exclusive_or_expressionContext) IsExclusive_or_expressionContext() {}

func NewExclusive_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exclusive_or_expressionContext {
	var p = new(Exclusive_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_exclusive_or_expression

	return p
}

func (s *Exclusive_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Exclusive_or_expressionContext) AllAnd_expression() []IAnd_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem())
	var tst = make([]IAnd_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_expressionContext)
		}
	}

	return tst
}

func (s *Exclusive_or_expressionContext) And_expression(i int) IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *Exclusive_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exclusive_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exclusive_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterExclusive_or_expression(s)
	}
}

func (s *Exclusive_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitExclusive_or_expression(s)
	}
}




func (p *ObjectiveCParser) Exclusive_or_expression() (localctx IExclusive_or_expressionContext) {
	localctx = NewExclusive_or_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ObjectiveCParserRULE_exclusive_or_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.And_expression()
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__99 {
		{
			p.SetState(941)
			p.Match(ObjectiveCParserT__99)
		}
		{
			p.SetState(942)
			p.And_expression()
		}


		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_and_expression
	return p
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) AllEquality_expression() []IEquality_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem())
	var tst = make([]IEquality_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquality_expressionContext)
		}
	}

	return tst
}

func (s *And_expressionContext) Equality_expression(i int) IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}




func (p *ObjectiveCParser) And_expression() (localctx IAnd_expressionContext) {
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ObjectiveCParserRULE_and_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Equality_expression()
	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__100 {
		{
			p.SetState(949)
			p.Match(ObjectiveCParserT__100)
		}
		{
			p.SetState(950)
			p.Equality_expression()
		}


		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IEquality_expressionContext is an interface to support dynamic dispatch.
type IEquality_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquality_expressionContext differentiates from other interfaces.
	IsEquality_expressionContext()
}

type Equality_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquality_expressionContext() *Equality_expressionContext {
	var p = new(Equality_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_equality_expression
	return p
}

func (*Equality_expressionContext) IsEquality_expressionContext() {}

func NewEquality_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Equality_expressionContext {
	var p = new(Equality_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_equality_expression

	return p
}

func (s *Equality_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Equality_expressionContext) AllRelational_expression() []IRelational_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem())
	var tst = make([]IRelational_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelational_expressionContext)
		}
	}

	return tst
}

func (s *Equality_expressionContext) Relational_expression(i int) IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Equality_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equality_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Equality_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterEquality_expression(s)
	}
}

func (s *Equality_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitEquality_expression(s)
	}
}




func (p *ObjectiveCParser) Equality_expression() (localctx IEquality_expressionContext) {
	localctx = NewEquality_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ObjectiveCParserRULE_equality_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Relational_expression()
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__101 || _la == ObjectiveCParserT__102 {
		{
			p.SetState(957)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserT__101 || _la == ObjectiveCParserT__102) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(958)
			p.Relational_expression()
		}


		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IRelational_expressionContext is an interface to support dynamic dispatch.
type IRelational_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_expressionContext differentiates from other interfaces.
	IsRelational_expressionContext()
}

type Relational_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_expressionContext() *Relational_expressionContext {
	var p = new(Relational_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_relational_expression
	return p
}

func (*Relational_expressionContext) IsRelational_expressionContext() {}

func NewRelational_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_expressionContext {
	var p = new(Relational_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_relational_expression

	return p
}

func (s *Relational_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_expressionContext) AllShift_expression() []IShift_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem())
	var tst = make([]IShift_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_expressionContext)
		}
	}

	return tst
}

func (s *Relational_expressionContext) Shift_expression(i int) IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Relational_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Relational_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterRelational_expression(s)
	}
}

func (s *Relational_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitRelational_expression(s)
	}
}




func (p *ObjectiveCParser) Relational_expression() (localctx IRelational_expressionContext) {
	localctx = NewRelational_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ObjectiveCParserRULE_relational_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.Shift_expression()
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__8 || _la == ObjectiveCParserT__13 || _la == ObjectiveCParserT__103 || _la == ObjectiveCParserT__104 {
		{
			p.SetState(965)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserT__8 || _la == ObjectiveCParserT__13 || _la == ObjectiveCParserT__103 || _la == ObjectiveCParserT__104) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(966)
			p.Shift_expression()
		}


		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) AllAdditive_expression() []IAdditive_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem())
	var tst = make([]IAdditive_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditive_expressionContext)
		}
	}

	return tst
}

func (s *Shift_expressionContext) Additive_expression(i int) IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitShift_expression(s)
	}
}




func (p *ObjectiveCParser) Shift_expression() (localctx IShift_expressionContext) {
	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ObjectiveCParserRULE_shift_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.Additive_expression()
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__105 || _la == ObjectiveCParserT__106 {
		{
			p.SetState(973)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserT__105 || _la == ObjectiveCParserT__106) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(974)
			p.Additive_expression()
		}


		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAdditive_expressionContext is an interface to support dynamic dispatch.
type IAdditive_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditive_expressionContext differentiates from other interfaces.
	IsAdditive_expressionContext()
}

type Additive_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditive_expressionContext() *Additive_expressionContext {
	var p = new(Additive_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_additive_expression
	return p
}

func (*Additive_expressionContext) IsAdditive_expressionContext() {}

func NewAdditive_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Additive_expressionContext {
	var p = new(Additive_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_additive_expression

	return p
}

func (s *Additive_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Additive_expressionContext) AllMultiplicative_expression() []IMultiplicative_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem())
	var tst = make([]IMultiplicative_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicative_expressionContext)
		}
	}

	return tst
}

func (s *Additive_expressionContext) Multiplicative_expression(i int) IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Additive_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Additive_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Additive_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterAdditive_expression(s)
	}
}

func (s *Additive_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitAdditive_expression(s)
	}
}




func (p *ObjectiveCParser) Additive_expression() (localctx IAdditive_expressionContext) {
	localctx = NewAdditive_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ObjectiveCParserRULE_additive_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Multiplicative_expression()
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__31 || _la == ObjectiveCParserT__32 {
		{
			p.SetState(981)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserT__31 || _la == ObjectiveCParserT__32) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(982)
			p.Multiplicative_expression()
		}


		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IMultiplicative_expressionContext is an interface to support dynamic dispatch.
type IMultiplicative_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicative_expressionContext differentiates from other interfaces.
	IsMultiplicative_expressionContext()
}

type Multiplicative_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicative_expressionContext() *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_multiplicative_expression
	return p
}

func (*Multiplicative_expressionContext) IsMultiplicative_expressionContext() {}

func NewMultiplicative_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_multiplicative_expression

	return p
}

func (s *Multiplicative_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplicative_expressionContext) AllCast_expression() []ICast_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem())
	var tst = make([]ICast_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICast_expressionContext)
		}
	}

	return tst
}

func (s *Multiplicative_expressionContext) Cast_expression(i int) ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Multiplicative_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplicative_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Multiplicative_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterMultiplicative_expression(s)
	}
}

func (s *Multiplicative_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitMultiplicative_expression(s)
	}
}




func (p *ObjectiveCParser) Multiplicative_expression() (localctx IMultiplicative_expressionContext) {
	localctx = NewMultiplicative_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ObjectiveCParserRULE_multiplicative_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Cast_expression()
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__10 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserT__107 {
		{
			p.SetState(989)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ObjectiveCParserT__10 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserT__107) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(990)
			p.Cast_expression()
		}


		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ICast_expressionContext is an interface to support dynamic dispatch.
type ICast_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCast_expressionContext differentiates from other interfaces.
	IsCast_expressionContext()
}

type Cast_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_expressionContext() *Cast_expressionContext {
	var p = new(Cast_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_cast_expression
	return p
}

func (*Cast_expressionContext) IsCast_expressionContext() {}

func NewCast_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_expressionContext {
	var p = new(Cast_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_cast_expression

	return p
}

func (s *Cast_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Cast_expressionContext) Cast_expression() ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Cast_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Cast_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cast_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterCast_expression(s)
	}
}

func (s *Cast_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitCast_expression(s)
	}
}




func (p *ObjectiveCParser) Cast_expression() (localctx ICast_expressionContext) {
	localctx = NewCast_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ObjectiveCParserRULE_cast_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(996)
			p.Match(ObjectiveCParserT__18)
		}
		{
			p.SetState(997)
			p.Type_name()
		}
		{
			p.SetState(998)
			p.Match(ObjectiveCParserT__19)
		}
		{
			p.SetState(999)
			p.Cast_expression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1001)
			p.Unary_expression()
		}

	}


	return localctx
}


// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Postfix_expression() IPostfix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfix_expressionContext)
}

func (s *Unary_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Unary_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_expressionContext) Cast_expression() ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *Unary_expressionContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}




func (p *ObjectiveCParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ObjectiveCParserRULE_unary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1020)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ObjectiveCParserT__18, ObjectiveCParserT__21, ObjectiveCParserT__51, ObjectiveCParserT__52, ObjectiveCParserT__55, ObjectiveCParserT__56, ObjectiveCParserIDENTIFIER, ObjectiveCParserCHARACTER_LITERAL, ObjectiveCParserSTRING_LITERAL, ObjectiveCParserHEX_LITERAL, ObjectiveCParserDECIMAL_LITERAL, ObjectiveCParserOCTAL_LITERAL, ObjectiveCParserFLOATING_POINT_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1004)
			p.Postfix_expression()
		}


	case ObjectiveCParserT__108:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1005)
			p.Match(ObjectiveCParserT__108)
		}
		{
			p.SetState(1006)
			p.Unary_expression()
		}


	case ObjectiveCParserT__109:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1007)
			p.Match(ObjectiveCParserT__109)
		}
		{
			p.SetState(1008)
			p.Unary_expression()
		}


	case ObjectiveCParserT__32, ObjectiveCParserT__71, ObjectiveCParserT__100, ObjectiveCParserT__111, ObjectiveCParserT__112:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1009)
			p.Unary_operator()
		}
		{
			p.SetState(1010)
			p.Cast_expression()
		}


	case ObjectiveCParserT__110:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1012)
			p.Match(ObjectiveCParserT__110)
		}
		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1013)
				p.Match(ObjectiveCParserT__18)
			}
			{
				p.SetState(1014)
				p.Type_name()
			}
			{
				p.SetState(1015)
				p.Match(ObjectiveCParserT__19)
			}


		case 2:
			{
				p.SetState(1017)
				p.Unary_expression()
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}




func (p *ObjectiveCParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ObjectiveCParserRULE_unary_operator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1022)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ObjectiveCParserT__32 || _la == ObjectiveCParserT__71 || _la == ObjectiveCParserT__100 || _la == ObjectiveCParserT__111 || _la == ObjectiveCParserT__112) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IPostfix_expressionContext is an interface to support dynamic dispatch.
type IPostfix_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfix_expressionContext differentiates from other interfaces.
	IsPostfix_expressionContext()
}

type Postfix_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfix_expressionContext() *Postfix_expressionContext {
	var p = new(Postfix_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_postfix_expression
	return p
}

func (*Postfix_expressionContext) IsPostfix_expressionContext() {}

func NewPostfix_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Postfix_expressionContext {
	var p = new(Postfix_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_postfix_expression

	return p
}

func (s *Postfix_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Postfix_expressionContext) Primary_expression() IPrimary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_expressionContext)
}

func (s *Postfix_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Postfix_expressionContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Postfix_expressionContext) AllArgument_expression_list() []IArgument_expression_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgument_expression_listContext)(nil)).Elem())
	var tst = make([]IArgument_expression_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgument_expression_listContext)
		}
	}

	return tst
}

func (s *Postfix_expressionContext) Argument_expression_list(i int) IArgument_expression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgument_expression_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgument_expression_listContext)
}

func (s *Postfix_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Postfix_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Postfix_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterPostfix_expression(s)
	}
}

func (s *Postfix_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitPostfix_expression(s)
	}
}




func (p *ObjectiveCParser) Postfix_expression() (localctx IPostfix_expressionContext) {
	localctx = NewPostfix_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ObjectiveCParserRULE_postfix_expression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Primary_expression()
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__12 || _la == ObjectiveCParserT__18 || _la == ObjectiveCParserT__52 || ((((_la - 109)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 109))) & ((1 << (ObjectiveCParserT__108 - 109)) | (1 << (ObjectiveCParserT__109 - 109)) | (1 << (ObjectiveCParserT__113 - 109)))) != 0) {
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ObjectiveCParserT__52:
			{
				p.SetState(1025)
				p.Match(ObjectiveCParserT__52)
			}
			{
				p.SetState(1026)
				p.Expression()
			}
			{
				p.SetState(1027)
				p.Match(ObjectiveCParserT__53)
			}


		case ObjectiveCParserT__18:
			{
				p.SetState(1029)
				p.Match(ObjectiveCParserT__18)
			}
			p.SetState(1031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if ((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (ObjectiveCParserT__18 - 19)) | (1 << (ObjectiveCParserT__21 - 19)) | (1 << (ObjectiveCParserT__32 - 19)))) != 0) || ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (ObjectiveCParserT__51 - 52)) | (1 << (ObjectiveCParserT__52 - 52)) | (1 << (ObjectiveCParserT__55 - 52)) | (1 << (ObjectiveCParserT__56 - 52)) | (1 << (ObjectiveCParserT__71 - 52)))) != 0) || ((((_la - 101)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 101))) & ((1 << (ObjectiveCParserT__100 - 101)) | (1 << (ObjectiveCParserT__108 - 101)) | (1 << (ObjectiveCParserT__109 - 101)) | (1 << (ObjectiveCParserT__110 - 101)) | (1 << (ObjectiveCParserT__111 - 101)) | (1 << (ObjectiveCParserT__112 - 101)) | (1 << (ObjectiveCParserIDENTIFIER - 101)) | (1 << (ObjectiveCParserCHARACTER_LITERAL - 101)) | (1 << (ObjectiveCParserSTRING_LITERAL - 101)) | (1 << (ObjectiveCParserHEX_LITERAL - 101)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 101)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 101)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 101)))) != 0) {
				{
					p.SetState(1030)
					p.Argument_expression_list()
				}

			}
			{
				p.SetState(1033)
				p.Match(ObjectiveCParserT__19)
			}


		case ObjectiveCParserT__12:
			{
				p.SetState(1034)
				p.Match(ObjectiveCParserT__12)
			}
			{
				p.SetState(1035)
				p.Identifier()
			}


		case ObjectiveCParserT__113:
			{
				p.SetState(1036)
				p.Match(ObjectiveCParserT__113)
			}
			{
				p.SetState(1037)
				p.Identifier()
			}


		case ObjectiveCParserT__108:
			{
				p.SetState(1038)
				p.Match(ObjectiveCParserT__108)
			}


		case ObjectiveCParserT__109:
			{
				p.SetState(1039)
				p.Match(ObjectiveCParserT__109)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArgument_expression_listContext is an interface to support dynamic dispatch.
type IArgument_expression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgument_expression_listContext differentiates from other interfaces.
	IsArgument_expression_listContext()
}

type Argument_expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgument_expression_listContext() *Argument_expression_listContext {
	var p = new(Argument_expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_argument_expression_list
	return p
}

func (*Argument_expression_listContext) IsArgument_expression_listContext() {}

func NewArgument_expression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Argument_expression_listContext {
	var p = new(Argument_expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_argument_expression_list

	return p
}

func (s *Argument_expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Argument_expression_listContext) AllAssignment_expression() []IAssignment_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem())
	var tst = make([]IAssignment_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignment_expressionContext)
		}
	}

	return tst
}

func (s *Argument_expression_listContext) Assignment_expression(i int) IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Argument_expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Argument_expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Argument_expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterArgument_expression_list(s)
	}
}

func (s *Argument_expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitArgument_expression_list(s)
	}
}




func (p *ObjectiveCParser) Argument_expression_list() (localctx IArgument_expression_listContext) {
	localctx = NewArgument_expression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ObjectiveCParserRULE_argument_expression_list)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Assignment_expression()
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == ObjectiveCParserT__24 {
		{
			p.SetState(1046)
			p.Match(ObjectiveCParserT__24)
		}
		{
			p.SetState(1047)
			p.Assignment_expression()
		}


		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitIdentifier(s)
	}
}




func (p *ObjectiveCParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ObjectiveCParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Match(ObjectiveCParserIDENTIFIER)
	}



	return localctx
}


// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ObjectiveCParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ObjectiveCParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserDECIMAL_LITERAL, 0)
}

func (s *ConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserHEX_LITERAL, 0)
}

func (s *ConstantContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserOCTAL_LITERAL, 0)
}

func (s *ConstantContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserCHARACTER_LITERAL, 0)
}

func (s *ConstantContext) FLOATING_POINT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ObjectiveCParserFLOATING_POINT_LITERAL, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ObjectiveCListener); ok {
		listenerT.ExitConstant(s)
	}
}




func (p *ObjectiveCParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ObjectiveCParserRULE_constant)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 116)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 116))) & ((1 << (ObjectiveCParserCHARACTER_LITERAL - 116)) | (1 << (ObjectiveCParserHEX_LITERAL - 116)) | (1 << (ObjectiveCParserDECIMAL_LITERAL - 116)) | (1 << (ObjectiveCParserOCTAL_LITERAL - 116)) | (1 << (ObjectiveCParserFLOATING_POINT_LITERAL - 116)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


